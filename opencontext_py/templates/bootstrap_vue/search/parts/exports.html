{% block search_exporter %}

{% load humanize %}

<template id="search_exporter_selectable_dl_attribs">
    <b-list-group-item v-if="show_attribs_exist">
        <b-row>
            <b-col cols="3">
                <strong v-if="data_type == 'id'">
                    Types or Relations
                </strong>
                <strong v-else-if="data_type == 'int'">
                    Integer
                </strong>
                <strong v-else-if="data_type == 'double'">
                    Decimal
                </strong>
                <strong v-else-if="data_type == 'date'">
                    Date
                </strong>
                <strong v-else-if="data_type == 'bool'">
                    Boolean (T/F)
                </strong>
                <strong v-else>
                    Free text
                </strong>
            </b-col>
            <b-col cols="9">
                <div v-for="(freq_type, ft_index) in attrib_freq_types">
                    <div v-if="show_attribs[freq_type].length > 0">
                        <span>Fields used with [[ freq_type ]] records</span><br/>
                        <span v-for="(attrib, index) in show_attribs[freq_type]">
                            <b-button
                                class="download-selected-attribs"
                                pill
                                size="sm"
                                variant="outline-primary"
                                :title="'Click to add \'' + attrib.label + '\''"
                                @click="add_selected_attrib(attrib)"
                                >
                                [[ attrib.s_label ]] <b-icon-plus-circle-fill></b-icon-plus-circle-fill>
                            </b-button>
                        </span>
                    </div>
                </div>
            </b-col>
        </b-row>
    </b-list-group-item>
</template>


<template id="search_exporter_ui">
    <b-modal
        size="xl"
        scrollable
        class="exporter-ui-modal"
        ref="exporter-modal"
        id="exporter-modal"
        title="Export Records for Download"
        @shown="on_shown"
    >
        <b-row>
            <b-col cols="12">
                <p>This tool exports the current set of records as a data table or a GIS output. 
                    GIS exports can be saved and previewed on the search result map. For convenience, 
                    these outputs represent data in somewhat simplified formats. If you need more 
                    expressive and complete representations of these data, 
                    please see the <a href="../../about/services" target="_blank">API documentation</a>. 
                    Please also note that location data for certain records may be approximated as a 
                    security precaution or because precise data is not available.
                </p>
            </b-col>
        </b-row>

        <b-row id="download-prog-bar-row">
            <b-col cols="12">

                <b-row v-if="dl_progress" class="progress_row">
                    <b-col cols="12">
              
                      <b-progress max="1" height="2rem" variant="secondary">
                        <b-progress-bar :value="dl_progress">
                          <span><strong>[[ (dl_progress * 100).toFixed(1) ]] %</strong> ([[ dl_message ]])</span>
                        </b-progress-bar>
                      </b-progress>
              
                    </b-col>
                </b-row>
                
            </b-col>
        </b-row>

        <b-row id="download-attribs-save-opts-row" >
            <b-col cols="6">
                <b-row>
                    <b-col cols="12">
                        <h5>Fields / Attributes to Include in Export</h5>
                        <small>Default attributes:</small><br/>
                        <span v-for="(attrib, index) in default_attribs">
                            <b-badge
                                pill
                                class="download-default-attribs"
                                title="Default, always included attribute"
                                variant="secondary">
                                [[ attrib ]]
                            </b-badge>
                        </span>
                        <div id="download-selected-attribs-div" if="act_download_attribs">
                            <small>Selected optional attributes:</small><br/>
                            <span v-for="(attrib, index) in act_download_attribs">
                                <b-button
                                    class="download-selected-attribs"
                                    pill
                                    size="sm"
                                    variant="primary"
                                    :title="'Click to remove \'' + attrib.label + '\''"
                                    @click="remove_selected_attrib(attrib)"
                                    :disabled="dl_started || dl_complete"
                                    >
                                    [[ attrib.s_label ]] <b-icon-dash-circle-fill></b-icon-dash-circle-fill>
                                </b-button>
                            </span>
                        </div>
                    </b-col>
                </b-row>

                <b-row id="download-dl-button-row" v-if="!dl_started">
                    <b-col cols="12">
                        <b-alert show variant="info">
                            <small>
                                After you have selected attributes to include in your download, click the button below to 
                                begin the download. Once the download is complete, you will see options to save the downloaded
                                records on your device. 
                            </small>
                            <br/>
                            <br/>
                            <b-button
                                block
                                :disabled="dl_button_disable"
                                size="sm" 
                                variant="primary" 
                                @click="get_records">
                                <b-icon-download></b-icon-download> Download
                            </b-button>
                        </b-alert>
                    </b-col>
                </b-row>

            </b-col>
            <b-col cols="6">
                <b-row>
                    <b-col cols="12">
                        <div v-if="dl_started & !dl_complete" class="text-center">
                            <h5>Download of <strong>[[ human_act_total_count ]]</strong> records in progress...</h5>
                            <b-spinner variant="success" label="Spinning"></b-spinner>
                        </div>
                        <b-alert show variant="info" v-else-if="dl_complete">
                            <h5 class="text-center">Download of <strong>[[ human_act_total_count ]]</strong> records completed.</h5>
                            <p>Data for all records are fully downloaded and can be saved on your device in a tabular (CSV) and/or 
                            a GIS (GeoJSON) format using the buttons below.
                            </p>

                            <b-row align-v="center" class="download-filesave-row">
                                <b-col cols="8">
                                    <small><strong>CSV (Comma Separated Value)</strong> format to save data as a
                                        table for use in a spreadsheet, database application, or 
                                        analysid using scripting languages like
                                        <strong>R</strong> or <strong>Python</strong>.
                                    </small>
                                </b-col>
                                <b-col cols="4">
                                    <vue-json-to-csv
                                        v-bind:json-data="dl_csv_data">
                                        <b-button variant="primary">Save Data as CSV <b-icon-table></b-icon-table>
                                        </b-button>
                                    </vue-json-to-csv>
                                </b-col>
                            </b-row>
                            <b-row align-v="center" class="download-filesave-row">
                                <b-col cols="8">
                                    <small><strong>GeoJSON</strong> format to save data for use in a GIS application like QGIS or ArcGIS.
                                        GeoJSON is a widely supported and
                                        <a href="https://en.wikipedia.org/wiki/GeoJSON" target="_blank">nonproprietary Internet standard</a>.
                                    </small>
                                </b-col>
                                <b-col cols="4">
                                    <b-button
                                        @click="save_dl_geojson"
                                        variant="primary">Save Data as GeoJSON (GIS) <b-icon-pin-map-fill></b-icon-pin-map-fill>
                                    </b-button>
                                </b-col>
                            </b-row>

                            <p><strong><b-icon-gear-fill></b-icon-gear-fill> Advanced Options</strong><br/>
                                <small>Some attributes may have multiple values. 
                                    Select how multi-valued attributes should be expressed in saved files.
                                </small>
                            </p>

                            <b-form-group>
                                <b-form-radio v-model="multi_value_save_option" name="multi_value_save_option" value="separate-fields">Split values across added fields</b-form-radio>
                                <b-form-radio v-model="multi_value_save_option" name="multi_value_save_option" value="delimiter">Join multiple values using a delimiter</b-form-radio>
                            </b-form-group>

                            <b-row v-if="multi_value_save_option == 'delimiter'" align-v="center">
                                <b-col cols="3" class="text-right">Multi-value Delimiter</b-col>
                                <b-col cols="2">
                                    <b-form-input maxlength="4" type="text" v-model="multi_value_delim" value="multi_value_delim"></b-form-input>
                                </b-col>
                                <b-col cols="7"><small><strong>[[ delim_example.list ]]</strong> becomes<br/><strong>[[ delim_example.joined ]]</strong></small></b-col>
                            </b-row>


                        </b-alert>
                        <div v-if="!dl_started">
                            <div class="accordion" role="tablist" v-if="act_attribs">
                                <h5>Choose Additional Fields / Attributes to Include in Export</h5>
                                <b-card 
                                    no-body
                                    class="mb-1"
                                    v-for="(attrib_grp, a_grp_index) in act_attribs">
                                    <b-card-header header-tag="header" class="p-1" role="tab">
                                        <b-button 
                                            block
                                            v-b-toggle="'attrib_grp_panel_' + a_grp_index"
                                            variant="secondary"><i class="bi bi-arrows-expand"></i> [[attrib_grp.label]]</b-button>
                                    </b-card-header>
                                    <b-collapse 
                                        :id="'attrib_grp_panel_' + a_grp_index"
                                        visible
                                        :accordion="'attrib_grp_panel_accordion_' + a_grp_index" 
                                        role="tabpanel">
                                        <b-card-body>
                                            <small v-if="attrib_grp.note">[[attrib_grp.note]]</small>
                                            <b-list-group flush>
                                                
                                                <selectable-dl-attribs
                                                    v-for="(attrib_dt_grp, a_dt_grp_index) in attrib_grp.attribs"
                                                    v-bind:attrib_freq_types="attrib_freq_types"
                                                    v-bind:attrib_dt_grp="attrib_dt_grp"
                                                    v-bind:data_type="attrib_dt_grp.data_type"
                                                    v-bind:act_download_attribs="act_download_attribs">
                                                </selectable-dl-attribs>
                                                    
                                            </b-list-group>
                                        </b-card-body>
                                    </b-collapse>
                                </b-card>
                            </div>
                            <div v-else>
                                Download not currently supported.
                            </div>
                        </div>
                    </b-col>
                </b-row>
            </b-col>
        </b-row>

       
        <template #modal-footer="{ ok, cancel, hide }">
            <b-button size="sm" variant="outline-secondary" @click="cancel_close">
              Cancel
            </b-button>
          </template>
    </b-modal>
</template>
    

<script type="text/javascript">
Vue.use(VueJsonToCsv);
/*
const vc_json_to_csv = Vue.component(
    'vue-json-to-csv', 
    window.VueJsonToCsv,
);
*/

var vc_selectable_dl_attribs = Vue.component(
    'selectable-dl-attribs',
    {
        delimiters: ['[[', ']]'],
        props: [
            'attrib_dt_grp',
            'data_type',
            'attrib_freq_types',
            'act_download_attribs',
        ],
        data() {
            return {
                attrib_dt_grp: null,
                data_type: null,
                attrib_freq_types: null,
                act_download_attribs: null,
            };
        },
        computed: {
            show_attribs_exist: function() {
                if(this.attrib_dt_grp == null || this.act_download_attribs == null){
                    return false;
                }
                if(this.attrib_freq_types == null){
                    return false;
                }
                let output = false;
                for(let freq_type of this.attrib_freq_types){
                    if(!this.attrib_dt_grp.hasOwnProperty(freq_type)){
                        continue;
                    }
                    for(let attrib of this.attrib_dt_grp[freq_type]){
                        if(this.in_download_attribs(attrib)){
                            continue;
                        }
                        output = true;
                    }
                }
                return output;
            },
            show_attribs: function(){
                if(this.attrib_dt_grp == null || this.act_download_attribs == null){
                    return false;
                }
                if(this.attrib_freq_types == null){
                    return false;
                }
                let show_attribs = {};
                for(let freq_type of this.attrib_freq_types){
                    show_attribs[freq_type] = [];
                    if(!this.attrib_dt_grp.hasOwnProperty(freq_type)){
                        continue;
                    }
                    for(let attrib of this.attrib_dt_grp[freq_type]){
                        if(this.in_download_attribs(attrib)){
                            continue;
                        }
                        show_attribs[freq_type].push(attrib);
                    }
                }
                return show_attribs;
            }
        },
        template: '#search_exporter_selectable_dl_attribs',
        methods: {
            in_download_attribs: function(attrib){
                for(let act_attrib of this.act_download_attribs){
                    if(act_attrib.slug == attrib.slug){
                        return true;
                    }
                }
                return false;
            },
            add_selected_attrib: function(attrib){
                this.act_download_attribs.push(attrib);
            },
        }
    }
);

var vc_search_exporter_ui = Vue.component(
    'search-exporter-ui',
    {
        delimiters: ['[[', ']]'],
        props: [
            'result',
            'base_search_url',
        ],
        data() {
            return {
                result: null,
                base_search_url: null,
                exclude_fields: [
                    'id',
                    'feature-type',
                    'href',
                ],
                default_field_mappings: {
                    'uri': 'URI',
                    'citation uri': 'Citation URI',
                    'label': 'Item Label',
                    'project label': 'Project Label',
                    'project href': 'Project URI',
                    'context label': 'Context',
                    'context href': 'Context URI',
                    'latitude': 'Latitude (WGS-84)',
                    'longitude': 'Longitude (WGS-84)',
                    'early bce/ce': 'Early BCE/CE',
                    'late bce/ce': 'Late BCE/CE',
                    'item category': 'Item Category',
                    'published': 'Published Date',
                    'updated': 'Updated Date',
                },
                sleep_pause: 325,
                max_export: 200000,
                records_per_page: 100,
                default_csv_name: 'open-context-records',
                default_geojson_name: 'open-context-geo-spatial-records',
                param_response_value: 'metadata,geo-record',
                default_add_common_attribs: true,
                attrib_freq_types: ['most', 'many', 'some', 'few'],
                multi_value_save_option: 'delimiter',
                multi_value_delim: '|',
                csv_null_value: "",
                record_sets: null,
                base_search_url_export_states: null,
                initial_export_states: {
                    loading: false,
                    error: null,
                    act_attribs: null,
                    act_download_attribs: null,
                    act_start_url: null,
                    act_page_url: null,
                    act_total_count: null,
                    act_downloaded_count: null,
                    dl_started: false,
                    dl_complete: null,
                },
                loading: false,
                error: null,
                act_attribs: null,
                act_download_attribs: null,
                act_start_url: null,
                act_page_url: null,
                act_total_count: null,
                act_downloaded_count: null,
                dl_started: false,
                dl_complete: null,
            }
        },
        template: '#search_exporter_ui',
        computed: {
            default_attribs: function() {
                let attribs = [];
                for(let [key, val] of Object.entries(this.default_field_mappings)){
                    attribs.push(val);
                }
                return attribs;
            },
            human_act_total_count: function(){
                if(this.act_downloaded_count == null){
                    return null;
                }
                return this.act_downloaded_count.toLocaleString();
            },
            dl_button_disable: function(){
                if(this.act_downloaded_count == null){
                    return false;
                }
                return true;
            },
            dl_progress: function(){
                if(this.act_total_count == null){
                    return null;
                }
                let dl_count = this.act_downloaded_count;
                if(this.act_total_count == 0){
                    return 1;
                }
                if(dl_count == null){
                    dl_count = 0;
                }
                let prop_done = dl_count / this.act_total_count;
                return prop_done;
            },
            dl_message: function(){
                if(this.act_total_count == null){
                    return null;
                }
                let dl_count = this.act_downloaded_count;
                if(dl_count == null){
                    dl_count = 0;
                }
                if(this.act_total_count < 1){
                    return 'No records to download';
                }
                return `${dl_count} of ${this.act_total_count} records downloaded`;
            },
            delim_example: function() {
                if(this.multi_value_save_option != 'delimiter'){
                    return null;
                }
                let vals = ['Rim', 'Handle', 'Base'];
                let vals_json = JSON.stringify(vals);
                let vals_joined = vals.join(this.multi_value_delim);
                return {list: vals_json, joined: vals_joined};
            },
            dl_csv_data: function(){
                let raw_features = this.gather_act_geojson_features();
                if(raw_features == null){
                    return null;
                }
                let data = [];
                for(let feature of raw_features){
                    if(!feature.hasOwnProperty('geometry')){
                        continue;
                    }
                    if(!feature.hasOwnProperty('properties')){
                        continue;
                    }
                    feature.properties = this.add_lat_lon_fields(
                        feature
                    );
                    let clean_props = this.props_to_multivalue_output(
                        feature.properties,
                        true
                    );
                    data.push(clean_props);
                }
                return this.fill_in_missing_fields(data);
            },
        },
        mounted(){
            this.set_base_search_url_export_state();
        },
        methods: {
            set_base_search_url_export_state: function() {
                if(this.base_search_url_export_states == null){
                    this.base_search_url_export_states = {ok: true};
                }
                let base_search_url = this.base_search_url;
                if(!this.base_search_url_export_states.hasOwnProperty(base_search_url)){
                    // So as not to mutate this.
                    this.base_search_url_export_states[base_search_url] = JSON.parse(JSON.stringify(this.initial_export_states));
                }
                let act_state = this.base_search_url_export_states[base_search_url];
                this.loading = act_state.loading;
                this.error = act_state.error;
                this.act_attribs = act_state.act_attribs;
                this.act_download_attribs = act_state.act_download_attribs;
                this.act_start_url =  act_state.act_start_url;
                this.act_page_url = act_state.act_page_url;
                this.act_total_count = act_state.act_total_count;
                this.act_downloaded_count = act_state.act_downloaded_count;
                this.dl_started = act_state.dl_started;
                this.dl_complete = act_state.dl_complete;
            },
            on_shown: function(){
                this.set_base_search_url_export_state();
                if(this.act_attribs == null){
                    this.make_act_attribs();
                }
                return null;
            },
            cancel_close: function(){
                this.$bvModal.hide('exporter-modal');
            },
            skip_excluded_property_key: function(key){
                if(this.exclude_fields.indexOf(key) >= 0){
                    return true;
                }
                return false;
            },
            map_property_key_to_field: function(key){
                if(this.default_field_mappings.hasOwnProperty(key)){
                   return this.default_field_mappings[key];
                }
                return key;
            },
            fill_in_missing_fields: function(raw_data){
                let data = JSON.parse(JSON.stringify(raw_data));
                let field_list = [];
                let rec_i = 0;
                for(let rec of data){
                    let i = 0;
                    for(let [field, val] of Object.entries(rec)){
                        if(field_list.indexOf(field) >=0 ){
                            continue;
                        }
                        if(rec_i < 1){
                            field_list.push(field);
                        }
                        else{
                            // this adds the field while preserving consisting ordering
                            field_list.splice(i, 0, field);
                        }
                        i +=1;
                    }
                    rec_i += 1;
                }
                let new_data = [];
                for(let rec of data){
                    for(let field of field_list){
                        if(rec.hasOwnProperty(field)){
                            continue;
                        }
                        rec[field] = this.csv_null_value;
                    }
                    new_data.push(rec);
                }
                return new_data;
            },
            add_lat_lon_fields: function(feature){
                let lat_p = 'Latitude (WGS 84)';
                let lon_p = 'Longitude (WGS 84)'
                let lat = null;
                let lon = null;
                if (feature.geometry.type === 'Point') {
                    lon = feature.geometry.coordinates[0];
                    lat = feature.geometry.coordinates[1];
                }
                else if (feature.geometry.type === 'Polygon') {
                    
                    let centroid = turf.centroid(feature);
                    lon = centroid.geometry.coordinates[0];
                    lat = centroid.geometry.coordinates[1];
                }
                else {
                    return feature.properties;
                }
                if(lat == null || lon == null){
                    return feature.properties;
                }
                let prop_keys = [];
                for(let [key, val] of Object.entries(feature.properties)){
                    prop_keys.push(key);
                }
                let context_index = prop_keys.indexOf('context href');
                if(context_index >= 0){
                    prop_keys.splice((context_index + 1), 0, lat_p, lon_p);
                }
                else{
                    prop_keys.push(lat_p);
                    prop_keys.push(lon_p);
                }
                let new_properties = {};
                for(let p_field of prop_keys){
                    if(feature.properties.hasOwnProperty(p_field)){
                        new_properties[p_field] = feature.properties[p_field];
                    }
                    else if (p_field == lat_p){
                        new_properties[p_field] = lat;
                    }
                    else if (p_field == lon_p){
                        new_properties[p_field] = lon;
                    }
                    else{
                        continue;
                    }
                }
                return new_properties;
            },
            add_multivalue_fields_for_mapped_key: function(mapped_key, val_list, clean_props){
                let act_key = mapped_key;
                let val_index = 1;
                for(let act_val of val_list){
                    clean_props[act_key] = act_val;
                    val_index += 1;
                    act_key = `${mapped_key} [${val_index}]`;
                }
                return clean_props;
            },
            props_to_seperate_multivalue_fields: function(properties, split_contexts){
                // Reformat properties so multi-values are put into different
                // fields.
                let clean_props = {};
                for(let [key, val] of Object.entries(properties)){
                    if(this.skip_excluded_property_key(key)){
                        continue;
                    }
                    let mapped_key = this.map_property_key_to_field(key);
                    let val_list = [val];
                    if(split_contexts && mapped_key == 'Context'){
                        val_list = val.split('/');
                    }
                    else{
                        if(Array.isArray(val)){
                            val_list = val;
                        }
                    }
                    clean_props = this.add_multivalue_fields_for_mapped_key(
                        mapped_key, 
                        val_list, 
                        clean_props
                    );
                }
                return clean_props;
            },
            props_to_join_multivalues: function(properties, split_contexts){
                // Reformat properties so multi-values are joined into a single
                // string value split by a delimiter.
                let clean_props = {};
                for(let [key, val] of Object.entries(properties)){
                    if(this.skip_excluded_property_key(key)){
                        continue;
                    }
                    let mapped_key = this.map_property_key_to_field(key);
                    if(split_contexts && mapped_key == 'Context'){
                        // Special treatment for the 'Context' field.
                        val_list = val.split('/');
                        clean_props = this.add_multivalue_fields_for_mapped_key(
                            mapped_key, 
                            val_list, 
                            clean_props
                        );
                        // Skip the rest.
                        continue;
                    }
                    let act_val = val;
                    if(Array.isArray(val)){
                        act_val = val.join(this.multi_value_delim);
                    }
                    clean_props[mapped_key] = act_val;
                }
                return clean_props;
            },
            props_to_mapped_fields_no_multi_value_change: function(properties){
                let clean_props = {};
                for(let [key, val] of Object.entries(properties)){
                    if(this.skip_excluded_property_key(key)){
                        continue;
                    }
                    let mapped_key = this.map_property_key_to_field(key);
                    clean_props[mapped_key] = val;
                }
                return clean_props;
            },
            props_to_multivalue_output: function(raw_properties, split_contexts){
                let properties = JSON.parse(JSON.stringify(raw_properties)); // prevent mutation of the result.
                if(this.multi_value_save_option === 'separate-fields'){
                    return this.props_to_seperate_multivalue_fields(properties, split_contexts);
                }
                else if(this.multi_value_save_option === 'delimiter'){
                    return this.props_to_join_multivalues(properties, split_contexts);
                }
                else{
                    return this.props_to_mapped_fields_no_multi_value_change(properties);
                }
            },
            save_file: function(str_data, file_name, mime_type) {
                const blob = new Blob([str_data], {type: 'text/plain'})
                const e = document.createEvent('MouseEvents'),
                a = document.createElement('a');
                a.download = file_name;
                a.href = window.URL.createObjectURL(blob);
                a.dataset.downloadurl = [mime_type, a.download, a.href].join(':');
                e.initEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                a.dispatchEvent(e);
            },
            gather_act_geojson_features: function() {
                if(!this.dl_complete){
                    return null;
                }
                let act_record_set = this.get_act_record_set();
                if(act_record_set == null){
                    return null;
                }
                let features = [];
                for(let page of act_record_set.pages){
                    if(!page.hasOwnProperty('features')){
                        continue;
                    }
                    for(let feature of page.features){
                        features.push(feature);
                    }
                }
                return JSON.parse(JSON.stringify(features)); // prevent mutation of the result.
            },
            save_dl_geojson: function(){
                let raw_features = this.gather_act_geojson_features();
                if(raw_features == null){
                    return null;
                }
                let features = [];
                for(let feature of raw_features){
                    if(!feature.hasOwnProperty('properties')){
                        continue;
                    }
                    feature.properties = this.props_to_multivalue_output(feature.properties, false);
                    features.push(feature);
                }
                let str_data = JSON.stringify(
                    {type: 'FeatureCollection', features: features}, 
                    null, 
                    4
                );
                this.save_file(
                    str_data, 
                    'open-context-geojson.json', 
                    'text/json'
                );
            },
            remove_selected_attrib: function(attrib){
                console.log('Remove click');
                console.log(attrib);
                let rev_attribs = [];
                for(let act_attrib of this.act_download_attribs){
                    if(act_attrib.slug == attrib.slug){
                        continue
                    }
                    rev_attribs.push(act_attrib);
                }
                this.act_download_attribs = rev_attribs;
                return true;
            },
            in_download_attribs: function(attrib){
                for(let act_attrib of this.act_download_attribs){
                    if(act_attrib.slug == attrib.slug){
                        return true;
                    }
                }
                return false;
            },
            make_record_fetch_start_url: function(url){
                let params_vals = [
                    {p: 'rows', v: this.records_per_page,},
                    {p: 'start', v: 0,},
                ];
                for (let p_v of params_vals){
                    url = replaceURLparameter(url, p_v.p, p_v.v);
                }
                return url;
            },
            make_attribute_lists: function(metadata){
                let all_attribs = [];
                if(!metadata.hasOwnProperty('oc-api:has-facets')){
                    return all_attribs;
                }
                for (let f_field of metadata['oc-api:has-facets']){
                    if(!f_field.hasOwnProperty('type')){
                        continue;
                    }
                    if(f_field.type != 'oc-api:facet-prop'){
                        continue;
                    }
                    let is_standard = false;
                    f_field.note = (
                        'Project defined attributes, not in wider use '
                        + 'across multiple data sources.'
                    );
                    if(f_field.label.indexOf('Standard') >=0 ){
                        is_standard = true;
                        f_field.note = 'Attributes used in common across multiple projects and data sources.';
                    }
                    f_field.attribs = [];
                    let attrib_opt_count = 0;
                    for (let opts_conf of FACETS_OPTIONS_LISTS_AND_DATA_TYPES) {
                        if (!(opts_conf.list_key in f_field)){
                            // Nothing to do, so keep on looping to check for other kinds of
                            // options lists.
                            continue;
                        }
                        let act_data_type_attribs = {
                            data_type: opts_conf.data_type,
                            most: [],
                            many: [],
                            some: [],
                            few: [],
                        };
                        for(let act_opt of f_field[opts_conf.list_key]){
                            act_opt.percent = Math.round(act_opt.count / metadata.totalResults, 2) * 100;
                            act_opt.s_label = act_opt.label;
                            if(!is_standard && act_opt.hasOwnProperty('rdfs:isDefinedBy')){
                                if(act_opt['rdfs:isDefinedBy'].indexOf('/predicates/') < 0){
                                    // This is NOT a predicate, so it's not a descriptive attribute.
                                    continue;
                                }
                            }
                            if (act_opt.s_label.length > 36) {
                                act_opt.s_label = act_opt.label.substring(0, 34) + '..';
                            }
                            if(act_opt.percent >=75){
                                act_data_type_attribs.most.push(act_opt);
                                attrib_opt_count += 1;
                            }
                            else if (act_opt.percent >= 33 && act_opt.percent < 75) {
                                act_data_type_attribs.many.push(act_opt);
                                attrib_opt_count += 1;
                            }
                            else if (act_opt.percent >= 10 && act_opt.percent < 33) {
                                act_data_type_attribs.some.push(act_opt);
                                attrib_opt_count += 1;
                            }
                            else{
                                act_data_type_attribs.few.push(act_opt);
                                attrib_opt_count += 1;
                            }
                        }
                        f_field.attribs.push(act_data_type_attribs);
                    }
                    if(attrib_opt_count < 1){
                        continue;
                    }
                    all_attribs.push(f_field);
                }
                return all_attribs;
            },
            make_act_attribs: function(){
                if(this.act_attribs != null){
                    // this is already defined.
                    return null;
                }
                if(!this.result){
                    this.act_attribs = null;
                    return null;
                }
                let start_metadata = JSON.parse(JSON.stringify(this.result)); // prevent mutation of the result.
                if(start_metadata.hasOwnProperty('features')){
                    delete start_metadata.features;
                }
                console.log('Made act attribs');
                this.act_attribs = this.make_attribute_lists(start_metadata);
                console.log(this.act_attribs);
                if(this.default_add_common_attribs){
                    this.act_download_attribs = [];
                    for(let field_grp of this.act_attribs){
                        if(!field_grp.hasOwnProperty('attribs')){
                            continue;
                        }
                        for(let dt_attribs of field_grp.attribs){
                            if(!dt_attribs.hasOwnProperty('most')){
                                continue;
                            }
                            for(let attrib of dt_attribs.most){
                                if(!attrib.hasOwnProperty('slug')){
                                    continue;
                                }
                                this.act_download_attribs.push(attrib);
                            }
                        }
                    }
                    console.log('Added default download attribs ' + this.act_download_attribs.length);
                    console.log(this.act_download_attribs);
                }
            },
            prep_record_fetches: function(){
                this.act_start_url = this.make_record_fetch_start_url(
                    this.base_search_url
                );

                let attrib_slugs = [];
                for(let attrib of this.act_download_attribs){
                    if(!attrib.hasOwnProperty('slug')){
                        continue;
                    }
                    attrib_slugs.push(attrib.slug);
                }
                if(attrib_slugs.length > 0){
                    this.act_start_url = replaceURLparameter(
                        this.act_start_url,
                        'attributes',
                        attrib_slugs.join(',')
                    );
                }

                let act_start_url = this.act_start_url;
                if(this.record_sets == null){
                    this.record_sets = {
                        ok: true,
                    };
                }
                if(act_start_url in this.record_sets && this.record_sets[act_start_url] != null){
                    return this.record_sets[act_start_url].metadata.totalResults;
                }
                
                let start_metadata = JSON.parse(JSON.stringify(this.result)); // prevent mutation of the result.
                if(start_metadata.hasOwnProperty('features')){
                    delete start_metadata.features;
                }
                this.record_sets[act_start_url] = {
                    label: this.default_csv_name,
                    metadata: start_metadata,
                    pages: [],
                }
                return this.record_sets[act_start_url].metadata.totalResults;
            },
            get_act_record_set: function(){
                let act_start_url = this.act_start_url;
                if((act_start_url == null) || (this.record_sets == null)){
                    console.log('Problem: null act_start_url or null record_sets');
                    return null;
                }
                if(!act_start_url in this.record_sets){
                    console.log('No ' + act_start_url + ' key in record_sets')
                    return null;
                }
                return this.record_sets[act_start_url];
            },
            check_page_in_record_sets: function(page_id){
                let page_res = {
                    ok: null, 
                    page_new: null,
                    next_url: null,
                    downloaded_count: null,
                };
                let act_start_url = this.act_start_url;
                let act_record_set = this.get_act_record_set();
                if(act_record_set == null){
                    page_res.ok = false;
                    return page_res;
                }
                // Check to see if the page of results is new, and if it is, add it.
                page_res.ok = true;
                page_res.page_new = true;
                page_res.downloaded_count = 0;
                let num_pages = this.record_sets[act_start_url].pages.length;
                for(let old_page of this.record_sets[act_start_url].pages){
                    if(old_page.id == page_id){
                        page_res.page_new = false;
                        if(old_page.hasOwnProperty('next')){
                            page_res.next_url = old_page.next;
                        }
                    }
                    if(old_page.hasOwnProperty('features')){
                        // Add up the number of existing records.
                        page_res.downloaded_count += old_page.features.length;
                    }
                }
                return page_res;
            },
            add_page_json_to_record_sets: function(page_json){
                if(!page_json){
                    console.log('Problem: page_json missing')
                    return false;
                }
                if(!page_json.hasOwnProperty('id')){
                    console.log('Problem: page_json missing id attribute')
                    return false;
                }
                let page_res = this.check_page_in_record_sets(page_json.id);
                if(!page_res.ok){
                    return false;
                }
                let downloaded_count = page_res.downloaded_count;
                if(!page_res.page_new){
                    // We already have this page downloaded.
                    this.act_downloaded_count = downloaded_count;
                    return true;
                }
                // Everything below happens if the page is new.
                if(page_json.hasOwnProperty('features')){
                    // Add the new page's feature count to the total downloaded count.
                    downloaded_count += page_json.features.length;
                }
                let act_start_url = this.act_start_url;
                this.record_sets[act_start_url].pages.push(page_json);
                this.act_downloaded_count = downloaded_count;
                console.log('Added ' + page_json.id + ' now ' + this.record_sets[act_start_url].pages.length + ' pages.');
                // New and valid.
                if(this.act_downloaded_count >= this.act_total_count){
                    this.dl_complete = true;
                }
                return true;
            },
            recursive_fetch_oc_records_api: function (url){
                this.error = null;
                this.loading = true;
                url = replaceURLparameter(url, 'response', this.param_response_value);
                let page_res = this.check_page_in_record_sets(url);
                if(!page_res.ok){
                    return false;
                }
                if(!page_res.page_new){
                    // We already have this page downloaded.
                    this.act_downloaded_count = page_res.downloaded_count;
                    if(page_res.next_url != null){
                        this.recursive_fetch_oc_records_api(page_res.next_url); 
                    }
                    return true;
                }
                fetch(
                    url,
                    {
                        headers:{
                            'Accept': 'application/json',
                        }
                    }
                ).then(async response => {
                    const page_data = await response.json();
                    this.loading = false;
                    // check for error response
                    if (!response.ok) {
                        // get error message from body or default to response status
                        const error = response.status;
                        return Promise.reject(error);
                    }
                    let page_ok = this.add_page_json_to_record_sets(page_data);
                    this.act_page_url = null;
                    if(page_ok){
                        if(page_data.hasOwnProperty('next')){
                            this.act_page_url = page_data.next;
                        }
                    }
                    if(this.act_page_url != null){
                        console.log('Fetch next act page ' + this.act_page_url);
                        setTimeout(() => { 
                            this.recursive_fetch_oc_records_api(this.act_page_url); 
                        }, this.sleep_pause);
                    }
                })
                .catch(error => {
                    this.errorMessage = error;
                    console.error('There was an error!', error);
                });
            },
            get_records: function(){
                this.act_total_count = this.prep_record_fetches();
                this.act_downloaded_count = 0;
                this.act_page_url = this.act_start_url;
                console.log('start url is: ' + this.act_start_url);
                this.dl_started = true;
                this.dl_complete = false;
                this.recursive_fetch_oc_records_api(this.act_page_url);
            }
        },
        components: {
            'selectable-dl-attribs': vc_selectable_dl_attribs,
            // 'vue-json-to-csv': vc_json_to_csv,
        }
    }
);



</script>



{% endblock %}