{% block search_exporter %}

{% load humanize %}

<template id="search_exporter_selectable_dl_attribs">
    <b-list-group-item v-if="show_attribs_exist">
        <b-row>
            <b-col cols="3">
                <strong v-if="data_type == 'id'">
                    Types or Relations
                </strong>
                <strong v-else-if="data_type == 'int'">
                    Integer
                </strong>
                <strong v-else-if="data_type == 'double'">
                    Decimal
                </strong>
                <strong v-else-if="data_type == 'date'">
                    Date
                </strong>
                <strong v-else-if="data_type == 'bool'">
                    Boolean (T/F)
                </strong>
                <strong v-else>
                    Free text
                </strong>
            </b-col>
            <b-col cols="9">
                <div v-for="(freq_type, ft_index) in attrib_freq_types">
                    <div v-if="show_attribs[freq_type].length > 0">
                        <span>Fields used with [[ freq_type ]] records</span><br/>
                        <span v-for="(attrib, index) in show_attribs[freq_type]">
                            <b-button
                                class="download-selected-attribs"
                                pill
                                size="sm"
                                variant="outline-primary"
                                :title="'Click to add \'' + attrib.label + '\''"
                                @click="add_selected_attrib(attrib)"
                                >
                                [[ attrib.s_label ]] <b-icon-plus-circle-fill></b-icon-plus-circle-fill>
                            </b-button>
                        </span>
                    </div>
                </div>
            </b-col>
        </b-row>
    </b-list-group-item>
</template>


<template id="search_exporter_ui">
    <b-modal
        size="xl"
        scrollable
        class="exporter-ui-modal"
        ref="exporter-modal"
        id="exporter-modal"
        title="Export Records for Download"
        @shown="on_shown"
        @close="on_close"
    >
        <b-row>
            <b-col cols="12">
                <p>This tool exports the current set of records as a data table or a GIS output. 
                    GIS exports can be saved and previewed on the search result map. For convenience, 
                    these outputs represent data in somewhat simplified formats. If you need more 
                    expressive and complete representations of these data, 
                    please see the <a href="../../about/services" target="_blank">API documentation</a>. 
                    Please also note that location data for certain records may be approximated as a 
                    security precaution or because precise data are not available.
                </p>
            </b-col>
        </b-row>

        <b-row id="download-prog-bar-row">
            <b-col cols="12">

                <b-row v-if="dl_progress" class="progress_row">
                    <b-col cols="12">
              
                      <b-progress max="1" height="2rem" variant="success">
                        <b-progress-bar :value="dl_progress">
                          <span><strong>[[ (dl_progress * 100).toFixed(1) ]] %</strong> ([[ dl_message ]])</span>
                        </b-progress-bar>
                      </b-progress>
              
                    </b-col>
                </b-row>
                
            </b-col>
        </b-row>

        <b-row id="download-attribs-save-opts-row" >
            <b-col cols="6">
                <b-row>
                    <b-col cols="12">
                        <h5>Fields / Attributes to Include in Export</h5>
                        <small>Default attributes:</small><br/>
                        <span v-for="(attrib, index) in default_attribs">
                            <b-badge
                                pill
                                class="download-default-attribs"
                                title="Default, always included attribute"
                                variant="secondary">
                                [[ attrib ]]
                            </b-badge>
                        </span>
                        <div id="download-selected-attribs-div" if="act_download_attribs">
                            <small>Selected optional attributes:</small><br/>
                            <span v-for="(attrib, index) in act_download_attribs">
                                <b-button
                                    class="download-selected-attribs"
                                    pill
                                    size="sm"
                                    variant="primary"
                                    :title="'Click to remove \'' + attrib.label + '\''"
                                    @click="remove_selected_attrib(attrib)"
                                    :disabled="dl_started || dl_complete"
                                    >
                                    [[ attrib.s_label ]] <b-icon-dash-circle-fill></b-icon-dash-circle-fill>
                                </b-button>
                            </span>
                        </div>
                    </b-col>
                </b-row>

                <b-row id="download-dl-button-row">
                    <b-col cols="12">
                        <b-alert show variant="info"  v-if="!dl_started">
                            <small>
                                After you have selected attributes to include in your download, click the button below to 
                                begin the download. Once the download is complete, you will see options to save the downloaded
                                records on your device. You will also be able to view the downloaded records on Open Context's
                                map interface.
                            </small>
                            <br/>
                            <br/>
                            <b-button
                                block
                                :disabled="dl_button_disable"
                                variant="primary" 
                                @click="get_records">
                                <b-icon-download></b-icon-download> Start Download
                            </b-button>
                        </b-alert>
                        <b-alert show variant="secondary" v-if="dl_complete">
                            <p><strong>NOTE</strong><br/>
                            Your completed download is now available to view on the map. Open the map layer options 
                            to select the downloaded records for view. However, the map view is only kept temporarily on
                            your browser. If you reload this page, you will need to redo the download to view on the map.
                            </p>
                        </b-alert>
                    </b-col>
                </b-row>

            </b-col>
            <b-col cols="6">
                <b-row>
                    <b-col cols="12">
                        <div v-if="dl_started & !dl_complete" class="text-center">
                            <h5>Download of <strong>[[ human_act_total_count ]]</strong> records in progress...</h5>
                            <b-spinner variant="success" label="Spinning"></b-spinner>
                        </div>
                        <b-alert show variant="info" v-else-if="dl_complete">
                            <h5 class="text-center">Download of <strong>[[ human_act_total_count ]]</strong> records completed.</h5>
                            <p>Data for all records are fully downloaded and can be saved on your device in a tabular (CSV) and/or 
                            a GIS (GeoJSON) format using the buttons below.
                            </p>

                            <b-row align-v="center">
                                <b-col cols="4">
                                    <strong>Label this download</strong>
                                </b-col>
                                <b-col cols="8">
                                    <b-form-input
                                        debounce="100"
                                        @change="update_act_download_label"
                                        type="text" 
                                        v-model="act_download_label" 
                                        value="act_download_label"></b-form-input>
                                </b-col>
                            </b-row>
                            <b-row align-v="center" class="download-filesave-row">
                                <b-col cols="8">
                                    <small><strong>CSV (Comma Separated Value)</strong> format to save data as a
                                        table for use in a spreadsheet or database application, or 
                                        for analysis using scripting languages like
                                        <strong>R</strong> or <strong>Python</strong>.
                                    </small>
                                </b-col>
                                <b-col cols="4">
                                    <vue-json-to-csv
                                        v-bind:csv-title="act_download_label"
                                        v-bind:json-data="dl_csv_data">
                                        <b-button variant="primary">Save Data as CSV <b-icon-table></b-icon-table>
                                        </b-button>
                                    </vue-json-to-csv>
                                </b-col>
                            </b-row>
                            <b-row align-v="center" class="download-filesave-row">
                                <b-col cols="8">
                                    <small><strong>GeoJSON</strong> format to save data for use in a GIS application like QGIS or ArcGIS.
                                        GeoJSON is a widely supported and
                                        <a href="https://en.wikipedia.org/wiki/GeoJSON" target="_blank">nonproprietary Internet standard</a>.
                                    </small>
                                </b-col>
                                <b-col cols="4">
                                    <b-button
                                        @click="save_dl_geojson"
                                        variant="primary">Save Data as GeoJSON (GIS) <b-icon-pin-map-fill></b-icon-pin-map-fill>
                                    </b-button>
                                </b-col>
                            </b-row>

                            <p><strong><b-icon-gear-fill></b-icon-gear-fill> Advanced Options</strong><br/>
                                <small>Some attributes may have multiple values. 
                                    Select how multi-valued attributes should be expressed in saved files.
                                </small>
                            </p>

                            <b-form-group>
                                <b-form-radio v-model="multi_value_save_option" name="multi_value_save_option" value="separate-fields">Split values across multiple fields</b-form-radio>
                                <b-form-radio v-model="multi_value_save_option" name="multi_value_save_option" value="delimiter">Join values using a delimiter, keeping all within one field</b-form-radio>
                            </b-form-group>

                            <b-row v-if="multi_value_save_option == 'delimiter'" align-v="center">
                                <b-col cols="3" class="text-right">Multi-value Delimiter</b-col>
                                <b-col cols="2">
                                    <b-form-input maxlength="4" type="text" v-model="multi_value_delim" value="multi_value_delim"></b-form-input>
                                </b-col>
                                <b-col cols="7"><small><strong>[[ delim_example.list ]]</strong> becomes<br/><strong>[[ delim_example.joined ]]</strong></small></b-col>
                            </b-row>


                        </b-alert>
                        <div v-if="!dl_started">
                            <div class="accordion" role="tablist" v-if="act_attribs">
                                <h5>Choose Additional Fields / Attributes to Include in Export</h5>
                                <b-card 
                                    no-body
                                    class="mb-1"
                                    v-for="(attrib_grp, a_grp_index) in act_attribs">
                                    <b-card-header header-tag="header" class="p-1" role="tab">
                                        <b-button 
                                            block
                                            v-b-toggle="'attrib_grp_panel_' + a_grp_index"
                                            variant="secondary"><i class="bi bi-arrows-expand"></i> [[attrib_grp.label]]</b-button>
                                    </b-card-header>
                                    <b-collapse 
                                        :id="'attrib_grp_panel_' + a_grp_index"
                                        visible
                                        :accordion="'attrib_grp_panel_accordion_' + a_grp_index" 
                                        role="tabpanel">
                                        <b-card-body>
                                            <small v-if="attrib_grp.note">[[attrib_grp.note]]</small>
                                            <b-list-group flush>
                                                
                                                <selectable-dl-attribs
                                                    v-for="(attrib_dt_grp, a_dt_grp_index) in attrib_grp.attribs"
                                                    v-bind:attrib_freq_types="attrib_freq_types"
                                                    v-bind:attrib_dt_grp="attrib_dt_grp"
                                                    v-bind:data_type="attrib_dt_grp.data_type"
                                                    v-bind:act_download_attribs="act_download_attribs">
                                                </selectable-dl-attribs>
                                                    
                                            </b-list-group>
                                        </b-card-body>
                                    </b-collapse>
                                </b-card>
                            </div>
                            <div v-else>
                                Download not currently supported.
                            </div>
                        </div>
                    </b-col>
                </b-row>
            </b-col>
        </b-row>

       
        <template #modal-footer="{ ok, cancel, hide }">
            <b-button size="sm" variant="outline-secondary" @click="cancel_close">
              Cancel
            </b-button>
          </template>
    </b-modal>
</template>
    

<script type="text/javascript">
Vue.use(VueJsonToCsv);
/*
const vc_json_to_csv = Vue.component(
    'vue-json-to-csv', 
    window.VueJsonToCsv,
);
*/

var vc_selectable_dl_attribs = Vue.component(
    'selectable-dl-attribs',
    {
        delimiters: ['[[', ']]'],
        props: [
            'attrib_dt_grp',
            'data_type',
            'attrib_freq_types',
            'act_download_attribs',
        ],
        data() {
            return {
                attrib_dt_grp: null,
                data_type: null,
                attrib_freq_types: null,
                act_download_attribs: null,
            };
        },
        computed: {
            show_attribs_exist: function() {
                if(this.attrib_dt_grp == null || this.act_download_attribs == null){
                    return false;
                }
                if(this.attrib_freq_types == null){
                    return false;
                }
                let output = false;
                for(let freq_type of this.attrib_freq_types){
                    if(!this.attrib_dt_grp.hasOwnProperty(freq_type)){
                        continue;
                    }
                    for(let attrib of this.attrib_dt_grp[freq_type]){
                        if(this.in_download_attribs(attrib)){
                            continue;
                        }
                        output = true;
                    }
                }
                return output;
            },
            show_attribs: function(){
                if(this.attrib_dt_grp == null || this.act_download_attribs == null){
                    return false;
                }
                if(this.attrib_freq_types == null){
                    return false;
                }
                let show_attribs = {};
                for(let freq_type of this.attrib_freq_types){
                    show_attribs[freq_type] = [];
                    if(!this.attrib_dt_grp.hasOwnProperty(freq_type)){
                        continue;
                    }
                    for(let attrib of this.attrib_dt_grp[freq_type]){
                        if(this.in_download_attribs(attrib)){
                            continue;
                        }
                        show_attribs[freq_type].push(attrib);
                    }
                }
                return show_attribs;
            }
        },
        template: '#search_exporter_selectable_dl_attribs',
        methods: {
            in_download_attribs: function(attrib){
                for(let act_attrib of this.act_download_attribs){
                    if(act_attrib.slug == attrib.slug){
                        return true;
                    }
                }
                return false;
            },
            add_selected_attrib: function(attrib){
                this.act_download_attribs.push(attrib);
            },
        }
    }
);

var vc_search_exporter_ui = Vue.component(
    'search-exporter-ui',
    {
        delimiters: ['[[', ']]'],
        props: [
            'result',
            'base_search_url',
            'geo_json_record_layer_count',
            'record_sets',
        ],
        data() {
            return {
                result: null,
                base_search_url: null,
                exclude_fields: [
                    'id',
                    'feature-type',
                    'href',
                ],
                default_field_mappings: UI_RECORD_PROPERTY_KEY_HUMAN_READABLE_MAPPINGS,
                skip_default_attribute_slugs: [
                    'dc-terms-coverage',
                    'dc-terms-license',
                    'dc-terms-subject',
                    'dc-terms-temporal',
                    'dc-terms-spatial',
                ],
                sleep_pause: 325,
                max_export: 200000,
                records_per_page: 100,
                param_response_value: 'metadata,geo-record',
                default_add_common_attribs: true,
                attrib_freq_types: ['most', 'many', 'some', 'few'],
                multi_value_save_option: 'delimiter',
                multi_value_delim: '|',
                csv_null_value: "",
                geo_json_record_layer_count: 0,
                record_sets: null,
                base_search_url_export_states: null,
                initial_export_states: {
                    loading: false,
                    error: null,
                    act_attribs: null,
                    act_download_attribs: null,
                    act_start_url: null,
                    act_page_url: null,
                    act_total_count: null,
                    act_downloaded_count: null,
                    act_download_label: null,
                    dl_started: false,
                    dl_complete: null,
                },
                loading: false,
                error: null,
                act_attribs: null,
                act_download_attribs: null,
                act_start_url: null,
                act_page_url: null,
                act_total_count: null,
                act_downloaded_count: null,
                act_download_label: null,
                dl_started: false,
                dl_complete: null,
            }
        },
        template: '#search_exporter_ui',
        computed: {
            default_attribs: function() {
                let attribs = [];
                for(let [key, val] of Object.entries(this.default_field_mappings)){
                    attribs.push(val);
                }
                return attribs;
            },
            human_act_total_count: function(){
                if(this.act_downloaded_count == null){
                    return null;
                }
                return this.act_downloaded_count.toLocaleString();
            },
            dl_button_disable: function(){
                if(this.act_downloaded_count == null){
                    return false;
                }
                return true;
            },
            dl_progress: function(){
                if(this.act_total_count == null){
                    return null;
                }
                let dl_count = this.act_downloaded_count;
                if(this.act_total_count == 0){
                    return 1;
                }
                if(dl_count == null){
                    dl_count = 0;
                }
                let prop_done = dl_count / this.act_total_count;
                return prop_done;
            },
            dl_message: function(){
                if(this.act_total_count == null){
                    return null;
                }
                let dl_count = this.act_downloaded_count;
                if(dl_count == null){
                    dl_count = 0;
                }
                if(this.act_total_count < 1){
                    return 'No records to download';
                }
                return `${dl_count} of ${this.act_total_count} records downloaded`;
            },
            delim_example: function() {
                if(this.multi_value_save_option != 'delimiter'){
                    return null;
                }
                let vals = ['Rim', 'Handle', 'Base'];
                let vals_json = JSON.stringify(vals);
                let vals_joined = vals.join(this.multi_value_delim);
                return {list: vals_json, joined: vals_joined};
            },
            dl_csv_data: function(){
                let raw_features = this.gather_act_geojson_features();
                if(raw_features == null){
                    return null;
                }
                let data = [];
                for(let feature of raw_features){
                    if(!feature.hasOwnProperty('geometry')){
                        continue;
                    }
                    if(!feature.hasOwnProperty('properties')){
                        continue;
                    }
                    feature.properties = this.add_lat_lon_fields(
                        feature
                    );
                    let clean_props = this.props_to_multivalue_output(
                        feature.properties,
                        true
                    );
                    data.push(clean_props);
                }
                return this.fill_in_missing_fields(data);
            },
        },
        mounted(){
            this.set_base_search_url_export_state();
        },
        methods: {
            set_base_search_url_export_state: function() {
                if(this.base_search_url_export_states == null){
                    this.base_search_url_export_states = {ok: true};
                }
                let base_search_url = this.base_search_url;
                if(!this.base_search_url_export_states.hasOwnProperty(base_search_url)){
                    // So as not to mutate this.
                    this.base_search_url_export_states[base_search_url] = JSON.parse(JSON.stringify(this.initial_export_states));
                }
                let act_state = this.base_search_url_export_states[base_search_url];
                this.loading = act_state.loading;
                this.error = act_state.error;
                this.act_attribs = act_state.act_attribs;
                this.act_download_attribs = act_state.act_download_attribs;
                this.act_start_url =  act_state.act_start_url;
                this.act_page_url = act_state.act_page_url;
                this.act_total_count = act_state.act_total_count;
                this.act_downloaded_count = act_state.act_downloaded_count;
                this.act_download_label = act_state.act_download_label;
                this.dl_started = act_state.dl_started;
                this.dl_complete = act_state.dl_complete;
            },
            on_shown: function(){
                this.set_base_search_url_export_state();
                if(this.act_attribs == null){
                    this.make_act_attribs();
                }
                return null;
            },
            on_close: function(){
                let act_state = {};
                act_state.loading = this.loading;
                act_state.error = this.error;
                act_state.act_attribs = this.act_attribs;
                act_state.act_download_attribs = this.act_download_attribs;
                act_state.act_start_url = this.act_start_url;
                act_state.act_page_url = this.act_page_url;
                act_state.act_total_count = this.act_total_count;
                act_state.act_downloaded_count = this.act_downloaded_count;
                act_state.act_download_label = this.act_download_label;
                act_state.dl_started = this.dl_started;
                act_state.dl_complete = this.dl_complete;
                let base_search_url = this.base_search_url;
                this.base_search_url_export_states[base_search_url] = act_state;
            },
            cancel_close: function(){
                this.$bvModal.hide('exporter-modal');
            },
            csv_call_value_clean: function(cell_val){
                if(!cell_val){
                    return cell_val;
                }
                cell_val = "" + cell_val;
                cell_val = cell_val.replace(/(\r\n|\n|\r)/gm," ");
                cell_val = cell_val.replace(/['"]+/g, ' ')
                return cell_val;
            },
            get_field_number: function(field){
                let num_start = field.indexOf('[');
                let num_end = field.indexOf(']');
                if(num_start < 1){
                    // not a numbered field, so it is the
                    // first field.
                    return 1;
                }
                let field_num = parseInt(field.slice((num_start + 1), num_end));
                if(field_num > 1){
                    // we found a field number.
                    return field_num;
                }
                // default to the first (field 1 field)
                return 1;
            },
            get_field_without_field_num(field){
                // removes the number part of a numbered field.
                let field_num = this.get_field_number(field);
                if(field_num == 1){
                    return field;
                }
                let num_start = field.indexOf('[');
                return field.slice(0, num_start).trim();
            },
            order_numbered_fields: function(field, i, field_list){
                let field_num = this.get_field_number(field);
                if(field_num == 1){
                    // Simple case, the field is not numbered.
                    field_list.splice(i, 0, field);
                    return field_list;
                }
                let base_field = this.get_field_without_field_num(field);
                let new_field_list = [];
                for(let old_field of field_list){
                    new_field_list.push(old_field);
                    if(old_field.startsWith(base_field)){
                        let old_field_num = this.get_field_number(old_field);
                        if(field_num == (old_field_num + 1)){
                            // the field num is the next in the sequence, so
                            // add it after the old_field.
                            new_field_list.push(field);
                        }
                    }
                }
                if(new_field_list.indexOf(field) < 0){
                    // Something went wrong, so append the
                    // field using the other method
                    field_list.splice(i, 0, field);
                    return field_list; 
                }
                return new_field_list;
            },
            fill_in_missing_fields: function(raw_data){
                let data = JSON.parse(JSON.stringify(raw_data));
                let field_list = [];
                let rec_i = 0;
                for(let rec of data){
                    let i = 0;
                    for(let [field, val] of Object.entries(rec)){
                        if(field_list.indexOf(field) >=0 ){
                            i +=1;
                            continue;
                        }
                        if(rec_i < 1){
                            field_list.push(field);
                            i +=1;
                            continue;
                        }
                        // this adds the field while preserving consisting ordering
                        field_list = this.order_numbered_fields(field, i, field_list);
                        i +=1;
                    }
                    rec_i += 1;
                }
                console.log('Gathered all fields!');
                console.log(field_list);
                let new_data = [];
                for(let rec of data){
                    let new_rec = {}
                    for(let field of field_list){
                        if(rec.hasOwnProperty(field)){
                            new_rec[field] = this.csv_call_value_clean(
                                rec[field]
                            );
                        }
                        else{
                            new_rec[field] = this.csv_null_value;
                        }
                    }
                    new_data.push(new_rec);
                }
                return new_data;
            },
            add_lat_lon_fields: function(feature){
                let lat_p = 'Latitude (WGS 84)';
                let lon_p = 'Longitude (WGS 84)'
                let lat = null;
                let lon = null;
                if (feature.geometry.type === 'Point') {
                    lon = feature.geometry.coordinates[0];
                    lat = feature.geometry.coordinates[1];
                }
                else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                    
                    let centroid = turf.centroid(feature);
                    lon = centroid.geometry.coordinates[0];
                    lat = centroid.geometry.coordinates[1];
                }
                else {
                    // we don't know what to do to get a point. skip out.
                    return feature.properties;
                }
                if(lat == null || lon == null){
                    return feature.properties;
                }
                let prop_keys = [];
                for(let [key, val] of Object.entries(feature.properties)){
                    prop_keys.push(key);
                }
                let context_index = prop_keys.indexOf('context href');
                if(context_index >= 0){
                    prop_keys.splice((context_index + 1), 0, lat_p, lon_p);
                }
                else{
                    prop_keys.push(lat_p);
                    prop_keys.push(lon_p);
                }
                let new_properties = {};
                for(let p_field of prop_keys){
                    if(feature.properties.hasOwnProperty(p_field)){
                        new_properties[p_field] = feature.properties[p_field];
                    }
                    else if (p_field == lat_p){
                        new_properties[p_field] = lat;
                    }
                    else if (p_field == lon_p){
                        new_properties[p_field] = lon;
                    }
                    else{
                        continue;
                    }
                }
                return new_properties;
            },
            add_multivalue_fields_for_mapped_key: function(mapped_key, val_list, clean_props){
                let act_key = mapped_key;
                let val_index = 1;
                for(let act_val of val_list){
                    clean_props[act_key] = act_val;
                    val_index += 1;
                    act_key = `${mapped_key} [${val_index}]`;
                }
                return clean_props;
            },
            props_to_separate_multivalue_fields: function(properties, split_contexts){
                // Reformat properties so multi-values are put into different
                // fields.
                let clean_props = {};
                for(let [key, val] of Object.entries(properties)){
                    if(skip_excluded_property_key(key)){
                        continue;
                    }
                    let mapped_key = map_property_key_to_field(key);
                    let val_list = [val];
                    if(split_contexts && mapped_key == 'Context'){
                        val_list = val.split('/');
                    }
                    else{
                        if(Array.isArray(val)){
                            val_list = val;
                        }
                    }
                    clean_props = this.add_multivalue_fields_for_mapped_key(
                        mapped_key, 
                        val_list, 
                        clean_props
                    );
                }
                return clean_props;
            },
            props_to_join_multivalues: function(properties, split_contexts){
                // Reformat properties so multi-values are joined into a single
                // string value split by a delimiter.
                let clean_props = {};
                for(let [key, val] of Object.entries(properties)){
                    if(skip_excluded_property_key(key)){
                        continue;
                    }
                    let mapped_key = map_property_key_to_field(key);
                    if(split_contexts && mapped_key == 'Context'){
                        // Special treatment for the 'Context' field.
                        val_list = val.split('/');
                        clean_props = this.add_multivalue_fields_for_mapped_key(
                            mapped_key, 
                            val_list, 
                            clean_props
                        );
                        // Skip the rest.
                        continue;
                    }
                    let act_val = val;
                    if(Array.isArray(val)){
                        act_val = val.join(this.multi_value_delim);
                    }
                    clean_props[mapped_key] = act_val;
                }
                return clean_props;
            },
            props_to_mapped_fields_no_multi_value_change: function(properties){
                let clean_props = {};
                for(let [key, val] of Object.entries(properties)){
                    if(skip_excluded_property_key(key)){
                        continue;
                    }
                    let mapped_key = map_property_key_to_field(key);
                    clean_props[mapped_key] = val;
                }
                return clean_props;
            },
            props_to_multivalue_output: function(raw_properties, split_contexts){
                let properties = JSON.parse(JSON.stringify(raw_properties)); // prevent mutation of the result.
                if(this.multi_value_save_option === 'separate-fields'){
                    return this.props_to_separate_multivalue_fields(properties, split_contexts);
                }
                else if(this.multi_value_save_option === 'delimiter'){
                    return this.props_to_join_multivalues(properties, split_contexts);
                }
                else{
                    return this.props_to_mapped_fields_no_multi_value_change(properties);
                }
            },
            save_file: function(str_data, file_name, mime_type) {
                const blob = new Blob([str_data], {type: 'text/plain'})
                const e = document.createEvent('MouseEvents'),
                a = document.createElement('a');
                a.download = file_name;
                a.href = window.URL.createObjectURL(blob);
                a.dataset.downloadurl = [mime_type, a.download, a.href].join(':');
                e.initEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                a.dispatchEvent(e);
            },
            gather_act_geojson_features: function() {
                if(!this.dl_complete){
                    return null;
                }
                let act_record_set = this.get_act_record_set();
                if(act_record_set == null){
                    return null;
                }
                let features = [];
                for(let page of act_record_set.pages){
                    if(!page.hasOwnProperty('features')){
                        continue;
                    }
                    for(let feature of page.features){
                        features.push(feature);
                    }
                }
                return JSON.parse(JSON.stringify(features)); // prevent mutation of the result.
            },
            add_geojson_record_layers: function(){
                let act_record_set = this.get_act_record_set();
                let raw_features = this.gather_act_geojson_features();
                if(raw_features == null){
                    return null;
                }
                console.log('New layer index ' +  act_record_set.record_layer_index + '; ' + act_record_set.label);
                let features = [];
                for(let feature of raw_features){
                    if(!feature.hasOwnProperty('properties')){
                        continue;
                    }
                    feature.record_layer_index = act_record_set.record_layer_index;
                    feature.properties = this.props_to_mapped_fields_no_multi_value_change(feature.properties);
                    features.push(feature);
                }
                let geojson = {
                    id: this.act_start_url,
                    label: act_record_set.label,
                    record_layer_index: act_record_set.record_layer_index,
                    ov_id: 'records-' + act_record_set.record_layer_index,
                    totalResults: act_record_set.metadata.totalResults,
                    query_url: this.act_start_url,
                    type: 'FeatureCollection', 
                    features: features,
                };
                this.$emit('add_geojson_record_layers', {geojson: geojson, record_sets:this.record_sets});
            },
            save_dl_geojson: function(){
                let raw_features = this.gather_act_geojson_features();
                if(raw_features == null){
                    return null;
                }
                let features = [];
                for(let feature of raw_features){
                    if(!feature.hasOwnProperty('properties')){
                        continue;
                    }
                    feature.properties = this.props_to_multivalue_output(feature.properties, false);
                    features.push(feature);
                }
                let str_data = JSON.stringify(
                    {type: 'FeatureCollection', features: features}, 
                    null, 
                    4
                );
                this.save_file(
                    str_data, 
                    `${this.act_download_label}.json`, 
                    'text/json'
                );
            },
            remove_selected_attrib: function(attrib){
                console.log('Remove click');
                console.log(attrib);
                let rev_attribs = [];
                for(let act_attrib of this.act_download_attribs){
                    if(act_attrib.slug == attrib.slug){
                        continue
                    }
                    rev_attribs.push(act_attrib);
                }
                this.act_download_attribs = rev_attribs;
                return true;
            },
            in_download_attribs: function(attrib){
                for(let act_attrib of this.act_download_attribs){
                    if(act_attrib.slug == attrib.slug){
                        return true;
                    }
                }
                return false;
            },
            make_record_fetch_start_url: function(url){
                let params_vals = [
                    {p: 'rows', v: this.records_per_page,},
                    {p: 'start', v: 0,},
                ];
                for (let p_v of params_vals){
                    url = replaceURLparameter(url, p_v.p, p_v.v);
                }
                return url;
            },
            make_attribute_lists: function(metadata){
                let all_attribs = [];
                if(!metadata.hasOwnProperty('oc-api:has-facets')){
                    return all_attribs;
                }
                for (let f_field of metadata['oc-api:has-facets']){
                    if(!f_field.hasOwnProperty('type')){
                        continue;
                    }
                    if(f_field.type != 'oc-api:facet-prop'){
                        continue;
                    }
                    let is_standard = false;
                    f_field.note = (
                        'Project defined attributes, not in wider use '
                        + 'across multiple data sources.'
                    );
                    if(f_field.label.indexOf('Standard') >=0 ){
                        is_standard = true;
                        f_field.note = 'Attributes used in common across multiple projects and data sources.';
                    }
                    f_field.attribs = [];
                    let attrib_opt_count = 0;
                    for (let opts_conf of FACETS_OPTIONS_LISTS_AND_DATA_TYPES) {
                        if (!(opts_conf.list_key in f_field)){
                            // Nothing to do, so keep on looping to check for other kinds of
                            // options lists.
                            continue;
                        }
                        let act_data_type_attribs = {
                            data_type: opts_conf.data_type,
                            most: [],
                            many: [],
                            some: [],
                            few: [],
                        };
                        for(let act_opt of f_field[opts_conf.list_key]){
                            act_opt.percent = Math.round(act_opt.count / metadata.totalResults, 2) * 100;
                            act_opt.s_label = act_opt.label;
                            if(!is_standard && act_opt.hasOwnProperty('rdfs:isDefinedBy')){
                                if(act_opt['rdfs:isDefinedBy'].indexOf('/predicates/') < 0){
                                    // This is NOT a predicate, so it's not a descriptive attribute.
                                    continue;
                                }
                            }
                            if (act_opt.s_label.length > 36) {
                                act_opt.s_label = act_opt.label.substring(0, 34) + '..';
                            }
                            if(act_opt.percent >=75){
                                act_data_type_attribs.most.push(act_opt);
                                attrib_opt_count += 1;
                            }
                            else if (act_opt.percent >= 33 && act_opt.percent < 75) {
                                act_data_type_attribs.many.push(act_opt);
                                attrib_opt_count += 1;
                            }
                            else if (act_opt.percent >= 10 && act_opt.percent < 33) {
                                act_data_type_attribs.some.push(act_opt);
                                attrib_opt_count += 1;
                            }
                            else{
                                act_data_type_attribs.few.push(act_opt);
                                attrib_opt_count += 1;
                            }
                        }
                        f_field.attribs.push(act_data_type_attribs);
                    }
                    if(attrib_opt_count < 1){
                        continue;
                    }
                    all_attribs.push(f_field);
                }
                return all_attribs;
            },
            make_act_attribs: function(){
                if(this.act_attribs != null){
                    // this is already defined.
                    return null;
                }
                if(!this.result){
                    this.act_attribs = null;
                    return null;
                }
                let start_metadata = JSON.parse(JSON.stringify(this.result)); // prevent mutation of the result.
                if(start_metadata.hasOwnProperty('features')){
                    delete start_metadata.features;
                }
                console.log('Made act attribs');
                this.act_attribs = this.make_attribute_lists(start_metadata);
                console.log(this.act_attribs);
                if(this.default_add_common_attribs){
                    this.act_download_attribs = [];
                    for(let field_grp of this.act_attribs){
                        if(!field_grp.hasOwnProperty('attribs')){
                            continue;
                        }
                        for(let dt_attribs of field_grp.attribs){
                            if(!dt_attribs.hasOwnProperty('most')){
                                continue;
                            }
                            for(let attrib of dt_attribs.most){
                                if(!attrib.hasOwnProperty('slug')){
                                    continue;
                                }
                                if(this.skip_default_attribute_slugs.indexOf(attrib.slug) >=0 ){
                                    // In the list of skipped default attributes.
                                    continue;
                                }
                                this.act_download_attribs.push(attrib);
                            }
                        }
                    }
                    console.log('Added default download attribs ' + this.act_download_attribs.length);
                    console.log(this.act_download_attribs);
                }
            },
            prep_record_fetches: function(){
                this.act_start_url = this.make_record_fetch_start_url(
                    this.base_search_url
                );

                let attrib_slugs = [];
                for(let attrib of this.act_download_attribs){
                    if(!attrib.hasOwnProperty('slug')){
                        continue;
                    }
                    attrib_slugs.push(attrib.slug);
                }
                if(attrib_slugs.length > 0){
                    this.act_start_url = replaceURLparameter(
                        this.act_start_url,
                        'attributes',
                        attrib_slugs.join(',')
                    );
                }

                let act_start_url = this.act_start_url;
                if(this.record_sets == null){
                    let record_sets = {};
                    record_sets[act_start_url] = null;
                    this.record_sets = JSON.parse(JSON.stringify(record_sets));
                }
                
                let record_layer_index = this.geo_json_record_layer_count;
                if(this.record_sets[act_start_url] != null){
                    // Skip out, we already have this.
                    return this.record_sets[act_start_url].metadata.totalResults;
                }
                
                let start_metadata = JSON.parse(JSON.stringify(this.result)); // prevent mutation of the result.
                if(start_metadata.hasOwnProperty('features')){
                    delete start_metadata.features;
                }
                this.record_sets[act_start_url] = {
                    label: `open-context-${start_metadata.totalResults}-records`,
                    record_layer_index: record_layer_index,
                    metadata: start_metadata,
                    pages: [],
                }
                console.log('Created new download record set');
                console.log(this.record_sets[act_start_url]);
                this.act_download_label = this.record_sets[act_start_url].label;
                return this.record_sets[act_start_url].metadata.totalResults;
            },
            get_act_record_set: function(){
                let act_start_url = this.act_start_url;
                if((act_start_url == null) || (this.record_sets == null)){
                    console.log('Problem: null act_start_url or null record_sets');
                    return null;
                }
                if(!act_start_url in this.record_sets){
                    console.log('No ' + act_start_url + ' key in record_sets')
                    return null;
                }
                return this.record_sets[act_start_url];
            },
            update_act_download_label: function(){
                let act_rec_set = this.get_act_record_set();
                if(act_rec_set == null){
                    return null;
                }
                act_rec_set.label = this.act_download_label;
                this.add_geojson_record_layers();
            },
            check_page_in_record_sets: function(page_id){
                let page_res = {
                    ok: null, 
                    page_new: null,
                    next_url: null,
                    downloaded_count: null,
                };
                let act_start_url = this.act_start_url;
                let act_record_set = this.get_act_record_set();
                if(act_record_set == null){
                    page_res.ok = false;
                    return page_res;
                }
                // Check to see if the page of results is new, and if it is, add it.
                page_res.ok = true;
                page_res.page_new = true;
                page_res.downloaded_count = 0;
                let num_pages = this.record_sets[act_start_url].pages.length;
                for(let old_page of this.record_sets[act_start_url].pages){
                    if(old_page.id == page_id){
                        page_res.page_new = false;
                        if(old_page.hasOwnProperty('next')){
                            page_res.next_url = old_page.next;
                        }
                    }
                    if(old_page.hasOwnProperty('features')){
                        // Add up the number of existing records.
                        page_res.downloaded_count += old_page.features.length;
                    }
                }
                return page_res;
            },
            add_page_json_to_record_sets: function(page_json){
                if(!page_json){
                    console.log('Problem: page_json missing')
                    return false;
                }
                if(!page_json.hasOwnProperty('id')){
                    console.log('Problem: page_json missing id attribute')
                    return false;
                }
                let page_res = this.check_page_in_record_sets(page_json.id);
                if(!page_res.ok){
                    return false;
                }
                let downloaded_count = page_res.downloaded_count;
                if(!page_res.page_new){
                    // We already have this page downloaded.
                    this.act_downloaded_count = downloaded_count;
                    return true;
                }
                // Everything below happens if the page is new.
                if(page_json.hasOwnProperty('features')){
                    // Add the new page's feature count to the total downloaded count.
                    downloaded_count += page_json.features.length;
                }
                let act_start_url = this.act_start_url;
                this.record_sets[act_start_url].pages.push(page_json);
                this.act_downloaded_count = downloaded_count;
                console.log('Added ' + page_json.id + ' now ' + this.record_sets[act_start_url].pages.length + ' pages.');
                // New and valid.
                if(this.act_downloaded_count >= this.act_total_count){
                    this.dl_complete = true;
                    this.add_geojson_record_layers();
                }
                return true;
            },
            recursive_fetch_oc_records_api: function (url){
                if(this.dl_complete){
                    return true;
                }
                url = replaceURLparameter(url, 'response', this.param_response_value);
                let page_res = this.check_page_in_record_sets(url);
                if(!page_res.ok){
                    return false;
                }
                this.error = null;
                this.loading = true;
                if(!page_res.page_new){
                    // We already have this page downloaded.
                    this.act_downloaded_count = page_res.downloaded_count;
                    if(!this.dl_complete && page_res.next_url != null){
                        this.recursive_fetch_oc_records_api(page_res.next_url); 
                    }
                    this.error = null;
                    this.loading = false;
                    return true;
                }
                fetch(
                    url,
                    {
                        headers:{
                            'Accept': 'application/json',
                        }
                    }
                ).then(async response => {
                    const page_data = await response.json();
                    this.loading = false;
                    // check for error response
                    if (!response.ok) {
                        // get error message from body or default to response status
                        const error = response.status;
                        return Promise.reject(error);
                    }
                    let page_ok = this.add_page_json_to_record_sets(page_data);
                    this.act_page_url = null;
                    if(page_ok){
                        if(page_data.hasOwnProperty('next')){
                            this.act_page_url = page_data.next;
                        }
                    }
                    if(this.dl_complete || (this.act_downloaded_count >= this.act_total_count)){
                        this.dl_complete = true;
                        this.act_page_url = null;
                    }
                    if(this.act_page_url != null){
                        console.log('Fetch next act page ' + this.act_page_url);
                        setTimeout(() => { 
                            this.recursive_fetch_oc_records_api(this.act_page_url); 
                        }, this.sleep_pause);
                    }
                })
                .catch(error => {
                    this.errorMessage = error;
                    console.error('There was an error!', error);
                });
            },
            get_records: function(){
                this.act_total_count = this.prep_record_fetches();
                this.act_downloaded_count = 0;
                this.act_page_url = this.act_start_url;
                console.log('start url is: ' + this.act_start_url);
                this.dl_started = true;
                this.dl_complete = false;
                this.recursive_fetch_oc_records_api(this.act_page_url);
            }
        },
        components: {
            'selectable-dl-attribs': vc_selectable_dl_attribs,
            // 'vue-json-to-csv': vc_json_to_csv,
        }
    }
);



</script>



{% endblock %}