{% load humanize %}

<!-- 
NOTE: Templates and view components to edit an item's identifier objects
-->

<style>
  .invalid_alert {
    margin-top: 6px;
  }
  .man_obj_field_row {
   margin-top: 24px;
   padding-bottom: 12px;
  }
  .meta_form {
    padding: 24px;
  }
  .meta_field_row {
    margin-top: 12px;
    margin-bottom: 12px;
    padding: 12px;
  }
</style>

<template id="group-configs">
  <b-form-group :label="group.label" v-slot="item_type_config">
    <b-form-radio-group
      size="sm"
      :id="'group-' + group.id + '-configs'"
      v-model="item_type_config"
      @change="config_select"
      :options="group.options"
      name="radio-options"
    ></b-form-radio-group>
  </b-form-group>
</template>


<template id="alert-invalid">
  <b-alert
    v-if="val_obj"
    :show="!val_obj.is_valid"
    class="invalid_alert"
    variant="danger">
    <div v-if="val_obj.valid_conflict_examples">
      <small v-if="val_obj.valid_conflict_examples.length > 0">
      Used by: <a 
        :href="'/editorial/item-edit/' + val_obj.valid_conflict_examples[0].uuid"
        target="_blank">
        [[val_obj.valid_conflict_examples[0].label]] ([[val_obj.valid_conflict_examples[0].uuid]])
      </a></small>
    </div>
    <div v-if="val_obj.errors">
      <small v-for="(error, index) in val_obj.errors">[[ error ]] <br/></small>
    </div>
  </b-alert>
</template>


<template id="meta-json-form-item">
  <b-row class="
    meta_field_row 
    border 
    border-info
    border-top-0
    border-right-0
    border-left-0
  ">
    <b-col cols="8" v-if="meta_json && key_config">
      <p><strong>[[ key_config.label ]]</strong> ([[ key_config.key ]])</p>
      <p><small>[[ key_config.note ]]</small></p>
      <b-form-textarea
        v-if="key_config.data_type == 'xsd:string' & !key_config.options"
        debounce="250"
        @change="html_validate"
        :state="is_valid_html"
        :placeholder="meta_json[key_config.key]"
        :value="meta_json[key_config.key]"
      ></b-form-textarea>

      <b-form-select
        v-if="key_config.options"
        v-model="meta_json[key_config.key]"
        :options="key_config.options"
        class="mb-3"
        @change="value_change"
      ></b-form-select>

      <b-form-input
        v-if="key_config.data_type == 'xsd:integer' && !key_config.options"
        type="number"
        @change="value_change"
        :placeholder="meta_json[key_config.key]"
        :value="meta_json[key_config.key]"
      ></b-form-input>

      <div v-if="validation">
        <alert-invalid
          v-bind:val_obj="validation"
        ></alert-invalid>
      </div>

    </b-col>

    <b-col cols="4">
      <b-spinner v-if="updating" label="Updating..."></b-spinner>
      <b-button
        v-if="is_value_changed && !updating && !add_new"
        sm
        block
        @click="update_meta_field"
        class="text-center"
        variant="info">Update
        <b-icon-cloud-check-fill></b-icon-cloud-check-fill>
      </b-button>
      <b-list-group v-if="errors">
        <b-list-group-item v-for="(error, index) in errors"
        :key="'metadata-error-' + index"
        variant="warning">
        <small>[[error]]</small>
        </b-list-group-item>
      </b-list-group>
    </b-col>
  </b-row>
</template>


<template id="meta-json-form">
  <b-container fluid v-if="meta_configs.length > 0" class="meta_form alert-secondary">
    <h5>Administrative Metadata</h5>
    <meta-json-form-item v-for="(key_config, index) in meta_configs"
      v-bind:key_config="key_config"
      v-bind:meta_json="meta_json"
      v-bind:item_id="item_id"
      v-bind:add_new="add_new"
      @get_value_change="get_value_change($event)"
      @update_metadata="update_metadata($event)"
    >
    </meta-json-form-item>
  </div>
</template>


<template id="edit-manifest-obj">
  <div>
    
    <b-row class="
      man_obj_field_row
      border 
      border-secondary
      border-top-0
      border-right-0
      border-left-0">
      <b-col cols="9">
        <label for="input-label"><strong>Label</strong></label>
        <b-form-input 
          @change="check_value_change" 
          size="sm" 
          id="input-label"
          :state="is_attribute_valid('label')"
          v-model="man_obj.label">[[ man_obj.label ]]</b-form-input>
        <div v-if="validations.label">
          <alert-invalid
            v-bind:val_obj="validations.label"
          ></alert-invalid>
        </div>
        <small>A label is the primary name used by people to identify an item. 
          This differs from an item's UUID and URI, both of which are universally 
          unique identifiers used by software. A label is not necessarily unique.
        </small>
      </b-col>
      <b-col cols="3">

      </b-col>
    </b-row>


    <b-row class="
      man_obj_field_row
      border 
      border-secondary
      border-top-0
      border-right-0
      border-left-0">

      <b-col v-if="add_new & item_type_config.edit_uuid">
        <label for="input-uuid"><strong>UUID</strong></label>
        <b-form-input 
          @change="check_value_change"
          size="sm"
          id="input-uuid" 
          :state="is_attribute_valid('uuid')"
          v-model="man_obj.uuid">[[ man_obj.uuid ]]</b-form-input>
        <div v-if="validations.uuid">
          <alert-invalid
            v-bind:val_obj="validations.uuid"
          ></alert-invalid>
        </div>
        <small>The primary database identifier for an item. It must be valid and unique without
          repeated use in Open Context.
          </small>
      </b-col>

      <b-col v-if="item_type_config.edit_slug">
        <label for="input-slug"><strong>Slug</strong></label>
        <b-form-input 
          @change="check_value_change" 
          size="sm" 
          id="input-slug"
          :state="is_attribute_valid('slug')"
          v-model="man_obj.slug">[[ man_obj.slug ]]</b-form-input>
        <div v-if="validations.slug">
          <alert-invalid
            v-bind:val_obj="validations.slug"
          ></alert-invalid>
        </div>
        <small>This is a secondary identifier for an item, intended to make readable URLs. 
          It must be valid and unique without repeated use in Open Context.
          </small>
      </b-col>
      
      <b-col v-if="item_type_config.edit_item_key">
        <label for="input-item-key"><strong>Item Key</strong></label>
        <b-form-input 
          @change="check_value_change" 
          size="sm" 
          id="input-item-key"
          :state="is_attribute_valid('item_key')"
          v-model="man_obj.item_key">[[ man_obj.item_key ]]</b-form-input>
        <div v-if="validations.item_key">
          <alert-invalid
            v-bind:val_obj="validations.item_key"
          ></alert-invalid>
        </div>
        <small>This is an abbreviated identifier for an item, that provides a convenient short
          way of identifying an entity in JSON-LD representations. For example, 
          <code>dc-terms:creator</code> is used as an abbreviated identifier of the full
          URL <code>http://purl.org/dc/terms/creator</code>. It must be valid and unique 
          without repeated use in Open Context.
        </small>
      </b-col>

    </b-row>
    

    <b-row v-if="add_new & item_type_config.edit_uri" class="
      man_obj_field_row
      border 
      border-secondary
      border-top-0
      border-right-0
      border-left-0">
      <b-col cols="9">
        <label for="input-uri"><strong>URI</strong></label>
        <b-form-input 
          @change="check_value_change" 
          size="sm" 
          id="input-uri"
          :state="is_attribute_valid('uri')"
          v-model="man_obj.uri">[[ man_obj.uri ]]</b-form-input>
        <div v-if="validations.uri">
          <alert-invalid
            v-bind:val_obj="validations.uri"
          ></alert-invalid>
        </div>
        <small>This is an item's primary Web identifier (URI). A URI is used to uniquely reference
          Linked Data resources published outside of Open Context. For these outside
          Linked Data, Open Context derives a (non-random, deterministic) corresponding UUID 
          as an internal database identifier. Open Context will always create the same UUID
          for a given URI.
        </small>
      </b-col>
      <b-col cols="3">

      </b-col>
    </b-row>


    <b-row v-if="item_type_config.data_type_options" class="
      man_obj_field_row
      border 
      border-secondary
      border-top-0
      border-right-0
      border-left-0">
      <b-col cols="9">
        <label for="input-item-class-id"><strong>Data Type </strong>
          <span v-if="man_obj.data_type">[[ man_obj.data_type ]]</span>
        </label><br/>
        <b-form-select
          v-model="man_obj.data_type"
          :options="item_type_config.data_type_options"
          class="mb-3"
          @change="check_value_change"
        ></b-form-select>
        <small>The types of values that can be used with this <em>[[ man_obj.item_type ]]</em> item.
        </small>
      </b-col>
      <b-col cols="3">

      </b-col>
    </b-row>


    <b-row v-if="item_type_config.item_class_lookup" class="
      man_obj_field_row
      border 
      border-secondary
      border-top-0
      border-right-0
      border-left-0">
      <b-col cols="5">
        <label for="input-item-class-id"><strong>Item Class / Category </strong>
          <span v-if="man_obj.item_class__label">[[ man_obj.item_class__label ]]</span>
        </label><br/>
        <b-form-input
          @change="check_value_change"
          size="sm" 
          id="input-class-id" 
          v-model="man_obj.item_class_id">[[ man_obj.item_class_id ]]</b-form-input>
        <small>This is an item's primary classification within an item-type.
        </small>
      </b-col>
      <b-col cols="4">
        <small>Navigate below to select an item class.</small><br/>
        <div style="font-size: 75%;">
          <root-item-tree
            v-bind:root_item_id="'oc-gen-' + man_obj.item_type"
            v-bind:cached_tree_items="cached_tree_items"
            @set_selected_item="set_selected_class_item($event)"
          ></root-item-tree>
        </div>
      </b-col>
      <b-col cols="3">

      </b-col>
    </b-row>


    <b-row v-if="item_type_config.context_lookup" class="
      man_obj_field_row
      border 
      border-secondary
      border-top-0
      border-right-0
      border-left-0">
      <b-col cols="5">
        <label for="input-context-id"><strong>Context </strong>
          <span v-if="man_obj.context__label">[[ man_obj.context__label ]]</span>
        </label><br/>
        <b-form-input
          @change="check_value_change"
          size="sm" 
          id="input-context-id" 
          v-model="man_obj.context_id">[[ man_obj.context_id ]]</b-form-input>

        <small v-if="man_obj.item_type == 'subjects'">
          A location or object item needs to be contained within a broader location or object context.
        </small>
        <small v-else-if="man_obj.item_type == 'projects'">
          A project may be contained in the context of another project.
        </small>
        <small v-else-if="man_obj.item_type == 'types'">
          A descriptive predicate must provide the context for a controlled-vocabulary type item.
        </small>
        <small v-else>
          A vocabulary must be given to provide context for Linked Data resources.
        </small>

      </b-col>
      <b-col cols="4">
        <small>Search and select a context below</small><br/>
        <lookup-list
          key="context-lookup"
          v-bind:project_id="project_ids"
          v-bind:item_type="item_type_config.context_lookup.item_type"
          v-bind:data_type="item_type_config.context_lookup.data_type"
          v-bind:do_meta="true"
          v-bind:show_project="item_type_config.context_lookup.show_project"
          v-bind:show_item_class="item_type_config.context_lookup.show_item_class"
          v-bind:show_total_results="item_type_config.context_lookup.show_total_results"
          v-bind:show_q_search_box="item_type_config.context_lookup.show_q_search_box"
          v-bind:show_label_search_box="item_type_config.context_lookup.show_label_search_box"
          v-bind:show_path_search_box="item_type_config.context_lookup.show_path_search_box"
          @set_selected_item="set_selected_context_item($event)"
        ></lookup-list>
      </b-col>
      <b-col cols="3">

      </b-col>
    </b-row>


    <b-row v-if="item_type_config.project_lookup" class="
      man_obj_field_row
      border 
      border-secondary
      border-top-0
      border-right-0
      border-left-0">
      <b-col cols="5">
        <label for="input-project-id"><strong>Project </strong>
          <span v-if="man_obj.project__label">[[ man_obj.project__label ]]</span>
        </label><br/>
        <b-form-input
          @change="check_value_change"
          size="sm" 
          id="input-project-id" 
          v-model="man_obj.project_id">[[ man_obj.project_id ]]</b-form-input>

        <small>
          The project or collection into which this item belongs.
        </small>

      </b-col>
      <b-col cols="4">
        <small>Search and select a project below</small><br/>
        <lookup-list
          key="project-lookup"
          v-bind:item_type="item_type_config.project_lookup.item_type"
          v-bind:do_meta="true"
          v-bind:show_project="item_type_config.project_lookup.show_project"
          v-bind:show_total_results="item_type_config.project_lookup.show_total_results"
          v-bind:show_q_search_box="item_type_config.project_lookup.show_q_search_box"
          v-bind:show_label_search_box="item_type_config.project_lookup.show_label_search_box"
          @set_selected_item="set_selected_project_item($event)"
        ></lookup-list>
      </b-col>
      <b-col cols="3">

      </b-col>
    </b-row>



    <b-row class="man_obj_field_row" v-if="item_type_config.meta_json_edit">
      <b-col cols="12">
        <meta-json-form
          v-bind:meta_json="man_obj.meta_json"
          v-bind:meta_configs="item_type_config.meta_json_edit"
          v-bind:item_id="man_obj.uuid"
          v-bind:add_new="true"
          @update_metadata="update_metadata($event)"
          >
        </meta-json-form>
      </b-col>
    </b-row>
  </div>
</template>


<template id="add-item">
  <div>
    <b-modal
      size="lg"
      scrollable
      ref="add-item-modal"
      id="add-item-modal" 
      title="Add Item"
      @shown="on_shown"
    >
      <b-container fluid v-if="configs">
        <b-row v-if="!item_type_config">
          <b-col cols="12">
            <h5>Select Item Type to Create</h5>
          </b-col>
        </b-row>
        <b-row v-if="item_type_config">
          <b-col cols="9">
            <b-alert show>
              <h5>Create <strong>[[ item_type_config.item_type ]]</strong> item</h5>
              <p>[[ item_type_config.item_type_note ]] </p>
            </b-alert>
          </b-col>
          <b-col cols="3">
            <b-button
              sm
              @click="config_deselect"
              variant="outline-secondary"
              title="Select a different item type to create"
              class="text-center">Change type <b-icon-patch-minus-fill></b-icon-patch-minus-fill>
            </b-button>
          </b-col>
        </b-row>
        <b-row v-if="!item_type_config">
          <b-col v-for="(group_config, index) in group_options" cols="3">
            <group-configs
              @config_select="config_select($event)"
              v-bind:group="group_config">
            </group-configs>
          </b-col>
        </b-row>
        <div v-if="item_type_config">
          
          <edit-manifest-obj
            @update_metadata="update_metadata($event)"
            v-bind:add_new="true"
            v-bind:item_type_config="item_type_config"
            v-bind:project_ids="project_ids"
            v-bind:man_obj="man_obj">
          </edit-manifest-obj>

        </div>
      </b-container>
    </b-modal>
    <b-button
      sm
      block
      @click="toggle_add_new_item"
      variant="primary">Add New Item <b-icon-plus-circle-fill></b-icon-plus-circle-fill></b-button>
  </div>
</template>





<script type="text/javascript">

const OC_LINKS_ID = '{{ OC_LINKS_ID }}';
const DEFAULT_CLASS = JSON.parse('{{ DEFAULT_CLASS|escapejs }}');
const OPEN_CONTEXT_PROJ_UUID = '{{ OPEN_CONTEXT_PROJ_UUID }}';
const EDITING_PROJECT = JSON.parse('{{ EDITING_PROJECT|escapejs }}');


var vc_group_configs = Vue.component(
  'group-configs',
  {
    delimiters: ['[[', ']]'],
    props: ['group'],
    data() {
      return {
        group: null,
        item_type_config: null,
      };
    },
    template: '#group-configs',
    methods: {
      config_select(config){
        this.item_type_config = config;
        this.$emit('config_select', this.item_type_config);
      },
    },
  },
);


var vc_alert_invalid = Vue.component(
  'alert-invalid',
  {
    delimiters: ['[[', ']]'],
    props: ['val_obj'],
    data() {
      return {
        val_obj: null,
      };
    },
    template: '#alert-invalid',
    methods: {
    },
  },
);


var vc_meta_json_form_item = Vue.component(
  'meta-json-form-item',
  {
    delimiters: ['[[', ']]'],
    props: ['meta_json', 'key_config', 'item_id', 'add_new'],
    data() {
      return {
        key_config: null,
        meta_json: null,
        item_id: null,
        add_new: false,
        original_meta_json_str: null,
        is_value_changed: false,
        is_valid_html: null,
        updating: false,
        errors: null,
        validation: null,
      };
    },
    template: '#meta-json-form-item',
    mounted() {
      this.set_original_meta_json();
    },
    computed: {
      
    },
    methods: {
      set_original_meta_json: function (){
        if(!this.add_new && this.meta_json){
          // Hack to make a deep-copy.
          this.original_meta_json_str = JSON.stringify(this.meta_json);
          console.log('Original meta_json cached as JSON str');
        }
      },
      reset_to_original_meta_json: function () {
        if(this.original_meta_json_str){
          this.meta_json = JSON.parse(this.original_meta_json_str);
          this.is_value_changed = false;
          console.log('Reset to original meta_json from cache');
        }
      },
      get_original_value() {
        if(this.original_meta_json_str){
          let orig_meta_json = JSON.parse(this.original_meta_json_str);
          return orig_meta_json[this.key_config.key];
        }
        return null;
      },
      fetch_api_validation(key, params){
        const requestOptions = {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        };
        fetch(
          ('/editorial/item-manifest-validation?' + new URLSearchParams(params)), 
          requestOptions,
        )
        .then(this.loading = false)
        .then(response => response.json())
        .then(json => {
          this.validation = json;
          return this.validation;
        });
      },
      validate_short_id(short_id){
        let params = {};
        if(this.item_id){
          params.uuid = this.item_id;
        }
        params.short_id = short_id;
        this.fetch_api_validation('short_id', params);
      },
      value_change(input_value) {
        this.meta_json[this.key_config.key] = input_value;
        if(!this.add_new){
          let orig_value = this.get_original_value();
          this.is_value_changed = (input_value != orig_value);
        }
        else{
          this.is_value_changed = true;
        }

        if (this.is_value_changed && this.key_config.key == 'short_id'){
          this.validate_short_id(input_value);
        }

        let output = {
          input_value: input_value,
          is_value_changed: this.is_value_changed,
          meta_json: this.meta_json,
          validation: this.validation,
        };
        console.log(output);
        this.$emit('get_value_change', output);
        return output;
      },
      update_meta_field: function () {
        if(this.add_new || !this.item_id){
          return null;
        }
        this.updating = true;
        this.$emit('update_metadata', this.meta_json);
      },
      html_validate(input_value) {
        this.input_value = input_value.trim();
        this.value_change(input_value);
        const requestOptions = {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken,
          },
          body: JSON.stringify(
            {str: input_value}
          ),
        };
        fetch('/editorial/html-validate', requestOptions)
          .then(async response => {
            const data = await response.json();
            // check for error response
            if (!response.ok) {
              // get error message from body or default to response status
              const error = (data && data.message) || response.status;
              return Promise.reject(error);
            }
            this.is_valid_html = data.ok;
            this.errors = data.errors;
            this.$emit('get_validation_errors', this.errors);
          })
          .catch(error => {
            this.errorMessage = error;
            console.error('There was an error!', error);
          }
        );
      },
    },
    components: {
      'meta-json-form-item': vc_meta_json_form_item,
    },
  }
); 

var vc_meta_json_form = Vue.component(
  'meta-json-form',
  {
    delimiters: ['[[', ']]'],
    props: ['meta_json', 'meta_configs', 'item_id', 'add_new'],
    data() {
      return {
        meta_configs: null,
        meta_json: null,
        item_id: null,
        add_new: false,
      };
    },
    template: '#meta-json-form',
    mounted() {
      this.set_empty_keys();
    },
    computed: {
      
    },
    methods: {
      set_empty_keys(){
        if(!this.meta_configs){
          return null;
        }
        if(!this.meta_json){
          this.meta_json = Object;
        }
        for(let key_config of this.meta_configs){
          let key = key_config.key;
          if(this.meta_json.hasOwnProperty(key)){
            continue;
          }
          if(key_config.options){
            this.meta_json[key] = key_config.options[0].value;
          }
          else if(key_config.data_type == 'xsd:string'){
            this.meta_json[key] = '';
          }
          else {
            this.meta_json[key] = false;
          }
        }

      },
      get_value_change(change) {
        console.log('event get_value_change');
        console.log(change);
      },
      update_metadata(meta_json){
        this.meta_json = meta_json;
        this.$emit('update_metadata', this.meta_json);
      }
    },
    components: {
      'alert-invalid': vc_alert_invalid,
    },
  }
); 


var vc_edit_manifest_obj = Vue.component(
  'edit-manifest-obj',
  {
    delimiters: ['[[', ']]'],
    props: ['add_new', 'item_type_config', 'man_obj', 'project_ids',],
    data() {
      return {
        add_new: false,
        item_type_config: null,
        man_obj: null,
        project_ids: [],
        cached_tree_items: {},
        original_man_obj_str: null,
        is_value_changed: false,
        keyed_value_changes: {checked: false},
        validations: {
          label: null,
          uuid: null,
          slug: null,
          item_key: null,
          uri: null,
        },
        cached_validations: {},
      }
    },
    template: '#edit-manifest-obj',
    mounted() {
      this.set_original_man_obj();
    },
    created() {

    },
    computed: {
      web_url: function() {
        if(!this.man_obj || !this.man_obj.uri){
          return null;
        }
        let url = this.trim_prefix(this.man_obj.uri, 'https://');
        return 'https://' + this.trim_prefix(url, 'http://');
      },
      add_ok: function() {
        if(!this.add_new || !this.man_obj){
          return false;
        }
      },
    },
    methods: {
      set_original_man_obj: function (){
        if(this.man_obj){
          // Hack to make a deep-copy.
          this.original_man_obj_str = JSON.stringify(this.man_obj);
        }
      },
      reset_to_original_man_obj: function () {
        if(this.original_man_obj_str){
          this.man_obj = JSON.parse(this.original_man_obj_str);
          this.is_value_changed = false;
          this.keyed_value_changes = {checked: false};
        }
      },
      trim_prefix(str, prefix) {
        if (str.startsWith(prefix)) {
            return str.slice(prefix.length);
        } else {
            return str;
        }
      },
      uri_change(input_value) {
        input_value = this.trim_prefix(input_value, 'https://');
        input_value = this.trim_prefix(input_value, 'http://');
        return input_value;
      },
      is_attribute_valid(key) {
        if(!this.validations || !this.validations.hasOwnProperty(key)){
          return null;
        }
        let validation_result = this.validations[key];
        if(!validation_result){
          return null;
        }
        if(!validation_result.hasOwnProperty('is_valid')){
          return null;
        }
        return validation_result.is_valid;
      },
      get_cached_validation(params){
        let params_str = JSON.stringify(params);
        if(!this.cached_validations.hasOwnProperty(params_str)){
          return null;
        }
        return this.cached_validations[params_str];
      },
      cache_validation(params, validation_result){
        let params_str = JSON.stringify(params);
        this.cached_validations[params_str] = validation_result;
      },
      fetch_api_validation(key, params){
        const requestOptions = {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
          },
        };
        fetch(
          ('/editorial/item-manifest-validation?' + new URLSearchParams(params)), 
          requestOptions,
        )
        .then(this.loading = false)
        .then(response => response.json())
        .then(json => {
          this.cache_validation(params, json);
          this.validations[key] = json;
          return this.validations[key];
        });
      },
      validate_label(label){
        let params = {};
        if(!this.add_new && this.man_obj){
          params.uuid = this.man_obj.uuid;
        }
        params.label = label;
        params.item_type = this.man_obj.item_type;
        params.project_id = this.man_obj.project_id;
        if(this.item_type_config.context_lookup && this.man_obj.context_id){
          // Context is significant for labels, so add
          params.context_id = this.man_obj.context_id;
        }
        let valid_result = this.get_cached_validation(params);
        if(!valid_result){
          this.fetch_api_validation('label', params);
        }
        else{
          this.validations.label = valid_result;
        }
        console.log('validated label');
        console.log(this.validations);
      },
      validate_uuid(uuid){
        let params = {};
        if(!this.add_new && this.man_obj){
          params.uuid = this.man_obj.uuid;
        }
        params.new_uuid = uuid;
        let valid_result = this.get_cached_validation(params);
        if(!valid_result){
          this.fetch_api_validation('uuid', params);
        }
        else{
          this.validations.uuid = valid_result;
        }
      },
      validate_slug(slug){
        let params = {};
        if(!this.add_new && this.man_obj){
          params.uuid = this.man_obj.uuid;
        }
        params.slug = slug;
        let valid_result = this.get_cached_validation(params);
        if(!valid_result){
          this.fetch_api_validation('slug', params);
        }
        else{
          this.validations.slug = valid_result;
        }
      },
      validate_item_key(item_key){
        let params = {};
        if(!this.add_new && this.man_obj){
          params.uuid = this.man_obj.uuid;
        }
        params.item_key = item_key;
        let valid_result = this.get_cached_validation(params);
        if(!valid_result){
          this.fetch_api_validation('item_key', params);
        }
        else{
          this.validations.item_key = valid_result;
        }
      },
      validate_uri(uri){
        let params = {};
        if(!this.add_new && this.man_obj){
          params.uuid = this.man_obj.uuid;
        }
        params.uri = uri;
        let valid_result = this.get_cached_validation(params);
        if(!valid_result){
          this.fetch_api_validation('uri', params);
        }
        else{
          this.validations.uri = valid_result;
        }
      },
      check_value_change: function() {
        if(this.man_obj.item_class_id == OC_LINKS_ID){
          // A predicate link class MUST have a data_type of 'id'
          this.man_obj.data_type = 'id';
        }
        if(!this.original_man_obj_str){
          this.is_value_changed = false;
          return this.is_value_changed;
        }
        let orig = JSON.parse(this.original_man_obj_str);
        this.is_value_changed = false;
        this.keyed_value_changes.checked = true;
        for (let key in orig) {
          if (orig.hasOwnProperty(key) && this.man_obj.hasOwnProperty(key)) {
            this.keyed_value_changes[key] = false;
            if(orig[key] != this.man_obj[key]){
              this.is_value_changed = true;
              this.keyed_value_changes[key] = true;
              if(key == 'label'){
                this.validate_label(this.man_obj[key]);
              }
              if(key == 'uuid'){
                this.validate_uuid(this.man_obj[key]);
              }
              if(key == 'slug'){
                this.validate_slug(this.man_obj[key]);
              }
              if(key == 'item_key'){
                this.validate_item_key(this.man_obj[key]);
              }
              if(key == 'uri'){
                this.validate_uri(this.man_obj[key]);
              }
            }
            else{
              if(this.validations.hasOwnProperty(key)){
                this.validations[key] = null;
              }
            }
          }
        }
        return this.is_value_changed;
      },
      set_selected_class_item(class_item) {
        this.man_obj.item_class_id = class_item.uuid;
        this.man_obj.item_class__label = class_item.label;
        this.check_value_change();
      },
      set_selected_context_item(context_item) {
        this.man_obj.context_id = context_item.uuid;
        this.man_obj.context__label = context_item.label;
        this.check_value_change();
      },
      set_selected_project_item(project_item) {
        this.man_obj.project_id = project_item.uuid;
        this.man_obj.project__label = project_item.label;
        this.check_value_change();
      },
      update_metadata(meta_json){
        this.man_obj.meta_json = meta_json;
        this.check_value_change();
      },
      update_item: function() {
        if(this.add_new || !this.is_value_changed){
          return null;
        }
        let orig = JSON.parse(this.original_man_obj_str);
        let update_obj = {
          uuid: this.man_obj.uuid,
        };
        for (let key in this.man_obj) {
          if (orig.hasOwnProperty(key) && this.man_obj.hasOwnProperty(key)) {
            if(orig[key] != this.man_obj[key]){
              update_obj[key] = this.man_obj[key];
            }
          }
        }
        console.log(update_obj);
        let update_objs = [];
        update_objs.push(update_obj);
        const requestOptions = {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken,
          },
          body: JSON.stringify(update_objs),
        };
        fetch('/editorial/item-update-manifest', requestOptions)
        .then(async response => {
          const data = await response.json();
          this.updating = false;
          // check for error response
          if (!response.ok) {
            // get error message from body or default to response status
            const error = (data && data.message) || response.status;
            if(data && data.errors){
              this.errors = data.errors;
            }
            return Promise.reject(error);
          }
          // Share the news we just did an edit
          this.$emit('manifest_update_done', true);
        })
        .catch(error => {
          console.log(error);
          console.log(this.errors);
        });
      },
    },
    components: {
      'root-item-tree': vs_root_item_tree,
      'lookup-list': vs_look_up_list,
      'alert-invalid': vc_alert_invalid,
      'meta-json-form-item': vc_meta_json_form_item,
    },
  },
);

var vc_add_item = Vue.component(
  'add-item',
  {
    delimiters: ['[[', ']]'],
    props: ['project_ids', ],
    data() {
      return {
        configs: null,
        item_type_config: null,
        project_ids: [],
        new_item_template: {
          uuid: null,
          slug: null,
          item_key: null,
          label: null,
          item_type: null,
          uri: null,
          item_class_id: null,
          context_id: null,
          project_id: null,
          meta_json: {},
        },
        cached_tree_items: {},
        man_obj: null,
      };
    },
    template: '#add-item',
    created() {
      this.fetch_api_configs();
    },
    computed: {
      group_options: function() {
        if(!this.configs){
          return [];
        }
        let grp_options = [];
        let i = 0;
        for(let grp_config of this.configs){
          i += 1;
          let grp_option = {
            label: grp_config.group,
            id: i,
            options: [],
          };
          for(let item_type_config of grp_config.item_types){
            let option = {
              value: item_type_config,
              text: item_type_config.item_type,
            }
            grp_option.options.push(option);
          }
          grp_options.push(grp_option);
        }
        return grp_options;
      }
    },
    methods: {
      fetch_api_configs: function (){
        this.error = null;
        this.loading = true;
        fetch(
          ('/editorial/item-add-configs'),
            {
              headers:{
                  'Accept': 'application/json',
              }
            }
        )
        .then(this.loading = false)
        .then(response => response.json())
        .then(json => {
          this.configs = json;
          console.log(this.configs);
        });
      },
      on_shown: function() {
        console.log('show add item modal');
      },
      toggle_add_new_item: function() {
        this.$bvModal.show('add-item-modal');
      },
      config_select(config){
        this.item_type_config = config;
        let template_str = JSON.stringify(this.new_item_template);
        this.man_obj = JSON.parse(template_str);
        this.man_obj.item_type = this.item_type_config.item_type;
        this.man_obj.data_type = this.item_type_config.data_type;
        this.man_obj.project_id = EDITING_PROJECT.uuid;
        this.man_obj.project__label = EDITING_PROJECT.label;
        if(this.item_type_config.project_id){
          this.man_obj.project_id = this.item_type_config.project_id;
        }
        if(this.man_obj.project_id == OPEN_CONTEXT_PROJ_UUID){
          this.man_obj.project__label = 'Open Context (General)';
        }
        if(this.item_type_config.item_class_id && !this.item_type_config.context_lookup){
          this.man_obj.item_class_id = this.item_type_config.item_class_id;
        }
        if(!this.item_type_config.context_lookup){
          // If there's no context lookup, then the context will be the
          // same as the item project.
          this.man_obj.context_id = this.man_obj.project_id;
        }
        console.log(this.item_type_config);
        console.log(this.man_obj);
      },
      config_deselect: function (){
        this.item_type_config = null;
        this.man_obj = null;
      },
    },
    components: {
      'group-configs': vc_group_configs,
      'edit-manifest-obj': vc_edit_manifest_obj,
    },
  }
); 
  
</script>