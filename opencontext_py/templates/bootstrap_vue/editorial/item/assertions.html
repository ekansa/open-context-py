{% load humanize %}

<!-- 
NOTE: Templates and view components to edit assertions made on an item
-->

<style>
 .obs_row {
   margin-top: 48px;
 }
 .obj_row {
   margin-top: 12px;
   margin-bottom: 12px;
 }
 .pred_col {
   width: 33%;
 }
</style>

<template id="assert-uuid">
  <b-row>
    <b-col>
      <div v-for="(alert_uuid, index) in alert_update_uuids">
        <b-alert
          v-if="alert_uuid == assert.uuid"
          class="row_update_alert"
          :show="dismissCountDown"
          responsive="sm"
          fade
          variant="success"
          @dismissed="onDissmiss"
          @dismiss-count-down="countDownChanged"
          ><b-icon-cloud-upload-fill></b-icon-cloud-upload-fill>
        </b-alert>
        <span v-else>[[assert.updated]]</span>
      </div>
    </b-col>
  </b-row>
</template>

<template id='assert-object'>
  <b-row class="obj_row">
    <b-col cols="9">
      <b-form-group label="Boolean (True/False)" v-if="assert.predicate__data_type == 'xsd:boolean'">
        <b-form-radio :selected="assert.obj_boolean" v-model="selected" :name="'radio-' + assert.uuid" value="true">True</b-form-radio>
        <b-form-radio :selected="assert.obj_boolean" v-model="selected" :name="'radio-' + assert.uuid" value="false">False</b-form-radio>
      </b-form-group>
      <b-form-textarea
        v-if="assert.predicate__data_type == 'xsd:string'"
        debounce="250"
        @change="html_validate"
        :state="is_valid_html"
        :placeholder="assert.obj_string"
        :value="assert.obj_string"
      ></b-form-textarea>
      <b-form-input
        v-if="assert.predicate__data_type == 'xsd:integer'"
        type="number"
        @change="value_change"
        :placeholder="assert.obj_integer"
        :value="assert.obj_integer"
      ></b-form-input>
      <b-form-input
        v-if="assert.predicate__data_type == 'xsd:double'"
        type="number"
        @change="value_change"
        :placeholder="assert.obj_double"
        :value="assert.obj_double"
      ></b-form-input>
      <b-form-input
        v-if="assert.predicate__data_type == 'xsd:date'"
        type="date"
        @change="value_change"
        :value="assert.obj_datetime"
      ></b-form-input>
      <div v-if="assert.predicate__data_type == 'id'">
        <b-row>
          <b-col cols="2">
            <b-button
              v-if="!is_object_edit_open"
              sm
              block
              @click="toggle_object_edit"
              variant="info">Edit</b-button>
              <b-button
              v-if="is_object_edit_open"
              sm
              block
              @click="toggle_object_edit"
              variant="outline-secondary">Close</b-button>
          </b-col>
          <b-col cols="10">
            [[assert.object__label]]
            <br/>
            <small>ID: <span class="text-muted">[[assert.object_id]]</span></small>
          </b-col>
        </b-row>
        <b-row v-if="is_object_edit_open">
          <b-col v-if="assert.predicate__item_class_id == OC_VARIABLES.uuid">
            <lookup-list
              :key="'lookup' + assert.uuid"
              v-bind:context_id="[assert.predicate_id]"
              v-bind:show_label_search_box="true"
              v-bind:fetch_on_create="true"
              @set_selected_item="set_selected_obj_item($event)"
            ></lookup-list>
          </b-col>
        </b-row>
      </div>
    </b-col>
    <b-col cols="3">
      <b-spinner v-if="updating" label="Updating..."></b-spinner>
      <b-button
        v-if="is_value_changed && !updating"
        sm
        block
        @click="update_object_value"
        variant="info">Update to <strong>[[ disp_changed_value ]]</strong></b-button>
      <b-list-group v-if="errors">
        <b-list-group-item v-for="(error, index) in errors"
        :key="assert.uuid + '-error-' + index"
        variant="warning">
        <small>[[error]]</small>
        </b-list-group-item>
      </b-list-group>
    </b-col>
  </b-row>
</template>

<template id='assert-objects'>
  <div>
    <assert-object 
      v-for="(assert, index) in assert_node.objs"
      :key="assert.uuid"
      @assertion_update_done="assertion_update_done($event)"
      v-bind:assert="assert"
    ></assert-object>
  </div>
</template>

<template id="edit-observation">
  <div v-if="act_obs.assertions">
    <b-table
      ref="obs_assertions"
      small
      striped
      selectable
      table-variant="secondary"
      :select-mode="selectMode"
      :items="act_obs.assertions"
      :fields="fields"
      @row-selected="onRowSelected"
      :sort-by.sync="sortBy"
      :sort-desc.sync="sortDesc"
      responsive="lg"
      caption-top
    >
      <template #table-caption>[[ act_obs.label ]]</template>

      <template #cell(uuid)="data">
        <assert-uuid
          @countdown_done="remove_alert_update_uuid($event)"
          v-bind:alert_timer_state="alert_timer_state"
          v-bind:alert_timer_duration="alert_timer_duration"
          v-bind:assert="data.item"
          v-bind:alert_update_uuids="alert_update_uuids">
        </assert-uuid>
      </template>

      <template #cell(predicate__label)="data">
        <p v-if="data.item.event_id != DEFAULT_EVENT.uuid">
          <small>[[ data.item.event__label ]]</small>
        </p>
        <p v-if="data.item.attribute_group_id != DEFAULT_ATTRIBUTE_GROUP.uuid">
          <small>[[ data.item.attribute_group__label ]]</small>
        </p>
        [[ data.item.predicate__label ]]
      </template>

      <template #cell(objs)="data">
        <assert-objects
          @assertion_update_done="assertion_update_done($event)"
          v-bind:assert_node="data.item"
        >
        </assert-objects>
      </template>
      
      <template #cell()="data">
        [[ data.value ]]
      </template>

    </b-table>

  </div>
</template>


<template id="edit-assertions">
  <div v-if="assertions_in_obs">
    <h4>Observation Count [[ assertions_in_obs.length ]]</h4>
    <b-row class="obs_row" v-for="(act_obs, index) in assertions_in_obs">
      <b-col>
        <edit-observation 
          @assertion_update_done="assertion_update_done($event)"
          v-bind:act_obs="act_obs"
          v-bind:table_height="table_height"></edit-observation>
      </b-col>
    </b-row>


  </div>
</template>


<script type="text/javascript">

const DEFAULT_EVENT = JSON.parse('{{ DEFAULT_EVENT|escapejs }}');
const DEFAULT_ATTRIBUTE_GROUP = JSON.parse('{{ DEFAULT_ATTRIBUTE_GROUP|escapejs }}');
const DEFAULT_LANG = JSON.parse('{{ DEFAULT_LANG|escapejs }}');
const PREDICATE_CONTAINS = JSON.parse('{{ PREDICATE_CONTAINS|escapejs }}');
const OC_VARIABLES = JSON.parse('{{ OC_VARIABLES|escapejs }}');
const OC_LINKS = JSON.parse('{{ OC_LINKS|escapejs }}');

  var vs_assert_uuid = Vue.component(
    'assert-uuid',
    {
      delimiters: ['[[', ']]'],
      props: ['assert', 'alert_update_uuids', 'alert_timer_duration', 'alert_timer_state'],
      data() {
        return {
          assert: null,
          dismissSecs: 2,
          dismissCountDown: 2,
        };
      },
      template: '#assert-uuid',
      methods: {
        countDownChanged(dismissCountDown) {
          this.dismissCountDown = dismissCountDown
        },
        showAlert() {
          this.dismissCountDown = this.dismissSecs
        },
        onDissmiss(){
          this.$emit('countdown_done', this.assert.uuid);
          // Reset the dismiss countdown to re-render if
          // this ds_field gets another update.
          this.dismissCountDown = this.dismissSecs;
        },
      }
    },
  );

  var vs_assert_object = Vue.component(
    'assert-object',
    {
      delimiters: ['[[', ']]'],
      props: ['assert', ],
      data() {
        return {
          assert: null,
          is_object_edit_open: false,
          selected_item: null,
          input_value: null,
          is_valid_html: null,
          errors: null,
          updating: false,
        };
      },
      template: '#assert-object',
      computed: {
        returned_value: function () {
          if(!this.assert){
            return null;
          }
          if(this.assert.predicate__data_type == 'xsd:boolean'){
            return assert.obj_boolean;
          }
          if(this.assert.predicate__data_type == 'xsd:string'){
            return this.assert.obj_string;
          }
          if(this.assert.predicate__data_type == 'xsd:integer'){
            return this.assert.obj_integer;
          }
          if(this.assert.predicate__data_type == 'xsd:double'){
            return this.assert.obj_double;
          }
          if(this.assert.predicate__data_type == 'xsd:date'){
            return this.assert.obj_datetime;
          }
          if(this.assert.predicate__data_type == 'id'){
            return this.assert.object_id;
          }
          return null;
        },
        disp_changed_value: function() {
          if(this.input_value === null){
            return null;
          }
          let max_length = 20;
          let act_val = '';
          if(!this.selected_item){
            act_val += this.input_value;
          }
          else{
            act_val += this.selected_item.label;
          }
          return act_val.length > max_length ? act_val.substring(0, max_length) + "..." : act_val;
        },
        is_value_changed: function() {
          if(this.input_value === null){
            return null;
          }
          if(this.returned_value === null){
            return null;
          }
          return (this.input_value != this.returned_value);
        }
      },
      methods: {
        toggle_object_edit() {
          if(this.is_object_edit_open === null){
            this.is_object_edit_open = false;
          }
          this.is_object_edit_open = !this.is_object_edit_open;
        },
        set_selected_obj_item(obj_item) {
          this.selected_item = obj_item;
          this.input_value = this.selected_item.uuid;
          console.log('selected_item: ' + this.selected_item.label);
        },
        value_change(input_value) {
          this.input_value = input_value;
        },
        html_validate(input_value) {
          this.input_value = input_value.trim();
          const requestOptions = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': csrftoken,
            },
            body: JSON.stringify(
              {str: input_value}
            ),
          };
          fetch('/editorial/html-validate', requestOptions)
            .then(async response => {
              const data = await response.json();
              // check for error response
              if (!response.ok) {
                // get error message from body or default to response status
                const error = (data && data.message) || response.status;
                return Promise.reject(error);
              }
              this.is_valid_html = data.ok;
              this.errors = data.errors;
            })
            .catch(error => {
              this.errorMessage = error;
              console.error('There was an error!', error);
            }
          );
        },
        update_object_value: function() {
          if(this.input_value === null){
            console.log('No input value for the object');
            return null;
          }
          if(this.input_value === this.returned_value){
            console.log('No object value change detected');
            return null;
          }
          this.updating = true;
          let update_obj = {
            uuid: this.assert.uuid,
            // subject_id: this.assert.subject_id,
            // observation_id: this.assert.observation_id,
            // event_id: this.assert.event_id,
            // attribute_group_id: this.assert.attribute_group_id,
            // predicate_id: this.assert.predicate_id,
            // language_id: this.assert.language_id,
            // sort: this.assert.sort,
          };
          if(this.assert.predicate__data_type == 'xsd:boolean'){
            update_obj.obj_boolean = this.input_value;
          }
          if(this.assert.predicate__data_type == 'xsd:string'){
            update_obj.obj_string = this.input_value;
          }
          if(this.assert.predicate__data_type == 'xsd:integer'){
            update_obj.obj_integer = this.input_value;
          }
          if(this.assert.predicate__data_type == 'xsd:double'){
            update_obj.obj_double = this.input_value;
          }
          if(this.assert.predicate__data_type == 'xsd:date'){
            update_obj.obj_datetime = this.input_value;
          }
          if(this.assert.predicate__data_type == 'id'){
            update_obj.object_id = this.input_value;
          }
          let update_objs = [];
          update_objs.push(update_obj);
          const requestOptions = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': csrftoken,
            },
            body: JSON.stringify(update_objs)
          };
          fetch('/editorial/item-update-assertions', requestOptions)
          .then(async response => {
            const data = await response.json();
            // check for error response
            if (!response.ok) {
              // get error message from body or default to response status
              const error = (data && data.message) || response.status;
              return Promise.reject(error);
            }
            // Share the news we just did an edit
            this.input_value = null;
            this.$emit('assertion_update_done', true);
          })
          .catch(error => {
            this.errorMessage = error;
            console.error('There was an error!', error);
          });
        }
      },
      components: {
        'root-item-tree': vs_root_item_tree,
        'lookup-list': vs_look_up_list,
      },
    },
  );

  var vs_assert_objects = Vue.component(
    'assert-objects',
    {
      delimiters: ['[[', ']]'],
      props: ['assert_node', ],
      data() {
        return {
          assert: null,
        };
      },
      template: '#assert-objects',
      methods: {
        assertion_update_done(v){
          this.$emit('assertion_update_done', true);
        }
      }
    },
  );

  var vc_edit_observation = Vue.component(
    'edit-observation',
    {
      delimiters: ['[[', ']]'],
      props: ['act_obs', 'table_height'],
      data() {
        return {
          act_obs: null,
          table_height: '900px',
          modes: ['multi', 'single', 'range'],
          sortBy: 'sort',
          sortDesc: false,
          fields: [
            {
              key: 'predicate__label', 
              label:'Attribute or Relationship (Predicate)',
              class: 'pred_col',
              sortable: false
            },
            {
              key: 'objs', 
              label:'Attribute Values', 
              sortable: false
            },
          ],
          items: [],
          selectMode: 'range',
          selected: [],
          alert_update_uuids: [],
          alert_timer_duration: 2, // length of time the alerts stay up.
          alert_timer_state: 0,
        }
      },
      template: '#edit-observation',
      created() {
        
      },
      computed: {
        
      },
      methods: {
        add_alert_update_uuid(uuid) {
          const index = this.alert_update_uuids.indexOf(uuid);
          if (index > -1) {
            return null;
          }
          this.alert_update_uuids.push(uuid);
          this.alert_timer_state = this.alert_timer_duration;
        },
        add_alert_update_uuid_list(uuid_list){
          for (let uuid of uuid_list){
            this.add_alert_update_uuid(uuid);
          }
        },
        remove_alert_update_uuid(uuid) {
          const index = this.alert_update_uuids.indexOf(uuid);
          if (index > -1) {
            this.alert_update_uuids.splice(index, 1);
          }
          this.alert_timer_state = 0;
          // Remove all the uuids from the alerts all at once.
          this.alert_update_uuids = [];
        },
        clear_alert_update_uuids(){
          this.alert_update_uuids = [];
        },
        onRowSelected(items) {
          this.selected = items
        },
        selectAllRows() {
          this.$refs.dsFieldsGeneralTable.selectAllRows()
        },
        clearSelected() {
          this.$refs.dsFieldsGeneralTable.clearSelected()
        },
        assertion_update_done(v){
          this.$emit('assertion_update_done', true);
        }
      },
      components: {
        'assert-uuid': vs_assert_uuid,
        'assert-objects': vs_assert_objects,
      },
    }
  );

  var vc_edit_assertions = Vue.component(
    'edit-assertions',
    {
      delimiters: ['[[', ']]'],
      props: ['uuid', 'table_height'],
      data() {
        return {
          uuid: null,
          table_height: '900px',
          assertions_in_obs: [],
          non_pred_keys: [
            'id', 
            'label', 
            'type', 
            'oc_gen_has_events', 
            'oc_gen_has_attribute_groups'
          ],
          emit_edit_done:false,
        }
      },
      template: '#edit-assertions',
      created() {
        this.fetch_api_assertions();
      },
      computed: {
        
      },
      methods: {
        process_assertions(json) {
          let new_obs = [];
          for(let obs of json){
            let obs_assertions = [];
            let act_events = [];
            if('oc_gen_has_events' in obs){
              for(let event of obs.oc_gen_has_events){
                act_events.push(event);
              }
            }
            else{
              act_events.push(obs);
            }
            let act_attrib_group = [];
            for(let event of act_events){
              if('oc_gen_has_attribute_groups' in event){
                for(let a_group of event.oc-gen_has_attribute_groups){
                  act_attrib_group.push(a_group);
                }
              }
              else{
                act_attrib_group.push(event);
              }
            }
            for(let a_group of act_attrib_group){
              for (let key in a_group) {
                let key_index = this.non_pred_keys.indexOf(key);
                if(key_index >= 0){
                  continue;
                }
                if (a_group.hasOwnProperty(key)) {
                  let obs_assert_node = a_group[key][0];
                  obs_assert_node.objs = a_group[key];
                  obs_assertions.push(obs_assert_node);
                }
              }
            }
            let new_obs_item = {
              label: obs.label,
              assertions: obs_assertions,
            }
            new_obs.push(new_obs_item);
          }
          return new_obs;
        },
        fetch_api_assertions: function (){
          this.error = null;
          this.loading = true;
          fetch(
            ('/editorial/item-assertions/' + this.uuid),
              {
                headers:{
                    'Accept': 'application/json',
                }
              }
          )
          .then(this.loading = false)
          .then(response => response.json())
          .then(json => {
            this.assertions_in_obs = this.process_assertions(json);
            console.log(this.assertions_in_obs);
            if(this.emit_edit_done){
              this.emit_edit_done = false;
              this.$emit('edit_done', true);
            }
          })
        },
        assertion_update_done(v){
          this.emit_edit_done = true;
          this.fetch_api_assertions();
        }
      },
      components: {
        'root-item-tree': vs_root_item_tree,
        'lookup-list': vs_look_up_list,
        'edit-observation': vc_edit_observation,
      },
    }
  ); 
  
  </script>