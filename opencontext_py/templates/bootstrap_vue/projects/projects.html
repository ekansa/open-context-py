{% extends '../page.html' %}

{% block content %}


<script type="text/javascript">
    // Populated by Django.
    // const BASE_URL = '{{ BASE_URL|safe }}';
    let proj_items_api_url = abs_to_rel_url('{{ proj_items_api_url|safe }}', BASE_URL);
</script>

{% include '../color_gradients.html' %}
{% include '../common_geo.html' %}



<template id='proj-tab-field-proj-label'>
    <div>
        <b-img-lazy
            v-if="proj_item.media"
            fluid
            :src="proj_item.media"
            alt="Project banner"
            class="proj_item_banner"
        ></b-img-lazy>
        <div>
            <h4>[[ proj_item.label ]]</h4>
            <p>[[ proj_item.description ]]</p>
            <dl v-for="p_obj in proj_item.people">
                <dt><small>[[ p_obj.rel ]]</small></dt>
                <dd class="text-muted">
                    <small>
                    <a v-for="pers, i in p_obj.named_entities" :href="pers.href" target="_blank">[[ pers.label ]]<span v-if="i < (p_obj.named_entities.length -1)">, </span></a>
                    </small>
                </dd>
            </dl>
            </b-card-body>
        </div>
    </div>
</template>













<div id="main">

    <div class="container-fluid">
        <div id="app">
            <b-card
                title="Map of Project and Collection Publications"
            >

                <b-card-text>
                    <div class="main-map" id="home-map">
                    </div>
                </b-card-text>

            </b-card>

            <b-table
                v-if="items"
                :items="items"
                :fields="fields"
                striped
                bordered
                borderless
                stacked="md"
                responsive
                hover
                no-local-sorting
                sort-icon-left
            >
                <template #cell(descriptiveness)="data">
                    <h4 class="text-center"><b-badge pill variant="info">[[ percent_format(data.item.percentile)]] %</b-badge></h4>
                    <p class="text-center"><small>Scale, diversity, documentation</small></p>
                </template>

                <template #cell(label)="data">
                    <proj-tab-field-proj-label
                    v-bind:proj_item="data.item">
                    </proj-tab-field-proj-label>
                </template>

                <template #cell(published)="data">
                    <p class="text-center"><strong>[[ data.item.published ]] </strong></p>
                    <p class="text-center text-muted"><small>Last updated:<br/>[[ data.item.updated ]]</small></p>
                </template>

                <template #cell(metadata)="data">
                    <dl v-for="m_obj in data.item.metadata">
                        <dt><small>[[ m_obj.rel ]]</small></dt>
                        <dd class="text-muted">
                            <small>
                            <a v-for="meta, i in m_obj.named_entities" :href="meta.href" target="_blank">[[ meta.label ]]<span v-if="i < (m_obj.named_entities.length -1)">, </span></a>
                            </small>
                        </dd>
                    </dl>
                </template>

                <template #cell()="data">
                    [[ data.value ]]
                </template>

            </b-table>
        </div>
    </div>
</div>



<style type="text/css">
    .proj_item_banner {
        max-height: 290px;
	    overflow-y: hidden;
        background-color: #dee4f5;
        object-fit: cover;
        width: 100%;
    }
</style>


<script type="text/javascript">

    const USE_TEST_ALL_ITEMS_HREF = true;
    const START_API_URL = "{{ api_url|safe }}";
    const routes = [{path: START_API_URL}];
    const router = new VueRouter({
         mode: 'history',
         routes: routes
    });

    var vs_proj_field_proj_label = Vue.component(
        'proj-tab-field-proj-label',
        {
        delimiters: ['[[', ']]'],
        props: ['proj_item', ],
        data() {
            return {
                proj_item: null,
            };
        },
        template: '#proj-tab-field-proj-label',
        methods: {

        }
        },
    );

    var vm = new Vue({
        router: router,
        delimiters: ['[[', ']]'],
        el: '#app',
        data: {
            proj_items_geojson_url: "{{ proj_items_geojson_url|safe }}",
            proj_geojson: null,
            all_proj_items: null,
            filtered_projs: null,
            route_key_index: 0,
            loading: false,
            error: null,
            emit_update_fetch_done: false,
            fields: [
                { key: 'descriptiveness', sortable: true, label: 'Info Content', tdClass: 'align-middle'},
                { key: 'label', sortable: true, label: 'Project'},
                { key: 'metadata', sortable: false, tdClass: 'align-middle'},
                { key: 'published', sortable: true, tdClass: 'align-middle'},
            ],
            descriptiveness_scores:null,
        },
        created(){
            this.fetch_proj_items_geojson();
        },
        mounted(){

        },
        watch: {
            // call again the method if the route changes
            '$route': 'fetch_oc_api',
        },
        computed: {
            items: function(){
                let all_proj_items = this.prepare_all_proj_items();
                if(!all_proj_items){
                    return null;
                }
                return all_proj_items;
            },

        },
        methods: {
            iOS: function() {
                return [
                    'iPad Simulator',
                    'iPhone Simulator',
                    'iPod Simulator',
                    'iPad',
                    'iPhone',
                    'iPod'
                ].includes(navigator.platform)
                // iPad on iOS 13 detection
                || (navigator.userAgent.includes("Mac") && "ontouchend" in document)
            },
            percent_format: function(raw_val){
                return parseFloat(raw_val * 100).toFixed(0);
            },
            get_percentile_of_val: function(act_array, val) {
                if (act_array.length === 0) return null;
                if (typeof val !== 'number') return null;
                let act_num = 0;
                for (let i in act_array) {
                    act_num = (
                        act_num
                        + (act_array[i] < val ? 1 : 0)
                        + (act_array[i] === val ? 0.5 : 0)
                    );
                }
                return (act_num / act_array.length);
            },
            props_valid: function(act_obj, prop_list){
                if (!(act_obj.constructor == Object)) {
                    return false;
                }
                for(let prop of prop_list){
                    if(!act_obj.hasOwnProperty(prop)){
                        return false;
                    }
                }
                return true;
            },
            make_link_entity_objs: function(act_obj, act_vars){
                let links_objs = [];
                if (!(act_obj.constructor == Object)) {
                    return link_objs;
                }
                for(let act_var of act_vars){
                    if(!act_obj.hasOwnProperty(act_var.p)){
                        continue;
                    }
                    let act_var_uri = act_var.p + ' [URI]';
                    if(!act_obj.hasOwnProperty(act_var_uri)){
                        continue;
                    }
                    let act_link_objs = null;
                    for(let link_objs of links_objs){
                        if(link_objs.rel == act_var.l){
                            act_link_objs = link_objs;
                        }
                    }
                    if(!act_link_objs){
                        act_link_objs = {
                            rel: act_var.l,
                            named_entities: [],
                        }
                        links_objs.push(act_link_objs);
                    }
                    let i = -1;
                    for(let act_val_item of act_obj[act_var.p]){
                        i += 1;
                        let href = null;
                        if(i < act_obj[act_var_uri].length){
                            href = abs_to_rel_url(act_obj[act_var_uri][i], BASE_URL);
                            href  = use_all_items_href(href, BASE_URL, USE_TEST_ALL_ITEMS_HREF);
                        }
                        let named_entity_obj = {
                            label: act_val_item,
                            href: href,
                            rel: act_var.l,
                        }
                        act_link_objs.named_entities.push(named_entity_obj);
                    }
                }
                return links_objs;
            },
            get_valid_features: function(raw_features){
                let act_descriptiveness_scores = [];
                let valid_features = [];
                for(let feature of raw_features){
                    let ok = this.props_valid(
                        feature,
                        ['slug', 'properties', 'oc-api:descriptiveness', 'rdfs:isDefinedBy'],
                    )
                    if(!ok){
                        continue;
                    }
                    if(feature.slug == 'open-context'){
                        // slip open context.
                        continue;
                    }
                    act_descriptiveness_scores.push(
                        feature['oc-api:descriptiveness']
                    )
                    valid_features.push(feature);
                }
                if(this.descriptiveness_scores == null){
                    this.descriptiveness_scores = act_descriptiveness_scores.sort();
                }
                return valid_features;
            },
            prepare_all_proj_items: function(){
                // combine information from the proj_geojson
                // and the this.proj_items_raw.
                if(this.all_proj_items != null){
                    return this.all_proj_items;
                }
                if(!this.proj_geojson){
                    return null;
                }
                if(!this.proj_geojson.hasOwnProperty('features')){
                    return null;
                }
                let all_proj_items = [];
                for(let feature of this.get_valid_features(this.proj_geojson.features)){
                    let props = feature.properties;
                    let url = feature['rdfs:isDefinedBy'];
                    url = abs_to_rel_url(url, BASE_URL);
                    url = use_all_items_href(url, BASE_URL, USE_TEST_ALL_ITEMS_HREF);
                    let href = url;
                    if('href' in props){
                        href = use_all_items_href(props['href'], BASE_URL, USE_TEST_ALL_ITEMS_HREF);
                    }
                    let hero_uri = null;
                    if('hero_banner' in props){
                        hero_uri = props['hero_banner'];
                    }
                    let updated = props['updated'];
                    let updated_ex = updated.split('T');
                    let published = props['published'];
                    let published_ex = published.split('T');
                    let description = null;
                    if('description' in props){
                        description = props['description'];
                    }
                    let item = {
                        label: feature['label'],
                        url: url,
                        href: href,
                        updated: updated_ex[0],
                        published: published_ex[0],
                        media: hero_uri,
                        description: description,
                        descriptiveness: feature['oc-api:descriptiveness'],
                        percentile: this.get_percentile_of_val(
                            this.descriptiveness_scores,
                            feature['oc-api:descriptiveness'],
                        ),
                        people: this.make_link_entity_objs(
                            feature.properties,
                            [
                                {p:'Creator', l:'Named Director(s)',},
                                {p:'Contributor', l:'Named Contributor(s)',},
                            ],
                        ),
                        metadata: this.make_link_entity_objs(
                            feature.properties,
                            [
                                {p:'Subject', l:'Subject',},
                                {p:'Subject [dc-terms-subject]', l:'Subject',},
                                {p:'Coverage', l:'Coverage',},
                                {p:'Spatial Coverage', l:'Spatial Coverage',},
                                {p:'Temporal Coverage', l:'Temporal Coverage',},
                                {p:'References', l:'References',},
                                {p:'Is Referenced By', l:'Is Referenced By',},
                            ],
                        )
                    };
                    all_proj_items.push(item);
                }
                this.all_proj_items = all_proj_items;
                console.log('all_proj_items: ' + all_proj_items.length);
                console.log(this.all_proj_items);
                return this.all_proj_items;
            },
            add_project_map: function(){

            },
            fetch_proj_items_geojson: function (){
                if(this.proj_geojson != null){
                    return null;
                }
                this.error = null;
                this.loading = true;
                fetch(
                    this.proj_items_geojson_url,
                    {
                        headers: {
                            'Accept': 'application/json, application/geo+json, application/vnd.geo+json,',
                        },
                    }
                )
                .then(this.loading = true)
                .then(response => response.json())
                .then(json => {
                    this.proj_geojson = json;
                    console.log('Downloaded geojson for project items: ' + this.proj_geojson.features.length);
                    this.prepare_all_proj_items();
                });
            },
            get_filtered_projects(api_result){
                if(!api_result.hasOwnProperty('oc-api:has-facets')){
                    return null;
                }
                for (let f_field of result['oc-api:has-facets']){
                    if(!f_field.hasOwnProperty('type')){
                        continue;
                    }
                    if(!f_field.hasOwnProperty('oc-api:has-id-options')){
                        continue;
                    }
                    if(f_field.type != 'oc-api:facet-project'){
                        continue;
                    }
                    return f_field['oc-api:has-id-options'];
                }
                return [];
            },
            fetch_oc_api: function (){
                this.error = null;
                this.loading = true;
                fetch(
                    this.$route.fullPath,
                    {
                        headers:{
                            'Accept': 'application/json',
                        }
                    }
                )
                .then(this.loading = true)
                .then(response => response.json())
                .then(json => {
                    let api_result = json;
                    this.filtered_projs = this.get_filtered_projects(api_result);
                    this.route_key_index += 1;
                    this.loading = false;
                    if(this.emit_update_fetch_done){
                        this.emit_update_fetch_done = false;
                        this.$emit('update_fetch_done', true);
                    }
                });
            },
            emit_fetch_update(v){
                this.emit_update_fetch_done = true;
                this.fetch_oc_api();
            },
        },
        components: {
            'common_map': vc_common_map,
            'proj-field-proj-label': vs_proj_field_proj_label,
        },
    }).$mount('#app');
</script>




{% endblock %}