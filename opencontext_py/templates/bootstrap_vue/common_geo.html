{% block common_geo %}

{% load humanize %}

<template id="map_color_ui">
    <b-modal
        size="lg"
        scrollable
        ref="map-color-modal"
        id="map-color-modal"
        title="Change Map Visualization Colors"
        @shown="on_shown"
    >

        <b-row v-for="(color_choice, index) in color_choices"
        >
            <b-col cols="1">
                -
            </b-col>
            <b-col cols="10">
                <div :style="color_choice.style"></div>
            </b-col>
            <b-col cols="1">
                +
            </b-col>
        </b-row>
    </b-modal>
</template>
    


<template id='common_map'>
    <div>
        <l-map
            v-if="geo_json"
            @ready="ready_map_setup"
            :class="map_class"
            :style="'min-height: ' + min_height + 'px;'"
            :ref="'map-' + ref_suffix" 
            :zoom="11"
            :load-tiles-while-animating="true" 
            :load-tiles-while-interacting="true">
            <l-control-layers
                :ref="'map-l-controls-' + ref_suffix"
                position="topright"></l-control-layers>
            <l-tile-layer
                v-for="tp in tileProviders"
                :ref="'map-tile-' + ref_suffix + '-' + tp.name" 
                :key="tp.name"
                :name="tp.name"
                :visible="tp.visible"
                :url="tp.url"
                :attribution="tp.attribution"
                :maxZoom="tp.maxZoom"
                :maxNativeZoom="tp.maxNativeZoom"
                layer-type="base"></l-tile-layer>
            <l-img-overlay
                v-if="geo_overlays"
                v-for="ov in geo_overlays"
                :key="ov.id"
                :alt="ov.id"
                :ref="'map-image-overlay-' + ov.id + '-' + ref_suffix"
                :name="ov.label"
                :visible="ov.visible"
                :url="ov.url"
                :attribution="ov.attribution"
                :bounds="ov.bounds"
                layer-type="overlay"
            ></l-img-overlay>
            <l-geo-json
                v-if="show_default_overlay"
                :key="'map-geojson-' + ref_suffix + '-' + map_key"
                :ref="'map-geojson-' + ref_suffix"
                :options="options"
                v-bind:geojson="geo_json"
            >
            <l-popup></l-popup>
            </l-geo-json>
        </l-map>
        <div v-else class="text-center mb-3 d-flex justify-content-between">
            <b-spinner
                :variant="primary"
                style="width: 3rem; height: 3rem;" label="Large Spinner"></b-spinner>
        </div>
        <div v-if="location_precision_note">
            <b-alert v-if="location_precision_factor" show variant="warning">
              <small>[[location_precision_note]]</small>
            </b-alert>
            <b-alert v-else show variant="info">
              <small>[[location_precision_note]]</small>
            </b-alert>
        </div>
        <map-color-ui 
            v-if="map_type == 'search'"
            v-bind:frontend_state_obj="frontend_state_obj"
        ></map-color-ui>
    </div>
</template>


<script type="text/javascript">
  // Import Vue2Leaflet components. 
  const l_popup = Vue.component('l-popup', window.Vue2Leaflet.LPopup);
  const l_tile_layer = Vue.component(
    'l-tile-layer', 
    window.Vue2Leaflet.LTileLayer,
  );
  const l_img_overlay = Vue.component(
    'l-img-overlay', 
    window.Vue2Leaflet.LImageOverlay,
  );
  const l_geo_json = Vue.component(
    'l-geo-json', 
    window.Vue2Leaflet.LGeoJson,
  );
  const l_control_layers = Vue.component(
    'l-control-layers', 
    window.Vue2Leaflet.LControlLayers,
  );
  const l_marker = Vue.component(
    'l-marker', 
    window.Vue2Leaflet.LMarker,
  );
  const l_map = Vue.component(
    'l-map', 
    window.Vue2Leaflet.LMap,
  );

  const MAX_ZOOM_TILES = 24;
  const MAX_ZOOM = 30;
  
  const GOOGLE_API_KEY = 'AIzaSyAuhr3tCQOxbGxnOki11vuvDB86-sxjHwo';
  const MAPBOX_PUBLIC_ACCESS_TOKEN = '{{ MAPBOX_PUBLIC_ACCESS_TOKEN|escapejs }}';
  
  const GOOGLE_TILE_CONFIGS = [
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Road",
      type: "roadmap",
      id: 'google-road',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Aerial",
      type: "satellite",
      id: 'google-aerial',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Terrain",
      type: "terrain",
      id: 'google-terrain',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Hybrid",
      type: "hybrid",
      id: 'google-hybrid',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
  ];


  const TILE_PROVIDERS = [
    {
      name: 'MapBox Satellite',
      visible: true,
      id: 'mapbox-satellite',
      url: (
        'https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token='
        + MAPBOX_PUBLIC_ACCESS_TOKEN
      ),
      attribution: 'Map data: © <a target="_blank" href="https://MapBox.com">MapBox.com</a>',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: MAX_ZOOM_TILES,
    },
    {
      name: 'OpenStreetMap',
      visible: false,
      id: 'osm',
      url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      attribution: '© <a target="_blank" href="http://osm.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: 18,
    },
    {
      name: 'OpenTopoMap',
      visible: false,
      id: 'otm',
      url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
      attribution: 'Map data: © <a target="_blank" href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: © <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
      maxZoom: 16,
      maxNativeZoom: 16,
    },
    {
      name: 'MapBox Light',
      visible: false,
      id: 'mapbox-light',
      url: (
        'https://api.mapbox.com/styles/v1/mapbox/light-v10/tiles/{z}/{x}/{y}?access_token=' 
        + MAPBOX_PUBLIC_ACCESS_TOKEN
      ),
      attribution: 'Map data: © <a target="_blank" href="https://MapBox.com">MapBox.com</a>',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: MAX_ZOOM_TILES,
    },
    {
      name: 'MapBox Dark',
      visible: false,
      id: 'mapbox-dark',
      url: (
        'https://api.mapbox.com/styles/v1/mapbox/dark-v10/tiles/{z}/{x}/{y}?access_token='
        + MAPBOX_PUBLIC_ACCESS_TOKEN
      ),
      attribution: 'Map data: © <a href="https://MapBox.com">MapBox.com</a>',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: MAX_ZOOM_TILES,
    },
  ];


// URL updating for Map view state.
(function(window) {
    var HAS_HASHCHANGE = (function() {
        var doc_mode = window.documentMode;
        return ('onhashchange' in window) &&
            (doc_mode === undefined || doc_mode > 7);
    })();
    
    L.Hash = function(map) {
        this.tile_zoom = false;
        this.onHashChange = L.Util.bind(this.onHashChange, this);
    
        if (map) {
            this.init(map);
        }
    };
    
    L.Hash.prototype = {
        map: null,
        lastHash: null,
        frontend_state_obj: null,
        update_map_frontend_state_obj: null,
        update_base_layer: null,
    
        contains: function(a, obj) {
            var i = a.length;
            while (i--) {
               if (a[i] === obj) {
                   return true;
               }
            }
            return false;
        },

        prep_geo_from_state_obj: function(frag_obj){
            frag_obj.center = null;
            frag_obj.zoom = null;
            if(frag_obj.hasOwnProperty('zm') && frag_obj.hasOwnProperty('lat') && frag_obj.hasOwnProperty('lng')){
                let zoom = parseInt(frag_obj.zm, 10);
                let lat = parseFloat(frag_obj.lat);
                let lng = parseFloat(frag_obj.lng);
                if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) {
                    frag_obj.center = null;
                }
                else{
                    frag_obj.center = new L.LatLng(lat, lng);
                    frag_obj.zoom = zoom;
                }
            }
            if(frag_obj.hasOwnProperty('bm') && frag_obj.bm != null){
                this.update_base_layer(frag_obj.bm.replace('_', ' '));
            }
            return frag_obj;
        },

        parseHash: function(hash) {
            let frag_obj = parse_search_frag_dict(hash);
            return this.prep_geo_from_state_obj(frag_obj);
        },
    
        compose_new_frontend_state: function(map){
            let frag_obj = this.frontend_state_obj;
            // console.log('composing new map frontend state');
            // console.log(frag_obj);
            let center = this.map.getCenter();
            let zoom = this.map.getZoom();
            let precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));

            frag_obj.zm = zoom;
            frag_obj.lat = center.lat.toFixed(precision);
            frag_obj.lng = center.lng.toFixed(precision);
            if(Math.round(frag_obj.lat, 1) == 0 && Math.round(frag_obj.lng) == 0){
                console.log('Bad coodinates do not update');
                delete frag_obj.zm;
                delete frag_obj.lat;
                delete frag_obj.lng;
            }
            if(this.map.baselayer_name){
                frag_obj.bm = this.map.baselayer_name.replace(' ' , '_');
            }
            if(this.map.hasOwnProperty('visible_overlay_ids')){
                if(this.map.visible_overlay_ids.length > 0){
                    frag_obj.ov = this.map.visible_overlay_ids;
                }
            }
            return frag_obj;
        },

        formatHash: function(frag_obj) {
            let frag_str = encode_frag_obj(frag_obj);
            return '#' + frag_str;
        },
    
        init: function(map) {
            this.map = map;
            this.map.on("moveend", this.onMapMove, this);
            // reset the hash
            this.lastHash = null;
            this.onHashChange();
            if (!this.isListening) {
                this.startListening();
            }
        },
    
        remove: function() {
            this.map = null;
            if (this.isListening) {
                this.stopListening();
            }
        },

        update_new_fontend_state: function(frag_obj){
            // Updates the frontend state for all vue components.
            if(frag_obj.hasOwnProperty('center')){
                delete frag_obj.center;
            }
            if(frag_obj.hasOwnProperty('zoom')){
                delete frag_obj.zoom;
            }
            let hash = this.formatHash(frag_obj);
            if (this.lastHash != hash) {
                this.update_map_frontend_state_obj(frag_obj);
                this.lastHash = hash;
                return true;
            }
            return false;
        },
        
        forceHashChange: function(map) {
            // change the hash, in response to changes
            // in base layers
            if(this.map.auto_fit){
                return false;
            }
            let frag_obj = this.compose_new_frontend_state(map);
            this.update_new_fontend_state(frag_obj);
        },
        
        onMapMove: function(map) {
            // bail if we're moving the map (updating from a hash),
            // or if the map has no zoom set
            
            if (this.movingMap || this.map.getZoom() === 0) {
                return false;
            }
            if(this.map.auto_fit){
                return false;
            }
            let frag_obj = this.compose_new_frontend_state(map);
            this.update_new_fontend_state(frag_obj);
        },
    
        movingMap: false,
        update: function() {
            let parsed = this.prep_geo_from_state_obj(this.frontend_state_obj);
            if (parsed != null && parsed.center != null) {
                // console.log("parsed:", parsed.zoom, parsed.center.toString());
                this.movingMap = true;
                this.map.setView(parsed.center, parsed.zoom);  
                this.movingMap = false;
            } else {
                // console.warn("parse error; resetting:", this.map.getCenter(), this.map.getZoom());
                this.onMapMove(this.map);
            }
        },
    
        // defer hash change updates every 100ms
        changeDefer: 100,
        changeTimeout: null,
        onHashChange: function() {
            // throttle calls to update() so that they only happen every
            // `changeDefer` ms
            if (!this.changeTimeout) {
                var that = this;
                this.changeTimeout = setTimeout(function() {
                    that.update();
                    that.changeTimeout = null;
                }, this.changeDefer);
            }
        },
    
        isListening: false,
        hashChangeInterval: null,
        startListening: function() {
            if (HAS_HASHCHANGE) {
                L.DomEvent.addListener(window, "hashchange", this.onHashChange);
            } else {
                clearInterval(this.hashChangeInterval);
                this.hashChangeInterval = setInterval(this.onHashChange, 50);
            }
            this.isListening = true;
        },
    
        stopListening: function() {
            if (HAS_HASHCHANGE) {
                L.DomEvent.removeListener(window, "hashchange", this.onHashChange);
            } else {
                clearInterval(this.hashChangeInterval);
            }
            this.isListening = false;
        }
    };
})(window);


var vc_map_color_ui = Vue.component(
    'map-color-ui',
    {
        delimiters: ['[[', ']]'],
        props: ['frontend_state_obj',],
        data() {
            return {
                frontend_state_obj: {},
            };
        },
        template: '#map_color_ui',
        computed: {
            color_choices(){
                let color_choices = [];
                for(let key in COLOR_GRADIENTS){
                    if(!COLOR_GRADIENTS.hasOwnProperty(key)){
                        continue;
                    }
                    let color_configs = COLOR_GRADIENTS[key];
                    let l_gradient_parts = ['to right'];
                    for(let conf of color_configs){
                        let rgb = convertToRGB(conf.color);
                        let grad_part = `rgba(${rgb.join(', ')},1)`;
                        l_gradient_parts.push(grad_part);
                    }
                    let color_choice = {
                        id: key,
                        style: (`min-height: 44px;
                                 margin-top: 12px;
                                 background-image: linear-gradient(${l_gradient_parts.join(', ')});`),
                    }
                    color_choices.push(color_choice);
                }
                return color_choices;
            },
        },
        methods: {
            on_shown(){
                console.log('Color map colors');
            },
        },
        components: {
            
        }
    }
);

var vc_common_map = Vue.component(
  'common_map', 
  {
    props: [
        'map_key',
        'ref_suffix',
        'geo_json_url',
        'geo_json',
        'geo_overlays',
        'item_json',
        'map_type',
        'map_class',
        'min_height',
        'route_key_index',
        'frontend_state_obj',
        'show_default_overlay',
    ],
    data() {
        return {
            // Map Options
            map: null,
            map_key: 0,
            zoom_def: 13,
            base_layers: {},
            selectedTileSet: TILE_PROVIDERS[0], 
            tileProviders: TILE_PROVIDERS,
            google_tile_configs: GOOGLE_TILE_CONFIGS,
            added_google_tiles: false,
            added_google_tile_types: [],
            minZoom_def: 1,
            maxZoom_def: MAX_ZOOM,
            show_mapsets_default: true,
            center: null,
            geo_json_url: null,
            geo_json: null,
            geo_overlays: null,
            location_precision_factor: null,
            location_precision_note: null,
            item_json: null,
            map_type: 'generic',
            map_class: 'item',
            min_height: 300,
            route_key_index: 0,
            frontend_state_obj: {},
            map_hash_obj: null,
            baselayer_name: null,
            default_zoom: 11,
            map_type_default_zooms: {
                item: 16,
                generic: 12,
            },
            default_tilelayer_name: 'Google Aerial',
            geo_tile_facets: null,
            geo_region_facets: null,
            geo_page_records: null,
            geo_all_records: null,
            heatmap_data: null,
            geo_tile_facets_default: {
                type: "FeatureCollection",
                label: "Summary as squares",
                ov_id: 'sqr',
                ref: "map-tile-geojson-" + this.ref_suffix,
                min_count: null,
                max_count: null,
                features: [],
            },
            geo_facets_circles_default: {
                type: "FeatureCollection",
                label: "Summary as circles",
                ov_id: 'crc',
                ref: "map-circle-geojson-" + this.ref_suffix,
                min_count: null,
                max_count: null,
                features: [],
            },
            geo_region_facets_default: {
                type: "FeatureCollection",
                label: "Context summary",
                ov_id: 'cntx',
                ref: "map-region-geojson-" + this.ref_suffix,
                min_count: null,
                max_count: null,
                features: [],
            },
            geo_page_records_default: {
                type: "FeatureCollection",
                label: "Records (current page)",
                ov_id: 'pg-recs',
                ref: "map-page-recs-geojson-" + this.ref_suffix,
                features: [],
            },
            geo_all_records_default: {
                type: "FeatureCollection",
                label: "Records (all selected)",
                ov_id: 'all-recs',
                ref: "map-all-recs-geojson-" + this.ref_suffix,
                features: [],
            },
            heatmap_data_default: {
                label: "Summary as heatmap",
                ov_id: 'heat',
                ref: "map-heatmap-" + this.ref_suffix,
                max: null,
                data: [],
            },
            heatmap_config: {
                "radius": 40,
                "useLocalExtrema": false,
                latField: 'lat',
                lngField: 'lng',
                valueField: 'count',
            },
            show_default_overlay: true,
            default_gradient_key: 'legacy_oc',
        };
    },
    template: '#common_map',
    delimiters: ['[[', ']]'],
    created() {
        this.fetch_geojson();
    },
    mounted() {
        this.fetch_geojson();
    },
    updated(){
        this.update_map_setup();
    },
    computed: {
        map_ref(){return 'map-' + this.ref_suffix},
        l_controls_ref(){return 'map-l-controls-' + this.ref_suffix},
        geojson_ref(){return 'map-geojson-' + this.ref_suffix},
        options() {
            return {
                onEachFeature: this.onEachFeatureFunction
            };
        },
        onEachFeatureFunction() {
            return (feature, layer) => {
                let popup_content = this.make_feature_popup(feature);
                let tooltip_content = this.make_feature_tooltip(feature);
                layer.bindPopup(popup_content);
                layer.bindTooltip(
                    tooltip_content, 
                    { permanent: false, sticky: true }
                );
            };
        },
    },
    methods: {
        add_links(str){
            if (!(typeof str === 'string' || str instanceof String)){
                return str;
            }
            if(str.startsWith("https://")||str.startsWith("http://")){
                return `<a target="_blank" href="${str}">${str}</a>`;
            }
            return str;
        },
        update_router: function(url){
            let hash = '';
            if(window.location.hash) {
                hash = '#' + window.location.hash.substring(1); //Puts hash in variable, and removes the # character
            }
            if(url.indexOf(hash) < 0){
                url += hash;
            }
            url = abs_to_rel_url(url, BASE_URL);
            router.push(url);
        },
        update_geodeep: function(geodeep){
            if(!this.geo_json){
                return null;
            }
            let current_url = this.geo_json.id;
            let url = replaceURLparameter(current_url, 'geodeep', geodeep);
            this.update_router(url);
        },
        get_centroid: function(arr) {
            // get the centroid of a polygon
            if(arr[0] == arr[1]){
                arr.pop();
            }
            return arr.reduce(function (x,y) {
                return [x[0] + y[0]/arr.length, x[1] + y[1]/arr.length] 
            }, [0,0]);
        },
        update_map_frontend_state_obj(frontend_state_obj) {
            this.$emit('set_frontend_state_obj', frontend_state_obj);
        },
        update_base_layer(baselayer_name){
            if(!this.map){
                return null;
            }
            if(!(baselayer_name in this.base_layers)){
                console.log('Cannot find baselayer: ' + baselayer_name);
                return null;
            }
            //
            for(let name_key in this.base_layers){
                let act_layer = this.base_layers[name_key];
                if(name_key == baselayer_name){
                    this.map.addLayer(act_layer);
                }
                else{
                    this.map.removeLayer(act_layer);
                }
            }
            let new_tile_state_list = [];
            for(tp of this.tileProviders){
                tp.visible = false;
                if(tp.name == baselayer_name){
                    tp.visible = true;
                    this.selectedTileSet = tp;
                }
                new_tile_state_list.push(tp);
            }
            this.tileProviders = new_tile_state_list;
            this.map.baselayer_name = baselayer_name;
        },
        toggle_map_color_ui: function(){
            console.log('color control toggle');
            this.$bvModal.show('map-color-modal');
        },
        add_search_map_extra_controls: function() {
            if(this.map_type != 'search'){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(this.map.hasOwnProperty('search_map_extra_buttons')){
                return null;
            }
            if(!this.map.hasOwnProperty('geodeep')){
                this.map.geodeep = 11;
            }
            if(!this.map.hasOwnProperty('max_tile_zoom')){
                this.map.max_tile_zoom = MAX_ZOOM_TILES;
            }
            this.map.update_geodeep = this.update_geodeep;
            this.map.toggle_map_color_ui = this.toggle_map_color_ui;
            this.map.deactivate_all_overlays_except = function(map, active_ov_id){
                if(!map.hasOwnProperty('overlay_layers_by_id')){
                    console.log('missing overlay_layers_by_id');
                    console.log(map);
                    return null;
                }
                for(let ov_id in map.overlay_layers_by_id){
                    if(!map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                        continue;
                    }
                    let act_layer = map.overlay_layers_by_id[ov_id];
                    if(active_ov_id == ov_id){
                        map.addLayer(act_layer);
                    }else{
                        act_layer.removeFrom(map);
                    }
                }
            },
            this.map.add_search_map_extra_controls = function(map){
                let search_map_extra_controls = [];
                let deep_tile_control = L.easyButton(
                    '<span class="material-icons-two-tone">grid_on</span>',
                    // the control for higher resolution region tiles
                    function (){
                        map.deactivate_all_overlays_except(map, 'sqr');
                        let new_geodeep = parseInt(map.geodeep) + 1;
                        if (new_geodeep <= map.max_tile_zoom) {
                            //can still zoom in
                            console.log('New higher tile zoom: ' + new_geodeep);
                            map.geodeep = new_geodeep;
                            map.update_geodeep(new_geodeep);
                        }
                    },
                    'Higher resolution summary regions',
                );
                let big_tile_control = L.easyButton(
                    '<span class="material-icons-two-tone">window</span>',
                    // control for lower resolution region tiles
                    function (){
                        map.deactivate_all_overlays_except(map, 'sqr');
                        let new_geodeep = map.geodeep - 1;
                        if (new_geodeep > 3) {
                            console.log('New lower tile zoom: ' + new_geodeep);
                            map.geodeep = new_geodeep;
                            map.update_geodeep(new_geodeep);
                        }
                    },
                    'Lower resolution summary regions',
                );
                let circle_control = L.easyButton(
                    '<span class="material-icons">circle</span>', 
                    function (){
                        map.deactivate_all_overlays_except(map, 'crc');
                    },
                    'Circle-markers for summary regions',
                );
                let heat_control = L.easyButton(
                    '<span class="material-icons">thermostat</span>', 
                    function (){
                        map.deactivate_all_overlays_except(map, 'heat');
                    },
                    'Heat-map visualization',
                );
                let color_control = L.easyButton(
                    '<span class="material-icons-two-tone">palette</span>', 
                    function (){
                        map.toggle_map_color_ui();
                    },
                    'Map visualization colors',
                );
                map.search_map_extra_buttons = {
                    deep_tile_control: deep_tile_control,
                    big_tile_control: big_tile_control,
                    circle_control: circle_control,
                    heat_control: heat_control,
                    color_control: color_control,
                };
                search_map_extra_controls.push(deep_tile_control);
                search_map_extra_controls.push(big_tile_control);
                search_map_extra_controls.push(circle_control);
                search_map_extra_controls.push(heat_control);
                search_map_extra_controls.push(color_control);
                L.easyBar(search_map_extra_controls).addTo(map);
            }
            this.map.add_search_map_extra_controls(this.map);
            console.log(this.map.search_map_extra_buttons);
            console.log('added search controls');
        },
        geo_view_from_state_obj: function(raw_frag_obj){
            if(!raw_frag_obj){
                return null;
            }
            let frag_obj = JSON.parse(JSON.stringify(raw_frag_obj));
            frag_obj.center = null;
            frag_obj.zoom = null;
            if(frag_obj.hasOwnProperty('zm') && frag_obj.hasOwnProperty('lat') && frag_obj.hasOwnProperty('lng')){
                let zoom = parseInt(frag_obj.zm, 10);
                let lat = parseFloat(frag_obj.lat);
                let lng = parseFloat(frag_obj.lng);
                if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) {
                    frag_obj.center = null;
                }
                else{
                    frag_obj.center = new L.LatLng(lat, lng);
                    frag_obj.zoom = zoom;
                }
            }
            return frag_obj;
        },
        set_map_view_from_frontend_state_obj: function () {
            if(this.map_type != 'search'){
                return null;
            }
            if(!this.map){
                return null;
            }
            let frag_obj = this.geo_view_from_state_obj(this.frontend_state_obj);
            if (this.map_type == 'search' && frag_obj != null && frag_obj.center != null) {
                console.log('Update map view from frontend state');
                this.map.auto_fit = false;
                this.map.setView(frag_obj.center, frag_obj.zoom);
                return true;  
            }
            return false;
        },
        add_search_map_hash: function() {
            if(this.map_type != 'search'){
                return null;
            }
            if(!this.map){
                return null;
            }
            this.map.visible_overlay_ids = [];
            this.set_map_view_from_frontend_state_obj();
            this.map_hash_obj = new L.Hash(this.map);
            this.map_hash_obj.frontend_state_obj = this.frontend_state_obj;
            this.map_hash_obj.update_map_frontend_state_obj = this.update_map_frontend_state_obj;
            this.map_hash_obj.update_base_layer = this.update_base_layer;
            this.map.hash_obj = this.map_hash_obj;
            this.map.on('baselayerchange', function(e) {
                // when the base layer changes, keep the id
                this.baselayer_name = e.name;
                if(this.hash_obj){
                    this.hash_obj.forceHashChange();
                }
            });
            this.map.overlay_ready = false;
            this.map.on('overlayadd', function(e) {
                // Adding an overlay layer, note what layers are active
                if(!this.overlay_ready){
                    return null;
                }
                if(!e.hasOwnProperty('layer') || !e.layer.hasOwnProperty('ov_id')){
                    console.log('Image overlay, no state recording');
                    return null;
                }
                
                if(this.visible_overlay_ids.indexOf(e.layer.ov_id) < 0){
                    this.visible_overlay_ids.push(e.layer.ov_id);
                }
                else{
                    // Nothing changed so skip out.
                    return null;
                }
                if(this.hash_obj){
                    this.hash_obj.forceHashChange();
                }
            });
            this.map.on('overlayremove', function(e) {
                if(!this.overlay_ready){
                    return null;
                }
                /// Remove an overlay layer, note what layers are active
                if(!e.hasOwnProperty('layer') || !e.layer.hasOwnProperty('ov_id')){
                    console.log('Image overlay, no state recording');
                    return null;
                }
                let new_overlay_ids = [];
                for(let i =0; i < this.visible_overlay_ids.length; i++){
                    if(this.visible_overlay_ids[i] !== e.layer.ov_id){
                        new_overlay_ids.push(this.visible_overlay_ids[i]);
                    }
                }
                if(this.visible_overlay_ids.length <= new_overlay_ids.length){
                    // Nothing changed, so skip out.
                    return null;
                }
                this.visible_overlay_ids = new_overlay_ids;
                if(this.hash_obj){
                    this.hash_obj.forceHashChange();
                }
            });
        },
        make_geo_features_layer(category_limit, geo_layer=null){
            if(!geo_layer){
                let geo_layer = {
                    type: "FeatureCollection",
                    features: [],
                };
            }
            geo_layer.category = category_limit;
            if(!this.geo_json){
                return geo_layer;
            }
            let counts = [];
            for(let feature of this.geo_json.features){
                if(feature.category != category_limit){
                    continue;
                }
                geo_layer.features.push(feature);
                if(feature.hasOwnProperty('count')){
                    counts.push(feature.count);
                }
            }
            if(counts.length > 0){
                // Add information needed to style features.
                geo_layer.min_count = Math.min.apply(Math, counts);
                geo_layer.max_count = Math.max.apply(Math, counts);
                let count_features = [];
                for(let feature of geo_layer.features){
                    feature.max_count = geo_layer.max_count;
                    feature.gradient_key = this.default_gradient_key;
                    count_features.push(feature);
                }
                geo_layer.features = count_features;
            }
            return geo_layer;
        },
        make_generic_feature_popup(feature){
            if(!feature.hasOwnProperty('properties')){
                return '';
            }
            if(feature.properties.length < 1){
                return '';
            }
            var prop_content = [];
            for (var prop in feature.properties) {
                let prop_str = this.add_links(feature.properties[prop]);
                prop_content.push(
                    `<dl class="row">
                    <dt class="col">${prop}</dt>
                    <dd class="col">${prop_str}</dd>
                    </dl>
                    `
                );
            }
            var all_props = prop_content.join('\n');
            var popup_content = (
                `<div class="container geo_feature_popup">${all_props}</div>`
            );
            return popup_content;
        },
        make_item_feature_popup(feature){
            if(!this.item_json){
                return '';
            }
            return (
                `<dl class="row">
                <dt class="col">Item</dt>
                <dd class="col">${this.item_json.label}</dd>
                </dl>`
            );
        },
        make_feature_popup(feature){
            if(this.map_type == 'generic' || !this.item_json){
                return this.make_generic_feature_popup(feature);
            }
            return this.make_item_feature_popup(feature);
        },
        make_generic_feature_tooltip(feature){
            if(!feature.hasOwnProperty('properties')){
                return '';
            }
            if(feature.properties.length < 1){
                return '';
            }
            let act_prop_val = null;
            for (var prop in feature.properties) {
                act_prop_val = {k: prop, v:feature.properties[prop]};
                break;
            }
            if(!act_prop_val){
                return '';
            }
            return `<div>${act_prop_val.k}: ${act_prop_val.v}</div>`;
        },
        make_item_feature_tooltip(feature){
            if(!this.item_json){
                return '';
            }
            return ("<div>" + item_json.label + "</div>");
        },
        make_feature_tooltip(feature){
            if(this.map_type == 'generic' || !this.item_json){
                return this.make_generic_feature_tooltip(feature);
            }
            return this.make_item_feature_tooltip(feature);
        },
        gather_base_layers: function(){
            if(!this.map){
                return null;
            }
            for(tp of this.tileProviders){
                let tile_key = 'map-tile-' + this.ref_suffix + '-' + tp.name;
                if(this.$refs[tile_key] == null){
                    console.log('no basemap with key: ' + tile_key);
                    continue;
                }
                this.base_layers[tp.name] = this.$refs[tile_key][0].mapObject;
            }
        },
        add_google_tiles: function() {
            if(this.added_google_tiles){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(this.$refs[this.l_controls_ref] == null){
                console.log('no item: ' + this.l_controls_ref);
                return null;
            }
            if(this.$refs[this.map_ref] == null){
                console.log('no item: ' + this.map_ref);
                return null;
            }
            console.log(this.map);
            for(let gtile_config of this.google_tile_configs){
                if(this.added_google_tile_types.indexOf(gtile_config.type) >= 0){
                    // Don't add the same layer twice!
                    continue;
                }
                let gtile = L.gridLayer.googleMutant(gtile_config);
                this.base_layers[gtile.options.name] = gtile;
                if(gtile_config.type == 'satellite'){
                    // Add support for over-zooming satellite.
                    this.map.addLayer(gtile);
                }
                this.$refs[this.l_controls_ref].mapObject.addBaseLayer(
                    gtile, gtile.options.name
                );
                this.added_google_tile_types.push(gtile_config.type);
            }
            this.added_google_tiles = true;
        },
        count_style: function(feature){
            let act_gradient = COLOR_GRADIENTS.legacy_oc;
            if(feature.gradient_key in COLOR_GRADIENTS){
                act_gradient = COLOR_GRADIENTS[feature.gradient_key];
            }
            let hex_color = make_hex_color_in_gradient(
                (feature.count / feature.max_count), 
                act_gradient
            );
            let fill_opacity = (
                ((feature.count / feature.max_count) * 0.5 ) + 0.20
            );
            return {
                color: hex_color,
                fillOpacity: fill_opacity,
                weight: 2
            };
        },
        circle_pointToLayer: function(feature,  latlng){
            let marker_opts = this.count_style(feature);
            let radius = Math.round(30 * (feature.count / feature.max_count), 0) + 5;
            marker_opts.radius = radius;
            marker_opts.fillColor = marker_opts.color;
            marker_opts.weight = 1;
            marker_opts.opacity = 0.95;
            marker_opts.fillOpacity = 0.8;
            return L.circleMarker(latlng, marker_opts);
        },
        get_map_geodeep_from_geojson: function(act_geojson){
            if(act_geojson.category != 'oc-api:geo-facet'){
                return null;
            }
            if(!this.map){
                return null;
            }
            let feature = act_geojson.features[0];
            let geo_id_ex = feature.geometry.id.split('-');
			let geo_tile = geo_id_ex[geo_id_ex.length - 1];
            this.map.geodeep = geo_tile.length;
        },
        geojson_to_circle_data: function(act_geojson){
            if(act_geojson.category != 'oc-api:geo-facet'){
                return null;
            }
            if(!act_geojson.hasOwnProperty('max_count')){
                return null;
            }
            let circle_geojson = JSON.parse(JSON.stringify(this.geo_facets_circles_default));
            circle_geojson.min_count = act_geojson.min_count;
            circle_geojson.max_count = act_geojson.max_count;
            circle_geojson.category = act_geojson.category;
            /*
			 * 1st we aggregate nearby tiles getting points for the center of each
			 * tile region
			 */
            let aggregated_tiles = {};
            for(let feature of act_geojson.features){
                let centroid = this.get_centroid(feature.geometry.coordinates[0]);
                let geo_id_ex = feature.geometry.id.split('-');
				let geo_tile = geo_id_ex[geo_id_ex.length - 1];
                let agg_tile_id = geo_tile.substring(0, (geo_tile.length -1));
                if(!(agg_tile_id in aggregated_tiles)) {
                    aggregated_tiles[agg_tile_id] = [];
                }
                let point_item = {
                    centroid: centroid,
                    count: feature.count,
                    id: replaceURLparameter(feature.id, 'allevent-geotile', agg_tile_id),
                }
                aggregated_tiles[agg_tile_id].push(point_item);
            }
            /*
			 * 2nd we compute the weighted average for nearby tile center points
			 * based on their counts. This will help make the map look less like a grid
			 */
            let max_count = 0;
            let tindex = 0;
            let count_keyed_points = {};
            let count_keys = [];
            for(let agg_tile_id in aggregated_tiles){
                tindex += .000001;
                let total_count = 0;
                let sum_lat = 0;
                let sum_lng = 0;
                for(let point_item of aggregated_tiles[agg_tile_id]){
                    total_count += point_item.count;
                    sum_lat += point_item.centroid[1] * point_item.count;
                    sum_lng += point_item.centroid[0] * point_item.count;
                }
                if(max_count < total_count){
                    max_count = total_count;
                }
                let mean_lat = sum_lat / total_count;
                let mean_lng = sum_lng / total_count;
                let point_feature = {
                    'type': 'Feature',
                    'id': aggregated_tiles[agg_tile_id][0].id,
                    'count': total_count,
                    'max_count': null,
                    'geometry': {
                        'type': 'Point',
                        'coordinates': [mean_lng, mean_lat],
                    },
                };
                count_key = total_count + tindex;
                count_keys.push(count_key);
                count_keyed_points[count_key] = point_feature;
            }
            /*
			 * 3rd we sort the points in descending order of count so the point features with
			 * the highest counts will be rendered lower
			 */
			count_keys.sort(function(a, b){return b-a;});
            for(let count_key of count_keys){
                let feature = count_keyed_points[count_key];
                feature.max_count = max_count;
                circle_geojson.features.push(feature);
            }
            return circle_geojson;
        },
        geojson_to_heatmap_data: function(act_geojson){
            if(act_geojson.category != 'oc-api:geo-facet'){
                return null;
            }
            if(!act_geojson.hasOwnProperty('max_count')){
                return null;
            }
            let heatmap_data = JSON.parse(JSON.stringify(this.heatmap_data_default));
            heatmap_data.max = act_geojson.max_count;
            for(let feature of act_geojson.features){
                let centroid = this.get_centroid(feature.geometry.coordinates[0]);
                let data_item = {
                    // convert geojson order to lat/lng
                    lat: centroid[1],
                    lng: centroid[0],
                    count: feature.count,
                }
                heatmap_data.data.push(data_item);
            }
            return heatmap_data;
        },
        add_overlay_layers: function() {
            if(!this.geo_json){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(this.$refs[this.l_controls_ref] == null){
                console.log('no item: ' + this.l_controls_ref);
                return null;
            }

            // prevent mutation of the result.
            this.geo_tile_facets = this.make_geo_features_layer(
                'oc-api:geo-facet', 
                JSON.parse(JSON.stringify(this.geo_tile_facets_default))
            );
            this.geo_region_facets = this.make_geo_features_layer(
                'oc-api:geo-contained-in-feature', 
                JSON.parse(JSON.stringify(this.geo_region_facets_default))
            );
            this.geo_page_records = this.make_geo_features_layer(
                'oc-api:geo-record', 
                JSON.parse(JSON.stringify(this.geo_page_records_default))
            );

            // Removes prior geojson overlay layers from prior routing.
            if(this.map.hasOwnProperty('overlay_layers_by_id')){
                for(let ov_id in this.map.overlay_layers_by_id){
                    if(!this.map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                        continue;
                    }
                    let act_layer = this.map.overlay_layers_by_id[ov_id];
                    act_layer.removeFrom(this.map);
                    this.$refs[this.l_controls_ref].mapObject.removeLayer(
                        act_layer, 
                    );
                }
            }
            this.map.overlay_layers_by_id = null;

            // Gather all the types of 'raw' geojson used to build overlay layers.
            let overlays_geojson = [];
            if(this.geo_tile_facets && this.geo_tile_facets.features.length > 0){
                overlays_geojson.push(this.geo_tile_facets);
            }
            if(this.geo_region_facets && this.geo_region_facets.features.length > 0){
                overlays_geojson.push(this.geo_region_facets);
            }
            if(this.geo_page_records && this.geo_page_records.features.length > 0){
                overlays_geojson.push(this.geo_page_records);
            }
            if(this.geo_all_records && this.geo_all_records.features.length > 0){
                overlays_geojson.push(this.geo_all_records);
            }
            if(overlays_geojson.length < 1){
                return null;
            }

            this.map.overlay_layers_by_id = {};
            let i = -1;
            for(let act_geojson of overlays_geojson){
                let act_layer = null;
                if(act_geojson.hasOwnProperty('max_count')){
                    act_layer = L.geoJson(
                        act_geojson,
                        {
                            style: this.count_style,
                            onEachFeature: this.onEachFeatureFunction,
                        },
                    );
                }
                else{
                    act_layer = L.geoJson(
                        act_geojson,
                        {
                            onEachFeature: this.onEachFeatureFunction,
                        },
                    );
                }
                i += 1;
                act_layer.ref = act_geojson.ref;
                act_layer.label = act_geojson.label;
                if(act_geojson.hasOwnProperty('ov_id')){
                    act_layer.ov_id = act_geojson.ov_id;
                }
                else{
                    act_layer.ov_id = 'overlay-' + i;
                }
                // Now add it again fresh.
                act_layer.addTo(this.map, act_geojson.label);
                this.$refs[this.l_controls_ref].mapObject.addOverlay(
                    act_layer, 
                    act_geojson.label
                );
                act_layer.bringToFront();
                // Add to the object of all overlays keyed by their ID.
                this.map.overlay_layers_by_id[act_layer.ov_id] = act_layer;

                let l_geo_json = this.$refs[this.geojson_ref];
                if(l_geo_json){
                    this.map.removeLayer(l_geo_json);
                }

                if(!this.frontend_state_obj.hasOwnProperty('ov') && act_layer.ov_id == 'sqr'){
                    // we don't have a frontend obj determined overlay, and we don't have any
                    // currently visible overlays, so make this active layer visible.
                    this.map.addLayer(act_layer);
                    this.map.visible_overlay_ids.push(act_layer.ov_id);
                }
                else{
                    this.map.removeLayer(act_layer);
                }

                // Add headmap if relevant.
                let heatmap_data = this.geojson_to_heatmap_data(act_geojson);
                let circle_geojson = this.geojson_to_circle_data(act_geojson);
                if(heatmap_data == null || circle_geojson == null){
                    continue;
                }
                
                // Extract the current geodeep property. This is needed to give a starting
                // value for increasing or decreasing the tile resolution controls.
                this.get_map_geodeep_from_geojson(act_geojson);

                // Make and add a circle layer
                let circle_layer = L.geoJson(
                    circle_geojson,
                    {
                        pointToLayer: this.circle_pointToLayer,
                        onEachFeature: this.onEachFeatureFunction,
                    },
                );
                circle_layer.ref = circle_geojson.ref;
                circle_layer.label = circle_geojson.label;
                circle_layer.ov_id = circle_geojson.ov_id;
                circle_layer.addTo(this.map, circle_layer.label);
                this.$refs[this.l_controls_ref].mapObject.addOverlay(
                    circle_layer, 
                    circle_layer.label
                );
                circle_layer.bringToFront();
                this.map.removeLayer(circle_layer);
                this.map.overlay_layers_by_id[circle_layer.ov_id] = circle_layer;

                //Make and add the heatmap layer
                let heatmap_layer = new HeatmapOverlay(this.heatmap_config);
                heatmap_layer.ref = heatmap_data.ref;
                heatmap_layer.label = heatmap_data.label;
                heatmap_layer.ov_id = heatmap_data.ov_id;
                heatmap_layer.setData(heatmap_data);
                heatmap_layer.addTo(this.map, heatmap_layer.label);
                this.$refs[this.l_controls_ref].mapObject.addOverlay(
                    heatmap_layer, 
                    heatmap_layer.label
                );
                heatmap_layer.zIndex = 100;
                this.map.removeLayer(heatmap_layer);
                this.map.overlay_layers_by_id[heatmap_layer.ov_id] = heatmap_layer;
            }
        },
        finese_item_view: function(){
            if(!this.map){
                return null;
            }
            if (this.map_type == 'search'){
                return null;
            }
            if(!('features' in this.geo_json)){
                return null;
            }
            if(this.geo_json.features.length > 1){
                return null;
            }
            if(this.geo_json.features[0].geometry.type != 'Point'){
                console.log('Use extent derived zoom for ' + this.geo_json.features[0].geometry.type);
                return null;
            }
            let zoom = this.default_zoom;
            if(this.map_type in this.map_type_default_zooms){
                zoom = this.map_type_default_zooms[this.map_type];
            }
            let center = this.map.getCenter();
            this.map.setView(center, zoom);
        },
        fit_bounds: function(){
            if(!this.geo_json && GEO_JSON != null){
                this.geo_json = GEO_JSON;
            }
            if(!this.map){
                return null;
            }
            let frag_obj_set_view = this.set_map_view_from_frontend_state_obj();
            if (frag_obj_set_view){
                console.log('Fontend state object set map bounds.');
                return null;
            }
            console.log('Use overlay layer to fit bounds.');
            let act_overlay_layer = null;
            if(this.map.hasOwnProperty('overlay_layers_by_id')){
                if (this.map.overlay_layers_by_id && this.map.overlay_layers_by_id.hasOwnProperty('sqr')){
                    act_overlay_layer = this.map.overlay_layers_by_id.sqr;
                }
            }
            if(act_overlay_layer == null){
                act_overlay_layer = this.$refs[this.geojson_ref];
                if(act_overlay_layer == null){
                    console.log('no geo-json layer item: ' + this.geojson_ref);
                    return null;
                }
            }
            if(act_overlay_layer == null){
                console.log('no overlay layer for fitbounds');
                return null;
            }
            this.map.auto_fit = true;
            let bounds = act_overlay_layer.getBounds();
            this.map.fitBounds(bounds);
            console.log(bounds);
            this.map.auto_fit = false;
        },
        frontend_obj_overlays_prep: function(){
            if(this.map_type != 'search'){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(!this.map.hasOwnProperty('overlay_layers_by_id')){
                // No overlay layers by ID added to the map.
                return null;
            }
                
            if(!this.frontend_state_obj.hasOwnProperty('ov')){
                // No overlays passed from frontend state object.
                return null;
            }
            if(typeof this.frontend_state_obj.ov === 'string'){
                // No overlays passed from frontend state object.
                this.frontend_state_obj.ov = [this.frontend_state_obj.ov];
            }

            for(let ov_id in this.map.overlay_layers_by_id){
                if(!this.map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                    continue;
                }
                let act_layer = this.map.overlay_layers_by_id[ov_id];
                if(this.frontend_state_obj.ov.indexOf(act_layer.ov_id) >=0){
                    console.log('activate ' + act_layer.ov_id);
                    this.map.addLayer(act_layer);
                }
                else{
                    console.log('deactivate ' + act_layer.ov_id);
                    this.map.removeLayer(act_layer);
                }
            }
        },
        ready_map_setup: function(){
            this.map = this.$refs[this.map_ref].mapObject;
            this.map._layersMaxZoom = MAX_ZOOM;
            this.map.auto_fit = true;
            this.gather_base_layers();
            this.add_google_tiles();
            this.get_item_location_info();
            this.add_search_map_hash();
            this.add_overlay_layers();
            this.add_search_map_extra_controls();
            this.frontend_obj_overlays_prep();
            this.fit_bounds();
            this.finese_item_view();
            this.map.auto_fit = false;
            this.map.overlay_ready = true;
        },
        map_size_reset: function(){
            if(!this.geo_json && GEO_JSON != null){
                this.geo_json = GEO_JSON;
            }
            setTimeout(() => {
                // wait a bit so the geojson layer is available.
                this.$refs[this.map_ref].mapObject.invalidateSize();
            }, 50);
        },
        get_item_location_info: function() {
            if(!this.geo_json || !this.item_json){
                return null;
            }
            for(let feat of this.geo_json.features){
                if(!feat.hasOwnProperty('properties')){
                    continue;
                }
                if(!feat.properties.hasOwnProperty('href')){
                    continue;
                }
                if(feat.properties.href != this.item_json.id){
                    continue;
                }
                if(feat.properties.hasOwnProperty('location_precision_factor')){
                    this.location_precision_factor = feat.properties.location_precision_factor;
                }
                if(feat.properties.hasOwnProperty('location_precision_note')){
                    this.location_precision_note = feat.properties.location_precision_note;
                }
            }
        },
        update_map_setup: function(){
            this.map.overlay_ready = false;
            if(this.map_type == 'search' && this.map_hash_obj){
                this.map_hash_obj.frontend_state_obj = this.frontend_state_obj;
                this.map.hash_obj = this.map_hash_obj;
            }
            this.add_overlay_layers();
            this.map_size_reset();
            this.frontend_obj_overlays_prep();
            this.fit_bounds();
            this.finese_item_view();
            this.get_item_location_info();
            // console.log('updated map');
            // console.log('current frontend state');
            // console.log(this.frontend_state_obj);
            this.map.overlay_ready = true;
        },
        fetch_geojson: function() {
            if(!this.geo_json_url){
                return null;
            }
            if(this.geo_json){
                return null;
            }
            console.log('fetch geojson from: ' + this.geo_json_url);
            const requestOptions = {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json, application/geo+json, application/vnd.geo+json,',
                    },
                };
            fetch(
                (this.geo_json_url), 
                requestOptions,
            )
            .then(this.loading = false)
            .then(response => response.json())
            .then(json => {
                this.geo_json = json;
                console.log('fetched geojson');
            });
        },
    },
    components: {
      'l-popup': l_popup,
      'l-img-overlay' : l_img_overlay,
      'l-tile-layer': l_tile_layer,
      'l-geo-json': l_geo_json,
      'l-marker': l_marker,
      'l-map': l_map,
      'map-color-ui': vc_map_color_ui,
    },
});




/* TODO: https://www.patrick-wied.at/static/heatmapjs/example-heatmap-leaflet.html */









</script>



{% endblock %}