{% block common_geo %}

{% load humanize %}

<template id="map_color_ui">
    <b-modal
        size="lg"
        scrollable
        class="color-ui-modal"
        ref="map-color-modal"
        id="map-color-modal"
        title="Change Map Visualization Colors"
        @shown="on_shown"
    >
        <p><small>Select a color gradient option to use in map data visualizations. Different
            color options may be more effective than others depending on your selection of
            basemap layers, underlying patterns in the data, your sensitivity to
            various colors, and aesthetic preferences.
        </small></p>

        <color-gradient-ui
            v-bind:selected_gradient_key="selected_gradient_key"
            @set_selected_gradient_key="set_selected_gradient_key"
        >
        </color-gradient-ui>

        <template #modal-footer="{ ok, cancel, hide }">
            <b-button size="sm" variant="outline-secondary" @click="hide('map-color-modal')">
              Cancel
            </b-button>
          </template>
    </b-modal>
</template>
    


<template id="map_legends">
    <b-card v-if="legends" 
        border-variant="secondary"
        header-border-variant="secondary"
        header="Map Data Visualization Legend"
        id="map-datavis-legend"
    >
        <b-list-group flush>
            <b-list-group-item v-for="(legend, index) in legends" class="map-overlay-legend-item">

                <b-row align-v="center">
                    <b-col cols="3">
                        <small>
                            <b-avatar
                            v-if="legend.icon" 
                            :aria-label="'Icon for ' + legend.label" 
                            rounded="sm"
                            variant="light"
                            v-html="legend.icon">
                        </b-avatar>
                            <strong>[[ legend.label ]]</strong>
                        </small>
                    </b-col>
                    <b-col>
                        <div v-if="legend.poly_list">
                            <b-row align-h="center" align-v="center">
                                <b-col v-for="(sqr, c_index) in legend.poly_list" class="text-center">
                                    <svg width="25" height="25">
                                        <rect x="0" y="0" width="25" height="25" :style="sqr.svg_style" />
                                    </svg>
                                </b-col>
                            </b-row>
                            <b-row align-h="center" align-v="top">
                                <b-col v-for="(sqr, c_index) in legend.poly_list" class="text-center">
                                    <small>[[ sqr.count ]]</small>
                                </b-col>
                            </b-row>
                        </div>

                        <div v-if="legend.circle_list">
                            <b-row align-h="center" align-v="center">
                                <b-col v-for="(crc, c_index) in legend.circle_list" class="text-center">
                                    <svg :height="(crc.radius * 2) + 4" :width="(crc.radius * 2) + 4">
                                        <circle :cx="crc.radius + 2" :cy="crc.radius + 2" :r="crc.radius" :style="crc.svg_style" />
                                    </svg>
                                </b-col>
                            </b-row>
                            <b-row align-h="center" align-v="top">
                                <b-col v-for="(crc, c_index) in legend.circle_list" class="text-center">
                                    <small>[[ crc.count ]]</small>
                                </b-col>
                            </b-row>
                        </div>

                        <div v-if="legend.heat_style">
                            <b-row align-h="center">
                                <b-col>
                                    <div :style="legend.heat_style"></div>
                                </b-col>
                            </b-row>
                            <b-row align-h="center">
                                <b-col class="text-left">
                                    <small>[[ legend.min_count ]]</small>
                                </b-col>
                                <b-col class="text-right">
                                    <small>[[ legend.max_count ]]</small>
                                </b-col>
                            </b-row>
                        </div>
                        
                    </b-col>
                </b-row>
                <b-row v-if="legend.circle_list">
                    <b-col>
                        <small><em>
                            Circle markers aggregate counts from up to 4 adjacent regions,
                            so the maximum value of a circle marker may differ from other visualization layers.
                        </em>
                        </small>
                    </b-col>
                </b-row>

            </b-list-group-item>
        </b-list-group>
    </b-card>
</template>



<template id='common_map'>
    <div>
        <l-map
            v-if="geo_json"
            @ready="ready_map_setup"
            :class="map_class"
            :style="'min-height: ' + min_height + 'px;'"
            :ref="'map-' + ref_suffix" 
            :zoom="11"
            :load-tiles-while-animating="true" 
            :load-tiles-while-interacting="true">
            <l-control-layers
                :ref="'map-l-controls-' + ref_suffix"
                position="topright"></l-control-layers>
            <l-tile-layer
                v-for="tp in tileProviders"
                :ref="'map-tile-' + ref_suffix + '-' + tp.name" 
                :key="tp.name"
                :name="tp.name"
                :visible="tp.visible"
                :url="tp.url"
                :attribution="tp.attribution"
                :maxZoom="tp.maxZoom"
                :maxNativeZoom="tp.maxNativeZoom"
                layer-type="base"></l-tile-layer>
            <l-img-overlay
                v-if="geo_overlays"
                v-for="ov in geo_overlays"
                :key="ov.id"
                :alt="ov.id"
                :ref="'map-image-overlay-' + ov.id + '-' + ref_suffix"
                :name="ov.label"
                :visible="ov.visible"
                :url="ov.url"
                :attribution="ov.attribution"
                :bounds="ov.bounds"
                layer-type="overlay"
            ></l-img-overlay>
            <l-geo-json
                v-if="show_default_overlay"
                :key="'map-geojson-' + ref_suffix + '-' + map_key"
                :ref="'map-geojson-' + ref_suffix"
                :options="options"
                v-bind:geojson="geo_json"
            >
            <l-popup></l-popup>
            </l-geo-json>
        </l-map>
        <div v-else class="text-center mb-3 d-flex justify-content-between">
            <b-spinner
                variant="primary"
                style="width: 3rem; height: 3rem;" label="Large Spinner"></b-spinner>
        </div>
        <div v-if="location_precision_note">
            <b-alert v-if="location_precision_factor" show variant="warning">
              <small>[[location_precision_note]]</small>
            </b-alert>
            <b-alert v-else show variant="info">
              <small>[[location_precision_note]]</small>
            </b-alert>
        </div>
        <div v-if="map_type == 'search'">
            <map-color-ui 
                v-bind:selected_gradient_key="selected_gradient_key"
                @set_selected_gradient_key="set_selected_gradient_key"
            ></map-color-ui>
            <map-legends v-bind:legends="map_legends"></map-legends>
        </div>
    </div>
</template>


<script type="text/javascript">
  // Import Vue2Leaflet components.
  const MAP_DEFAULT_COLOR_GRADIENT_KEY = 'oc';
  const SEARCH_MAP_DEFAULT_OVERLAY_KEY = 'sqr';
  const l_popup = Vue.component('l-popup', window.Vue2Leaflet.LPopup);
  const l_tile_layer = Vue.component(
    'l-tile-layer', 
    window.Vue2Leaflet.LTileLayer,
  );
  const l_img_overlay = Vue.component(
    'l-img-overlay', 
    window.Vue2Leaflet.LImageOverlay,
  );
  const l_geo_json = Vue.component(
    'l-geo-json', 
    window.Vue2Leaflet.LGeoJson,
  );
  const l_control_layers = Vue.component(
    'l-control-layers', 
    window.Vue2Leaflet.LControlLayers,
  );
  const l_marker = Vue.component(
    'l-marker', 
    window.Vue2Leaflet.LMarker,
  );
  const l_map = Vue.component(
    'l-map', 
    window.Vue2Leaflet.LMap,
  );

  const MAX_ZOOM_TILES = 24;
  const MAX_ZOOM = 30;
  
  const GOOGLE_API_KEY = 'AIzaSyAuhr3tCQOxbGxnOki11vuvDB86-sxjHwo';
  const MAPBOX_PUBLIC_ACCESS_TOKEN = '{{ MAPBOX_PUBLIC_ACCESS_TOKEN|escapejs }}';
  
  const GOOGLE_TILE_CONFIGS = [
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Road",
      type: "roadmap",
      id: 'google-road',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Aerial",
      type: "satellite",
      id: 'google-aerial',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Terrain",
      type: "terrain",
      id: 'google-terrain',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Hybrid",
      type: "hybrid",
      id: 'google-hybrid',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
  ];


  const TILE_PROVIDERS = [
    {
      name: 'MapBox Satellite',
      visible: true,
      id: 'mapbox-satellite',
      url: (
        'https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token='
        + MAPBOX_PUBLIC_ACCESS_TOKEN
      ),
      attribution: 'Map data: © <a target="_blank" href="https://MapBox.com">MapBox.com</a>',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: MAX_ZOOM_TILES,
    },
    {
      name: 'OpenStreetMap',
      visible: false,
      id: 'osm',
      url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      attribution: '© <a target="_blank" href="http://osm.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: 18,
    },
    {
      name: 'OpenTopoMap',
      visible: false,
      id: 'otm',
      url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
      attribution: 'Map data: © <a target="_blank" href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: © <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
      maxZoom: 16,
      maxNativeZoom: 16,
    },
    {
      name: 'MapBox Light',
      visible: false,
      id: 'mapbox-light',
      url: (
        'https://api.mapbox.com/styles/v1/mapbox/light-v10/tiles/{z}/{x}/{y}?access_token=' 
        + MAPBOX_PUBLIC_ACCESS_TOKEN
      ),
      attribution: 'Map data: © <a target="_blank" href="https://MapBox.com">MapBox.com</a>',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: MAX_ZOOM_TILES,
    },
    {
      name: 'MapBox Dark',
      visible: false,
      id: 'mapbox-dark',
      url: (
        'https://api.mapbox.com/styles/v1/mapbox/dark-v10/tiles/{z}/{x}/{y}?access_token='
        + MAPBOX_PUBLIC_ACCESS_TOKEN
      ),
      attribution: 'Map data: © <a href="https://MapBox.com">MapBox.com</a>',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: MAX_ZOOM_TILES,
    },
  ];


// URL updating for Map view state.
(function(window) {
    var HAS_HASHCHANGE = (function() {
        var doc_mode = window.documentMode;
        return ('onhashchange' in window) &&
            (doc_mode === undefined || doc_mode > 7);
    })();
    
    L.Hash = function(map) {
        this.tile_zoom = false;
        this.onHashChange = L.Util.bind(this.onHashChange, this);
    
        if (map) {
            this.init(map);
        }
    };
    
    L.Hash.prototype = {
        map: null,
        lastHash: null,
        frontend_state_obj: null,
        update_map_frontend_state_obj: null,
        update_base_layer: null,
    
        contains: function(a, obj) {
            var i = a.length;
            while (i--) {
               if (a[i] === obj) {
                   return true;
               }
            }
            return false;
        },

        prep_geo_from_state_obj: function(frag_obj){
            frag_obj.center = null;
            frag_obj.zoom = null;
            if(frag_obj.hasOwnProperty('zm') && frag_obj.hasOwnProperty('lat') && frag_obj.hasOwnProperty('lng')){
                let zoom = parseInt(frag_obj.zm, 10);
                let lat = parseFloat(frag_obj.lat);
                let lng = parseFloat(frag_obj.lng);
                if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) {
                    frag_obj.center = null;
                }
                else{
                    frag_obj.center = new L.LatLng(lat, lng);
                    frag_obj.zoom = zoom;
                }
            }
            if(frag_obj.hasOwnProperty('bm') && frag_obj.bm != null){
                this.update_base_layer(frag_obj.bm.replace('_', ' '));
            }
            return frag_obj;
        },

        parseHash: function(hash) {
            let frag_obj = parse_search_frag_dict(hash);
            return this.prep_geo_from_state_obj(frag_obj);
        },
    
        compose_new_frontend_state: function(map){
            let frag_obj = this.frontend_state_obj;
            // console.log('composing new map frontend state');
            // console.log(frag_obj);
            let center = this.map.getCenter();
            let zoom = this.map.getZoom();
            let precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));

            frag_obj.zm = zoom;
            frag_obj.lat = center.lat.toFixed(precision);
            frag_obj.lng = center.lng.toFixed(precision);
            if(Math.round(frag_obj.lat, 1) == 0 && Math.round(frag_obj.lng, 1) == 0){
                console.log('Bad coodinates do not update');
                delete frag_obj.zm;
                delete frag_obj.lat;
                delete frag_obj.lng;
            }
            if(this.map.baselayer_name){
                frag_obj.bm = this.map.baselayer_name.replace(' ' , '_');
            }
            if(this.map.hasOwnProperty('visible_overlay_ids')){
                if(this.map.visible_overlay_ids.length > 0){
                    frag_obj.ov = this.map.visible_overlay_ids;
                }
            }
            return frag_obj;
        },

        formatHash: function(frag_obj) {
            let frag_str = encode_frag_obj(frag_obj);
            return '#' + frag_str;
        },
    
        init: function(map) {
            this.map = map;
            this.map.on("moveend", this.onMapMove, this);
            // reset the hash
            this.lastHash = null;
            this.onHashChange();
            if (!this.isListening) {
                this.startListening();
            }
        },
    
        remove: function() {
            this.map = null;
            if (this.isListening) {
                this.stopListening();
            }
        },

        update_new_fontend_state: function(frag_obj){
            // Updates the frontend state for all vue components.
            if(frag_obj.hasOwnProperty('center')){
                delete frag_obj.center;
            }
            if(frag_obj.hasOwnProperty('zoom')){
                delete frag_obj.zoom;
            }
            let hash = this.formatHash(frag_obj);
            if (this.lastHash != hash) {
                this.update_map_frontend_state_obj(frag_obj);
                this.lastHash = hash;
                return true;
            }
            return false;
        },
        
        forceHashChange: function(map) {
            // change the hash, in response to changes
            // in base layers
            if(this.map.auto_fit){
                return false;
            }
            let frag_obj = this.compose_new_frontend_state(map);
            this.update_new_fontend_state(frag_obj);
        },
        
        onMapMove: function(map) {
            // bail if we're moving the map (updating from a hash),
            // or if the map has no zoom set
            
            if (this.movingMap || this.map.getZoom() === 0) {
                return false;
            }
            if(this.map.auto_fit){
                return false;
            }
            let frag_obj = this.compose_new_frontend_state(map);
            this.update_new_fontend_state(frag_obj);
        },
    
        movingMap: false,
        update: function() {
            let parsed = this.prep_geo_from_state_obj(this.frontend_state_obj);
            if (parsed != null && parsed.center != null) {
                // console.log("parsed:", parsed.zoom, parsed.center.toString());
                this.movingMap = true;
                this.map.setView(parsed.center, parsed.zoom);  
                this.movingMap = false;
            } else {
                // console.warn("parse error; resetting:", this.map.getCenter(), this.map.getZoom());
                this.onMapMove(this.map);
            }
        },
    
        // defer hash change updates every 100ms
        changeDefer: 100,
        changeTimeout: null,
        onHashChange: function() {
            // throttle calls to update() so that they only happen every
            // `changeDefer` ms
            if (!this.changeTimeout) {
                var that = this;
                this.changeTimeout = setTimeout(function() {
                    that.update();
                    that.changeTimeout = null;
                }, this.changeDefer);
            }
        },
    
        isListening: false,
        hashChangeInterval: null,
        startListening: function() {
            if (HAS_HASHCHANGE) {
                L.DomEvent.addListener(window, "hashchange", this.onHashChange);
            } else {
                clearInterval(this.hashChangeInterval);
                this.hashChangeInterval = setInterval(this.onHashChange, 50);
            }
            this.isListening = true;
        },
    
        stopListening: function() {
            if (HAS_HASHCHANGE) {
                L.DomEvent.removeListener(window, "hashchange", this.onHashChange);
            } else {
                clearInterval(this.hashChangeInterval);
            }
            this.isListening = false;
        }
    };
})(window);


var vc_map_color_ui = Vue.component(
    'map-color-ui',
    {
        delimiters: ['[[', ']]'],
        props: ['selected_gradient_key', ],
        data() {
            return {
                selected_gradient_key: MAP_DEFAULT_COLOR_GRADIENT_KEY,
            };
        },
        template: '#map_color_ui',
        methods: {
            on_shown(){
                console.log('Show map color ui');
            },
            set_selected_gradient_key(gradient_key){
                this.selected_gradient_key = gradient_key;
                this.$emit('set_selected_gradient_key', this.selected_gradient_key);
            },
        },
        components: {
            'color-gradient-ui': vc_color_gradient_ui,
        }
    }
);


var vc_map_legends = Vue.component(
    'map-legends',
    {
        delimiters: ['[[', ']]'],
        props: ['legends', ],
        data() {
            return {
                legends: null,
            };
        },
        template: '#map_legends',
        methods: {
            
        },
        components: {
            
        }
    }
);


var vc_common_map = Vue.component(
  'common_map', 
  {
    props: [
        'map_key',
        'ref_suffix',
        'geo_json_url',
        'geo_json',
        'geo_overlays',
        'item_json',
        'map_type',
        'map_class',
        'min_height',
        'route_key_index',
        'frontend_state_obj',
        'show_default_overlay',
        'geojson_record_layers',
    ],
    data() {
        return {
            // Map Options
            map: null,
            map_key: 0,
            zoom_def: 13,
            base_layers: {},
            selectedTileSet: TILE_PROVIDERS[0], 
            tileProviders: TILE_PROVIDERS,
            google_tile_configs: GOOGLE_TILE_CONFIGS,
            added_google_tiles: false,
            added_google_tile_types: [],
            minZoom_def: 1,
            maxZoom_def: MAX_ZOOM,
            show_mapsets_default: true,
            center: null,
            geo_json_url: null,
            geo_json: null,
            geo_overlays: null,
            location_precision_factor: null,
            location_precision_note: null,
            item_json: null,
            map_type: 'generic',
            map_class: 'item',
            min_height: 300,
            route_key_index: 0,
            frontend_state_obj: {},
            map_hash_obj: null,
            baselayer_name: null,
            default_zoom: 11,
            map_type_default_zooms: {
                item: 16,
                generic: 12,
            },
            geojson_record_layers: null,
            default_tilelayer_name: 'Google Aerial',
            geo_tile_facets: null,
            geo_region_facets: null,
            geo_page_records: null,
            geo_all_records: null,
            heatmap_data: null,
            overlay_icons: {
                sqr: '<span class="material-icons-two-tone">grid_on</span>',
                sqr_hr: '<span class="material-icons-two-tone">grid_on</span>',
                sqr_lr: '<span class="material-icons-two-tone">window</span>',
                crc: '<span class="material-icons">circle</span>',
                heat: '<span class="material-icons">thermostat</span>',
            },
            geo_tile_facets_default: {
                type: "FeatureCollection",
                label: "Summary as squares",
                ov_id: 'sqr',
                ref: "map-tile-geojson-" + this.ref_suffix,
                min_count: null,
                max_count: null,
                legend: null,
                features: [],
            },
            geo_facets_circles_default: {
                type: "FeatureCollection",
                label: "Summary as circles",
                ov_id: 'crc',
                ref: "map-circle-geojson-" + this.ref_suffix,
                min_count: null,
                max_count: null,
                legend: null,
                features: [],
            },
            geo_region_facets_default: {
                type: "FeatureCollection",
                label: "Context summary",
                ov_id: 'cntx',
                ref: "map-region-geojson-" + this.ref_suffix,
                min_count: null,
                max_count: null,
                legend: null,
                features: [],
            },
            geo_page_records_default: {
                type: "FeatureCollection",
                label: "Records (current page)",
                ov_id: 'pg-recs',
                ref: "map-page-recs-geojson-" + this.ref_suffix,
                legend: null,
                features: [],
            },
            geo_all_records_default: {
                type: "FeatureCollection",
                label: "Records (all selected)",
                ov_id: 'all-recs',
                ref: "map-all-recs-geojson-" + this.ref_suffix,
                legend: null,
                features: [],
            },
            heatmap_data_default: {
                label: "Summary as heatmap",
                ov_id: 'heat',
                ref: "map-heatmap-" + this.ref_suffix,
                max: null,
                legend: null,
                data: [],
            },
            heatmap_config: {
                "radius": 40,
                "useLocalExtrema": false,
                latField: 'lat',
                lngField: 'lng',
                valueField: 'count',
            },
            show_default_overlay: true,
            selected_gradient_key: MAP_DEFAULT_COLOR_GRADIENT_KEY,
            legend_config: {
                poly_list: null,
                circle_list: null,
                heat_style: null,
            },
            route_map_legends: {},
            map_legends: null,
        };
    },
    template: '#common_map',
    delimiters: ['[[', ']]'],
    created(){
        this.fetch_geojson();
    },
    mounted(){
        this.fetch_geojson();
    },
    updated(){
        this.update_map_setup();
    },
    computed: {
        map_ref(){return 'map-' + this.ref_suffix},
        l_controls_ref(){return 'map-l-controls-' + this.ref_suffix},
        geojson_ref(){return 'map-geojson-' + this.ref_suffix},
        options() {
            return {
                onEachFeature: this.onEachFeatureFunction
            };
        },
        onEachFeatureFunction() {
            return (feature, layer) => {
                let popup_content = this.make_feature_popup(feature);
                let tooltip_content = this.make_feature_tooltip(feature);
                layer.bindPopup(popup_content);
                layer.bindTooltip(
                    tooltip_content, 
                    { permanent: false, sticky: true }
                );
            };
        },
    },
    methods: {
        // Utility functions for search map interface
        util_search_map_ok: function(){
            if(this.map_type != 'search'){
                return false;
            }
            if(!this.map){
                return false;
            }
            return true;
        },
        util_search_map_ok_with_props: function(prop_list){
            if(!this.util_search_map_ok()){
                return false;
            }
            for(let prop of prop_list){
                if(!this.map.hasOwnProperty(prop)){
                    return false;
                }
            }
            return true;
        },
        round_value(val, min_increment){
            let n_val = parseFloat(val);
            let rounded = n_val + min_increment/2 - (n_val + min_increment/2) % min_increment;
            return rounded;
        },
        add_links(str){
            if (!(typeof str === 'string' || str instanceof String)){
                return str;
            }
            if(str.startsWith("https://")||str.startsWith("http://")){
                return `<a target="_blank" href="${str}">${str}</a>`;
            }
            return str;
        },
        update_router: function(url){
            let hash = '';
            if(window.location.hash) {
                hash = '#' + window.location.hash.substring(1); //Puts hash in variable, and removes the # character
            }
            if(url.indexOf(hash) < 0){
                url += hash;
            }
            url = abs_to_rel_url(url, BASE_URL);
            router.push(url);
        },
        update_geodeep: function(geodeep){
            if(!this.geo_json){
                return null;
            }
            let current_url = this.geo_json.id;
            let url = replaceURLparameter(current_url, 'geodeep', geodeep);
            this.update_router(url);
        },
        get_centroid: function(arr) {
            // get the centroid of a polygon
            if(arr[0] == arr[1]){
                arr.pop();
            }
            return arr.reduce(function (x,y) {
                return [x[0] + y[0]/arr.length, x[1] + y[1]/arr.length] 
            }, [0,0]);
        },
        update_map_frontend_state_obj(frontend_state_obj) {
            if(frontend_state_obj.hasOwnProperty('ov')){
                if(isArray(frontend_state_obj.ov)){
                    frontend_state_obj.ov = [...new Set(frontend_state_obj.ov)];
                }
            }
            this.frontend_state_obj = frontend_state_obj;
            this.$emit('set_frontend_state_obj', frontend_state_obj);
            this.delayed_update_map_legends();
        },
        update_base_layer(baselayer_name){
            if(!this.map){
                return null;
            }
            if(!(baselayer_name in this.base_layers)){
                console.log('Cannot find baselayer: ' + baselayer_name);
                return null;
            }
            for(let name_key in this.base_layers){
                let act_layer = this.base_layers[name_key];
                if(name_key == baselayer_name){
                    this.map.addLayer(act_layer);
                }
                else{
                    this.map.removeLayer(act_layer);
                }
            }
            let new_tile_state_list = [];
            for(tp of this.tileProviders){
                tp.visible = false;
                if(tp.name == baselayer_name){
                    tp.visible = true;
                    this.selectedTileSet = tp;
                }
                new_tile_state_list.push(tp);
            }
            this.tileProviders = new_tile_state_list;
            this.map.baselayer_name = baselayer_name;
        },
        show_map_color_ui: function(){
            this.$bvModal.show('map-color-modal');
        },
        make_heatmap_gradient_config: function(gradient_key){
            if(!COLOR_GRADIENTS.hasOwnProperty(gradient_key)){
                return null;
            }
            let act_gradient = COLOR_GRADIENTS[gradient_key];
            let heat_gradient = {};
            for(let conf of act_gradient){
                let v_val = conf.v;
                if(v_val < 0.01){
                    v_val = 0.01;
                }
                let v_key = '' + v_val;
                heat_gradient[v_key] = conf.color;
            }
            return heat_gradient;
        },
        delayed_update_map_legends: function() {
            setTimeout(() => {  
                this.update_map_legends();
            }, 250);
        },
        update_map_legends: function() {
            let req_props = ['overlay_layers_by_id', 'visible_overlay_ids'];
            if(!this.util_search_map_ok_with_props(req_props)){
                return null;
            }
            // Use relevant parts of the current frontend object state
            // to track the state ff the legend. This means we won't make
            // a new legend everytime the map is panned or zoom levels change.
            // Only if the query changes or the overlays change will we update
            // the legends.
            let legend_ok_keys = ['ov', 'ovgrd',];
            let act_legend_state = {};
            for(let ok_key of legend_ok_keys){
                if(this.frontend_state_obj.hasOwnProperty(ok_key)){
                    act_legend_state[ok_key] = JSON.parse(JSON.stringify(this.frontend_state_obj[ok_key]));
                }else{
                    act_legend_state[ok_key] = null;
                }
            }
            let state_key = (
                this.$route.fullPath 
                + '#' 
                + encode_frag_obj(act_legend_state)
            );
            // console.log(this.$route);
            // console.log('Map legend state key is: ' + state_key);
            if(state_key in this.route_map_legends){
                if(this.route_map_legends[state_key].length > 0){
                    // console.log('Map legend state key already exists');
                    this.map_legends = this.route_map_legends[state_key];
                    return null;
                }
            }
            // console.log('Map legend state key is new');
            this.map_legends = [];
            let order_legends = ['sqr', 'crc', 'cntx', 'heat'];
            for(let ov_id of order_legends){
                if(this.map.visible_overlay_ids.indexOf(ov_id) < 0){
                    continue;
                }
                if(!this.map.overlay_layers_by_id.hasOwnProperty(ov_id)){ 
                    continue;
                }
                let act_layer = this.map.overlay_layers_by_id[ov_id];
                if(!act_layer.hasOwnProperty('legend')){
                    continue;
                }
                if(act_layer.legend == null){
                    continue;
                }
                this.map_legends.push(JSON.parse(JSON.stringify(act_layer.legend)));
            }
            // console.log('update map legends, legends: ');
            // console.log(this.map_legends);
            this.route_map_legends[state_key] = this.map_legends;
        },
        set_selected_gradient_key(gradient_key){
            if(!this.util_search_map_ok()){
                return null;
            }
            if(!gradient_key in COLOR_GRADIENTS){
                // This key does not exist, skip out.
                return null;
            }
            // capture the visible overlay ids before we mess with the overlay layers.
            // we need to do this to solve wierd state crap that I don't understand.
            let act_visible_overlay_ids = JSON.parse(JSON.stringify(this.map.visible_overlay_ids));
            this.selected_gradient_key = gradient_key;
            this.frontend_state_obj.ovgrd = gradient_key;
            let frontend_state = JSON.parse(JSON.stringify(this.frontend_state_obj));
            frontend_state.ovgrd = gradient_key;
            this.update_map_frontend_state_obj(frontend_state);
            this.selected_gradient_key = gradient_key;
            this.frontend_state_obj.ovgrd = gradient_key;
            this.add_overlay_layers();
            // remember the overlay ids!
            this.map.visible_overlay_ids = act_visible_overlay_ids;
            setTimeout(() => {
                this.frontend_state_obj.ovgrd = gradient_key;
                this.frontend_obj_overlays_prep();
            }, 50);
            this.delayed_update_map_legends();
            this.$bvModal.hide('map-color-modal');
        },
        add_search_map_extra_controls: function() {
            if(!this.util_search_map_ok()){
                return null;
            }
            if(this.map.hasOwnProperty('search_map_extra_buttons')){
                return null;
            }
            if(!this.map.hasOwnProperty('geodeep')){
                this.map.geodeep = 11;
            }
            if(!this.map.hasOwnProperty('max_tile_zoom')){
                this.map.max_tile_zoom = MAX_ZOOM_TILES;
            }
            this.map.update_geodeep = this.update_geodeep;
            this.map.show_map_color_ui = this.show_map_color_ui;
            this.map.overlay_icons = this.overlay_icons;
            this.map.deactivate_all_overlays_except = function(map, active_ov_id){
                if(!map.hasOwnProperty('overlay_layers_by_id')){
                    console.log('missing overlay_layers_by_id');
                    console.log(map);
                    return null;
                }
                map.visible_overlay_ids = [];
                for(let ov_id in map.overlay_layers_by_id){
                    if(!map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                        continue;
                    }
                    let act_layer = map.overlay_layers_by_id[ov_id];
                    if(active_ov_id == ov_id){
                        map.addLayer(act_layer);
                        map.visible_overlay_ids = [act_layer.ov_id];
                    }else{
                        act_layer.removeFrom(map);
                    }
                }
                if(map.hash_obj){
                    map.hash_obj.forceHashChange();
                }
            },
            this.map.add_search_map_extra_controls = function(map){
                let search_map_extra_controls = [];
                let deep_tile_control = L.easyButton(
                    map.overlay_icons.sqr_hr,
                    // the control for higher resolution region tiles
                    function (){
                        map.deactivate_all_overlays_except(map, 'sqr');
                        let new_geodeep = parseInt(map.geodeep) + 1;
                        if (new_geodeep <= map.max_tile_zoom) {
                            //can still zoom in
                            console.log('New higher tile zoom: ' + new_geodeep);
                            map.geodeep = new_geodeep;
                            map.update_geodeep(new_geodeep);
                        }
                    },
                    'Higher resolution summary regions',
                );
                let big_tile_control = L.easyButton(
                    map.overlay_icons.sqr_lr,
                    // control for lower resolution region tiles
                    function (){
                        map.deactivate_all_overlays_except(map, 'sqr');
                        let new_geodeep = map.geodeep - 1;
                        if (new_geodeep > 3) {
                            console.log('New lower tile zoom: ' + new_geodeep);
                            map.geodeep = new_geodeep;
                            map.update_geodeep(new_geodeep);
                        }
                    },
                    'Lower resolution summary regions',
                );
                let circle_control = L.easyButton(
                    map.overlay_icons.crc,
                    function (){
                        map.deactivate_all_overlays_except(map, 'crc');
                    },
                    'Circle-markers for summary regions',
                );
                let heat_control = L.easyButton(
                    map.overlay_icons.heat,
                    function (){
                        map.deactivate_all_overlays_except(map, 'heat');
                    },
                    'Heat-map visualization',
                );
                let color_control = L.easyButton(
                    '<span class="material-icons-two-tone">palette</span>', 
                    function (){
                        map.show_map_color_ui();
                    },
                    'Map visualization colors',
                );
                map.search_map_extra_buttons = {
                    deep_tile_control: deep_tile_control,
                    big_tile_control: big_tile_control,
                    circle_control: circle_control,
                    heat_control: heat_control,
                    color_control: color_control,
                };
                search_map_extra_controls.push(deep_tile_control);
                search_map_extra_controls.push(big_tile_control);
                search_map_extra_controls.push(circle_control);
                search_map_extra_controls.push(heat_control);
                search_map_extra_controls.push(color_control);
                L.easyBar(search_map_extra_controls).addTo(map);
            }
            this.map.add_search_map_extra_controls(this.map);
            // console.log(this.map.search_map_extra_buttons);
            // console.log('added search controls');
        },
        geo_view_from_state_obj: function(raw_frag_obj){
            if(!raw_frag_obj){
                return null;
            }
            let frag_obj = JSON.parse(JSON.stringify(raw_frag_obj));
            frag_obj.center = null;
            frag_obj.zoom = null;
            if(frag_obj.hasOwnProperty('zm') && frag_obj.hasOwnProperty('lat') && frag_obj.hasOwnProperty('lng')){
                let zoom = parseInt(frag_obj.zm, 10);
                let lat = parseFloat(frag_obj.lat);
                let lng = parseFloat(frag_obj.lng);
                if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) {
                    frag_obj.center = null;
                }
                else{
                    frag_obj.center = new L.LatLng(lat, lng);
                    frag_obj.zoom = zoom;
                }
            }
            return frag_obj;
        },
        set_map_view_from_frontend_state_obj: function () {
            if(!this.util_search_map_ok()){
                return null;
            }
            let frag_obj = this.geo_view_from_state_obj(this.frontend_state_obj);
            if (this.map_type == 'search' && frag_obj != null && frag_obj.center != null) {
                console.log('Update map view from frontend state');
                this.map.auto_fit = false;
                this.map.setView(frag_obj.center, frag_obj.zoom);
                return true;  
            }
            return false;
        },
        add_search_map_hash: function() {
            if(!this.util_search_map_ok()){
                return null;
            }
            this.map.visible_overlay_ids = [];
            this.set_map_view_from_frontend_state_obj();
            this.map_hash_obj = new L.Hash(this.map);
            this.map_hash_obj.frontend_state_obj = this.frontend_state_obj;
            this.map_hash_obj.update_map_frontend_state_obj = this.update_map_frontend_state_obj;
            this.map_hash_obj.update_base_layer = this.update_base_layer;
            this.map.hash_obj = this.map_hash_obj;
            this.map.on('baselayerchange', function(e) {
                // when the base layer changes, keep the id
                this.baselayer_name = e.name;
                if(this.hash_obj){
                    this.hash_obj.forceHashChange();
                }
            });
            this.map.overlay_ready = false;
            this.map.on('overlayadd', function(e) {
                // Adding an overlay layer, note what layers are active
                if(!this.overlay_ready){
                    return null;
                }
                if(!e.hasOwnProperty('layer') || !e.layer.hasOwnProperty('ov_id')){
                    console.log('Image overlay, no state recording');
                    return null;
                }
                
                if(this.visible_overlay_ids.indexOf(e.layer.ov_id) < 0){
                    this.visible_overlay_ids.push(e.layer.ov_id);
                }
                else{
                    // Nothing changed so skip out.
                    return null;
                }
                if(this.hash_obj){
                    this.hash_obj.forceHashChange();
                }
            });
            this.map.on('overlayremove', function(e) {
                if(!this.overlay_ready){
                    return null;
                }
                /// Remove an overlay layer, note what layers are active
                if(!e.hasOwnProperty('layer') || !e.layer.hasOwnProperty('ov_id')){
                    console.log('Image overlay, no state recording');
                    return null;
                }
                let new_overlay_ids = [];
                for(let i =0; i < this.visible_overlay_ids.length; i++){
                    if(this.visible_overlay_ids[i] !== e.layer.ov_id){
                        new_overlay_ids.push(this.visible_overlay_ids[i]);
                    }
                }
                if(this.visible_overlay_ids.length <= new_overlay_ids.length){
                    // Nothing changed, so skip out.
                    return null;
                }
                this.visible_overlay_ids = new_overlay_ids;
                if(this.hash_obj){
                    this.hash_obj.forceHashChange();
                }
            });
        },
        cat_limit_feature_data(category_limit, feature_data=null){
            if(!feature_data){
                let feature_data = {
                    type: "FeatureCollection",
                    features: [],
                };
            }
            feature_data.category = category_limit;
            if(!this.geo_json){
                return feature_data;
            }
            let counts = [];
            for(let feature of this.geo_json.features){
                if(feature.category != category_limit){
                    continue;
                }
                feature_data.features.push(feature);
                if(feature.hasOwnProperty('count')){
                    counts.push(feature.count);
                }
            }
            if(counts.length > 0){
                // Add information needed to style features.
                feature_data.min_count = Math.min.apply(Math, counts);
                feature_data.max_count = Math.max.apply(Math, counts);
                let count_features = [];
                for(let feature of feature_data.features){
                    feature.max_count = feature_data.max_count;
                    feature.gradient_key = this.selected_gradient_key;
                    count_features.push(feature);
                }
                feature_data.features = count_features;
            }
            return feature_data;
        },
        make_generic_feature_popup(feature){
            if(!feature.hasOwnProperty('properties')){
                return '';
            }
            if(feature.properties.length < 1){
                return '';
            }
            // First update the property labels (keys) using a constant config.
            let mapped_props = {};
            let mapped_prop_keys = [];
            for(let [key, val] of Object.entries(feature.properties)){
                if(skip_excluded_property_key(key)){
                    continue;
                }
                if(val == null){
                    continue;
                }
                let mapped_key = map_property_key_to_field(key);
                mapped_props[mapped_key] = val;
                mapped_prop_keys.push(mapped_key);
            }
            // Consolidate properties with their links.
            let link_consolidate = JSON.parse(JSON.stringify(UI_RECORD_PROPERTY_LINK_CONSOLIDATE));
            for(let a_prop of mapped_prop_keys){
                if(a_prop.indexOf(' [URI]') >= 0){
                    continue;
                }
                for(let b_prop of mapped_prop_keys){
                    if(b_prop == a_prop){
                        continue;
                    }
                    if(b_prop.indexOf(' [URI]') < 0){
                        continue;
                    }
                    let b_prop_first = b_prop.split(' [URI]')[0];
                    if(a_prop.indexOf(b_prop_first) >= 0){
                        //b prop is the link for the a_prop.
                        link_consolidate[a_prop] = b_prop;
                    }
                }
            }
            // Make the HTML for the (mapped) properties and their values.
            let used_keys = [];
            let prop_content = [];
            let label_index = null;
            for(let [mapped_key, val] of Object.entries(mapped_props)){
                if(used_keys.indexOf(mapped_key) >=0){
                    continue;
                }
                let link_val = null;
                if(link_consolidate.hasOwnProperty(mapped_key)){
                    let link_prop = link_consolidate[mapped_key];
                    if(link_prop == null){
                        // Don't make a link with this field.
                        used_keys.push(link_prop);
                        continue;
                    }
                    if(mapped_props.hasOwnProperty(link_prop)){
                        link_val = mapped_props[link_prop];
                        used_keys.push(link_prop);
                    }
                }
                // Values for a property can be in a list/array, so make
                // this the worst.
                let val_list = null;
                if(Array.isArray(val)){
                    val_list = val;
                }
                else{
                    val_list = [val];
                }
                if(val_list == null){
                    continue;
                }
                // Iterate through the val list to make a list of HTML to generate.
                let val_html_list = [];
                let val_index = 0;
                for(let act_val of val_list){
                    let val_html = act_val;
                    if(link_val != null){
                        let act_link = link_val;
                        if(Array.isArray(link_val)){
                            if(val_index >= link_val.length){
                                // problem, no link at this value index.
                                continue;
                            }
                            // Assumes the URI for the act_val is at the same index
                            // as the act_val.
                            act_link = link_val[val_index];
                        }
                        val_html = `<a target="_blank" href="${act_link}">${act_val}</a>`;
                    }
                    if(mapped_key == 'Thumbnail'){
                        val_html = `<img src="${act_val}" alt="Thumbnail image" style="max-width: 90%;" />`;
                    }
                    if(val_list.length > 1){
                        val_html = `<li>${val_html}</li>`;
                    }
                    val_html_list.push(val_html);
                    val_index += 1;
                }

                // Consolidate all of the val_html_list into one string.
                let all_vals_html = null;
                if(val_html_list.length == 1){
                    all_vals_html = val_html_list[0];
                }
                else if(val_html_list.length > 1){
                    all_vals_html = '<ul>' + val_html_list.join('\n') + '</ul>';
                }
                else{
                    continue;
                }
                let prop_html = (
                    `<dl class="row">
                    <dt class="col-5">${mapped_key}</dt>
                    <dd class="col-7">${all_vals_html}</dd>
                    </dl>
                    `
                );

                if(mapped_key == 'Item Label'){
                    label_index = prop_content.length;
                }
                if(mapped_key == 'Thumbnail' && label_index != null){
                    // Make sure the thumbnail is always after the item label.
                    prop_content.splice((label_index + 1), 0, prop_html);
                }
                else{
                    prop_content.push(prop_html);
                }
                used_keys.push(mapped_key);
            }
            var all_props = prop_content.join('\n');
            var popup_content = (
                `<div class="container geo_feature_popup">${all_props}</div>`
            );
            return popup_content;
        },
        make_item_feature_popup(feature){
            if(!this.item_json){
                return '';
            }
            return (
                `<dl class="row">
                <dt class="col">Item</dt>
                <dd class="col">${this.item_json.label}</dd>
                </dl>`
            );
        },
        make_feature_popup(feature){
            if(this.map_type == 'generic' || !this.item_json){
                return this.make_generic_feature_popup(feature);
            }
            return this.make_item_feature_popup(feature);
        },
        make_generic_feature_tooltip(feature){
            if(!feature.hasOwnProperty('properties')){
                return '';
            }
            if(feature.properties.length < 1){
                return '';
            }
            let act_prop_val = null;
            for (var prop in feature.properties) {
                act_prop_val = {k: prop, v:feature.properties[prop]};
                break;
            }
            if(!act_prop_val){
                return '';
            }
            return `<div>${act_prop_val.k}: ${act_prop_val.v}</div>`;
        },
        make_item_feature_tooltip(feature){
            if(!this.item_json){
                return '';
            }
            return ("<div>" + item_json.label + "</div>");
        },
        make_feature_tooltip(feature){
            if(this.map_type == 'generic' || !this.item_json){
                return this.make_generic_feature_tooltip(feature);
            }
            return this.make_item_feature_tooltip(feature);
        },
        gather_base_layers: function(){
            if(!this.map){
                return null;
            }
            for(tp of this.tileProviders){
                let tile_key = 'map-tile-' + this.ref_suffix + '-' + tp.name;
                if(this.$refs[tile_key] == null){
                    console.log('no basemap with key: ' + tile_key);
                    continue;
                }
                this.base_layers[tp.name] = this.$refs[tile_key][0].mapObject;
            }
        },
        add_google_tiles: function() {
            if(this.added_google_tiles){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(this.$refs[this.l_controls_ref] == null){
                console.log('no item: ' + this.l_controls_ref);
                return null;
            }
            if(this.$refs[this.map_ref] == null){
                console.log('no item: ' + this.map_ref);
                return null;
            }
            // console.log(this.map);
            for(let gtile_config of this.google_tile_configs){
                if(this.added_google_tile_types.indexOf(gtile_config.type) >= 0){
                    // Don't add the same layer twice!
                    continue;
                }
                let gtile = L.gridLayer.googleMutant(gtile_config);
                this.base_layers[gtile.options.name] = gtile;
                if(gtile_config.type == 'satellite'){
                    // Add support for over-zooming satellite.
                    this.map.addLayer(gtile);
                }
                this.$refs[this.l_controls_ref].mapObject.addBaseLayer(
                    gtile, gtile.options.name
                );
                this.added_google_tile_types.push(gtile_config.type);
            }
            this.added_google_tiles = true;
        },
        count_style: function(gradient_key, act_count, max_count){
            let act_gradient = COLOR_GRADIENTS[MAP_DEFAULT_COLOR_GRADIENT_KEY];
            if(gradient_key in COLOR_GRADIENTS){
                act_gradient = COLOR_GRADIENTS[gradient_key];
            }
            let hex_color = make_hex_color_in_gradient(
                (act_count / max_count), 
                act_gradient
            );
            let fill_opacity = (
                ((act_count / max_count) * 0.5 ) + 0.20
            );
            return {
                color: hex_color,
                fillOpacity: fill_opacity,
                weight: 1.5,
            };
        },
        polygon_count_style: function(feature){
            return this.count_style(
                feature.gradient_key,
                feature.count,
                feature.max_count,
            );
        },
        circle_count_style: function(gradient_key, act_count, max_count){
            let marker_opts = this.count_style(gradient_key, act_count, max_count);
            marker_opts.radius = Math.round(30 * (act_count / max_count), 0) + 5;
            marker_opts.fillColor = marker_opts.color;
            marker_opts.weight = 1;
            marker_opts.opacity = 0.95;
            marker_opts.fillOpacity = 0.8;
            return marker_opts;
        },
        circle_pointToLayer: function(feature,  latlng){
            let marker_opts = this.circle_count_style(
                feature.gradient_key,
                feature.count,
                feature.max_count,
            );
            return L.circleMarker(latlng, marker_opts);
        },
        make_legend_example_values: function(min_count, max_count){
            let example_div = 5;
            let max_min_dif =  max_count - min_count;
            let increment = max_min_dif / example_div;
            if(increment < 1){
                increment = 1;
            }
            let example_values = [];
            for(let act_val = min_count; act_val < max_count; act_val += increment){
                let round_val = Math.round(act_val, 0);
                if(example_values.indexOf(round_val) >=0 ){
                    continue
                }
                example_values.push(round_val);
            }
            if(example_values.indexOf(max_count) < 0){
                example_values.push(max_count);
            }
            return example_values;
        },
        make_layer_legend: function(act_layer, legend_key){
            if(!act_layer.hasOwnProperty('min_count')){
                return null;
            }
            if(!act_layer.hasOwnProperty('max_count')){
                return null;
            }
            let example_values = this.make_legend_example_values(
                act_layer.min_count, 
                act_layer.max_count
            );
            let legend = JSON.parse(JSON.stringify(this.legend_config));
            legend.ov_id = act_layer.ov_id;
            legend.label = act_layer.label;
            legend.icon = null;
            if(this.overlay_icons.hasOwnProperty(act_layer.ov_id)){
                legend.icon = this.overlay_icons[act_layer.ov_id];
            }
            legend.min_count = act_layer.min_count;
            legend.max_count = act_layer.max_count;
            let l_gradient_parts = ['to right'];
            if(legend_key != 'heat_style'){
                legend[legend_key] = [];
            }
            for(let act_count of example_values){
                let opts = this.circle_count_style(
                    this.selected_gradient_key, 
                    act_count, 
                    act_layer.max_count
                );
                opts.fillOpacity = 0.95;
                let rgb = convertToRGB(opts.color);
                let grad_part = `rgba(${rgb.join(', ')},1)`;
                l_gradient_parts.push(grad_part);
                let act_example = {
                    count: act_count,
                    radius: opts.radius,
                    svg_style: (
                        `fill:${opts.color};
                        fill-opacity:${opts.fillOpacity};
                        stroke:${opts.color};
                        stroke-width:${opts.weight};
                        stroke-opacity:1.0;`
                    ),
                };
                if(legend_key != 'heat_style'){
                    legend[legend_key].push(act_example);
                }
            }
            if(legend_key == 'heat_style'){
                legend[legend_key] = (
                    `min-height: 36px;
                    background-image: linear-gradient(${l_gradient_parts.join(', ')});`
                );
            }
            return legend;
        },
        get_map_geodeep_from_geojson: function(act_geojson){
            if(act_geojson.category != 'oc-api:geo-facet'){
                return null;
            }
            if(!this.map){
                return null;
            }
            let feature = act_geojson.features[0];
            let geo_id_ex = feature.geometry.id.split('-');
			let geo_tile = geo_id_ex[geo_id_ex.length - 1];
            this.map.geodeep = geo_tile.length;
        },
        geojson_to_circle_data: function(act_geojson){
            if(act_geojson.category != 'oc-api:geo-facet'){
                return null;
            }
            if(!act_geojson.hasOwnProperty('max_count')){
                return null;
            }
            let circle_geojson = JSON.parse(JSON.stringify(this.geo_facets_circles_default));
            circle_geojson.category = act_geojson.category;
            /*
			 * 1st we aggregate nearby tiles getting points for the center of each
			 * tile region
			 */
            let aggregated_tiles = {};
            for(let feature of act_geojson.features){
                let centroid = this.get_centroid(feature.geometry.coordinates[0]);
                let geo_id_ex = feature.geometry.id.split('-');
				let geo_tile = geo_id_ex[geo_id_ex.length - 1];
                let agg_tile_id = geo_tile.substring(0, (geo_tile.length -1));
                if(!(agg_tile_id in aggregated_tiles)) {
                    aggregated_tiles[agg_tile_id] = [];
                }
                let point_item = {
                    centroid: centroid,
                    count: feature.count,
                    id: replaceURLparameter(feature.id, 'allevent-geotile', agg_tile_id),
                }
                aggregated_tiles[agg_tile_id].push(point_item);
            }
            /*
			 * 2nd we compute the weighted average for nearby tile center points
			 * based on their counts. This will help make the map look less like a grid
			 */
            let min_count = null;
            let max_count = 0;
            let tindex = 0;
            let count_keyed_points = {};
            let count_keys = [];
            for(let agg_tile_id in aggregated_tiles){
                tindex += .000001;
                let total_count = 0;
                let sum_lat = 0;
                let sum_lng = 0;
                for(let point_item of aggregated_tiles[agg_tile_id]){
                    total_count += point_item.count;
                    sum_lat += point_item.centroid[1] * point_item.count;
                    sum_lng += point_item.centroid[0] * point_item.count;
                }
                if(max_count < total_count){
                    max_count = total_count;
                }
                if(min_count == null || total_count < min_count){
                    min_count = total_count;
                }
                let mean_lat = sum_lat / total_count;
                let mean_lng = sum_lng / total_count;
                let point_feature = {
                    'type': 'Feature',
                    'id': aggregated_tiles[agg_tile_id][0].id,
                    'count': total_count,
                    'max_count': null,
                    'geometry': {
                        'type': 'Point',
                        'coordinates': [mean_lng, mean_lat],
                    },
                };
                count_key = total_count + tindex;
                count_keys.push(count_key);
                count_keyed_points[count_key] = point_feature;
            }
            // Set min and max count limits for the circle feature geojson.
            circle_geojson.min_count = min_count;
            circle_geojson.max_count = max_count;
            /*
			 * 3rd we sort the points in descending order of count so the point features with
			 * the highest counts will be rendered lower
			 */
			count_keys.sort(function(a, b){return b-a;});
            for(let count_key of count_keys){
                let feature = count_keyed_points[count_key];
                feature.max_count = max_count;
                feature.gradient_key = this.selected_gradient_key;
                circle_geojson.features.push(feature);
            }
            return circle_geojson;
        },
        geojson_to_heatmap_data: function(act_geojson){
            if(act_geojson.category != 'oc-api:geo-facet'){
                return null;
            }
            if(!act_geojson.hasOwnProperty('max_count')){
                return null;
            }
            let heatmap_data = JSON.parse(JSON.stringify(this.heatmap_data_default));
            heatmap_data.min_count = act_geojson.min_count;
            heatmap_data.max_count = act_geojson.max_count;
            heatmap_data.max = act_geojson.max_count;
            for(let feature of act_geojson.features){
                let centroid = this.get_centroid(feature.geometry.coordinates[0]);
                let data_item = {
                    // convert geojson order to lat/lng
                    lat: centroid[1],
                    lng: centroid[0],
                    count: feature.count,
                }
                heatmap_data.data.push(data_item);
            }
            return heatmap_data;
        },
        add_overlay_layers: function() {
            if(!this.geo_json){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(this.$refs[this.l_controls_ref] == null){
                console.log('no item: ' + this.l_controls_ref);
                return null;
            }
            if(!this.frontend_state_obj){
                // not a search map, no search map overlays.
                return null;
            }

            // Use the frontend state object to set the selected color gradient,
            // if applicable.
            if(this.frontend_state_obj.hasOwnProperty('ovgrd')){
                if(this.frontend_state_obj.ovgrd in COLOR_GRADIENTS){
                    // console.log('frontend obj color gradient: ' + this.frontend_state_obj.ovgrd);
                    this.selected_gradient_key = this.frontend_state_obj.ovgrd;
                }
            }else{
                this.frontend_state_obj.ovgrd = MAP_DEFAULT_COLOR_GRADIENT_KEY;
            }

            // prevent mutation of the result.
            this.geo_tile_facets = this.cat_limit_feature_data(
                'oc-api:geo-facet', 
                JSON.parse(JSON.stringify(this.geo_tile_facets_default))
            );
            this.geo_region_facets = this.cat_limit_feature_data(
                'oc-api:geo-contained-in-feature', 
                JSON.parse(JSON.stringify(this.geo_region_facets_default))
            );
            this.geo_page_records = this.cat_limit_feature_data(
                'oc-api:geo-record', 
                JSON.parse(JSON.stringify(this.geo_page_records_default))
            );

            // Removes prior geojson overlay layers from prior routing.
            if(this.map.hasOwnProperty('overlay_layers_by_id')){
                for(let ov_id in this.map.overlay_layers_by_id){
                    if(!this.map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                        continue;
                    }
                    let act_layer = this.map.overlay_layers_by_id[ov_id];
                    act_layer.removeFrom(this.map);
                    this.$refs[this.l_controls_ref].mapObject.removeLayer(
                        act_layer, 
                    );
                }
            }
            this.map.overlay_layers_by_id = null;

            // Gather all the types of 'raw' geojson used to build overlay layers.
            let overlays_geojson = [];
            if(this.geo_tile_facets && this.geo_tile_facets.features.length > 0){
                overlays_geojson.push(this.geo_tile_facets);
            }
            if(this.geo_region_facets && this.geo_region_facets.features.length > 0){
                overlays_geojson.push(this.geo_region_facets);
            }
            if(this.geo_page_records && this.geo_page_records.features.length > 0){
                overlays_geojson.push(this.geo_page_records);
            }
            if(this.geo_all_records && this.geo_all_records.features.length > 0){
                overlays_geojson.push(this.geo_all_records);
            }
            if(this.geojson_record_layers && this.geojson_record_layers.length > 0){
                for(let geo_rec_layer of this.geojson_record_layers){
                    overlays_geojson.push(geo_rec_layer);
                }
            }
            if(overlays_geojson.length < 1){
                return null;
            }

            this.map.overlay_layers_by_id = {};
            let i = -1;
            for(let act_geojson of overlays_geojson){
                let act_layer = null;
                if(act_geojson.hasOwnProperty('max_count')){
                    act_layer = L.geoJson(
                        act_geojson,
                        {
                            style: this.polygon_count_style,
                            onEachFeature: this.onEachFeatureFunction,
                        },
                    );
                    act_layer.min_count = act_geojson.min_count;
                    act_layer.max_count = act_geojson.max_count;
                }
                else{
                    act_layer = L.geoJson(
                        act_geojson,
                        {
                            onEachFeature: this.onEachFeatureFunction,
                        },
                    );
                }
                i += 1;
                act_layer.ref = act_geojson.ref;
                act_layer.label = act_geojson.label;
                if(act_geojson.hasOwnProperty('ov_id')){
                    act_layer.ov_id = act_geojson.ov_id;
                }
                else{
                    act_layer.ov_id = 'overlay-' + i;
                }
                // Add the layer legend if applicable.
                act_layer.legend = this.make_layer_legend(act_layer, 'poly_list');
                // Now add it again fresh.
                act_layer.addTo(this.map, act_geojson.label);
                this.$refs[this.l_controls_ref].mapObject.addOverlay(
                    act_layer, 
                    act_geojson.label
                );
                act_layer.bringToFront();
                // Add to the object of all overlays keyed by their ID.
                this.map.overlay_layers_by_id[act_layer.ov_id] = act_layer;

                let l_geo_json = this.$refs[this.geojson_ref];
                if(l_geo_json){
                    this.map.removeLayer(l_geo_json);
                }

                if(!this.frontend_state_obj.hasOwnProperty('ov') && act_layer.ov_id == SEARCH_MAP_DEFAULT_OVERLAY_KEY){
                    // we don't have a frontend obj determined overlay, and we don't have any
                    // currently visible overlays, so make this active layer visible.
                    this.map.addLayer(act_layer);
                    this.map.visible_overlay_ids.push(act_layer.ov_id);
                }
                else{
                    this.map.removeLayer(act_layer);
                }

                // Add headmap if relevant.
                let heatmap_data = this.geojson_to_heatmap_data(act_geojson);
                let circle_geojson = this.geojson_to_circle_data(act_geojson);
                if(heatmap_data == null || circle_geojson == null){
                    continue;
                }
                
                // Extract the current geodeep property. This is needed to give a starting
                // value for increasing or decreasing the tile resolution controls.
                this.get_map_geodeep_from_geojson(act_geojson);

                // Make and add a circle layer
                let circle_layer = L.geoJson(
                    circle_geojson,
                    {
                        pointToLayer: this.circle_pointToLayer,
                        onEachFeature: this.onEachFeatureFunction,
                    },
                );
                circle_layer.ref = circle_geojson.ref;
                circle_layer.label = circle_geojson.label;
                circle_layer.ov_id = circle_geojson.ov_id;
                circle_layer.min_count = circle_geojson.min_count;
                circle_layer.max_count = circle_geojson.max_count;
                circle_layer.legend = this.make_layer_legend(circle_layer, 'circle_list');
                circle_layer.addTo(this.map, circle_layer.label);
                this.$refs[this.l_controls_ref].mapObject.addOverlay(
                    circle_layer, 
                    circle_layer.label
                );
                circle_layer.bringToFront();
                this.map.removeLayer(circle_layer);
                this.map.overlay_layers_by_id[circle_layer.ov_id] = circle_layer;

                //Make and add the heatmap layer.
                // First, set up the color gradient for the heatmap.
                let act_heatmap_config = JSON.parse(JSON.stringify(this.heatmap_config));
                act_heatmap_config.gradient = this.make_heatmap_gradient_config(
                    this.selected_gradient_key
                );
                let heatmap_layer = new HeatmapOverlay(act_heatmap_config);
                heatmap_layer.ref = heatmap_data.ref;
                heatmap_layer.label = heatmap_data.label;
                heatmap_layer.ov_id = heatmap_data.ov_id;
                heatmap_layer.min_count = heatmap_data.min_count;
                heatmap_layer.max_count = heatmap_data.max_count;
                heatmap_layer.setData(heatmap_data);
                heatmap_layer.legend = this.make_layer_legend(heatmap_layer, 'heat_style');
                heatmap_layer.addTo(this.map, heatmap_layer.label);
                this.$refs[this.l_controls_ref].mapObject.addOverlay(
                    heatmap_layer, 
                    heatmap_layer.label
                );
                heatmap_layer.zIndex = 100;
                this.map.removeLayer(heatmap_layer);
                this.map.overlay_layers_by_id[heatmap_layer.ov_id] = heatmap_layer;
            }

        },
        finesse_item_view: function(){
            if(!this.map){
                return null;
            }
            if (this.map_type == 'search'){
                return null;
            }
            if(!('features' in this.geo_json)){
                return null;
            }
            if(this.geo_json.features.length > 1){
                return null;
            }
            if(this.geo_json.features[0].geometry.type != 'Point'){
                console.log('Use extent derived zoom for ' + this.geo_json.features[0].geometry.type);
                return null;
            }
            let zoom = this.default_zoom;
            if(this.map_type in this.map_type_default_zooms){
                zoom = this.map_type_default_zooms[this.map_type];
            }
            let center = this.map.getCenter();
            this.map.setView(center, zoom);
        },
        fit_bounds: function(){
            if(!this.geo_json && GEO_JSON != null){
                this.geo_json = GEO_JSON;
            }
            if(!this.map){
                return null;
            }
            let frag_obj_set_view = this.set_map_view_from_frontend_state_obj();
            if (frag_obj_set_view){
                console.log('Fontend state object set map bounds.');
                return null;
            }
            // console.log('Use overlay layer to fit bounds.');
            let act_overlay_layer = null;
            if(this.map.hasOwnProperty('overlay_layers_by_id')){
                if (this.map.overlay_layers_by_id && this.map.overlay_layers_by_id.hasOwnProperty('sqr')){
                    act_overlay_layer = this.map.overlay_layers_by_id.sqr;
                }
            }
            if(act_overlay_layer == null){
                act_overlay_layer = this.$refs[this.geojson_ref];
                if(act_overlay_layer == null){
                    // console.log('no geo-json layer item: ' + this.geojson_ref);
                    return null;
                }
            }
            if(act_overlay_layer == null){
                console.log('no overlay layer for fitbounds');
                return null;
            }
            this.map.auto_fit = true;
            let bounds = act_overlay_layer.getBounds();
            this.map.fitBounds(bounds);
            // console.log(bounds);
            this.map.auto_fit = false;
        },
        frontend_obj_overlays_prep: function(){
            if(this.map_type != 'search'){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(!this.map.hasOwnProperty('overlay_layers_by_id')){
                // No overlay layers by ID added to the map.
                return null;
            }  
            if(!this.frontend_state_obj.hasOwnProperty('ov')){
                // No overlays passed from frontend state object.
                return null;
            }
            if(typeof this.frontend_state_obj.ov === 'string'){
                // No overlays passed from frontend state object.
                this.frontend_state_obj.ov = [this.frontend_state_obj.ov];
            }

            for(let ov_id in this.map.overlay_layers_by_id){
                if(!this.map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                    continue;
                }
                let act_layer = this.map.overlay_layers_by_id[ov_id];
                if(this.frontend_state_obj.ov.indexOf(act_layer.ov_id) >=0){
                    if(this.map.visible_overlay_ids.indexOf(act_layer.ov_id) < 0){
                        this.map.visible_overlay_ids.push(act_layer.ov_id);
                    }
                    console.log('activate ' + act_layer.ov_id);
                    this.map.addLayer(act_layer);
                }
                else{
                    console.log('deactivate ' + act_layer.ov_id);
                    this.map.removeLayer(act_layer);
                }
            }
        },
        ready_map_setup: function(){
            this.map = this.$refs[this.map_ref].mapObject;
            this.map._layersMaxZoom = MAX_ZOOM;
            this.map.auto_fit = true;
            this.map.legends = null;
            this.gather_base_layers();
            this.add_google_tiles();
            this.get_item_location_info();
            this.add_search_map_hash();
            this.add_overlay_layers();
            this.add_search_map_extra_controls();
            this.frontend_obj_overlays_prep();
            this.update_map_legends();
            this.fit_bounds();
            this.finesse_item_view();
            // this.update_map_legends();
            this.map.auto_fit = false;
            this.map.overlay_ready = true;
        },
        map_size_reset: function(){
            if(!this.geo_json && GEO_JSON != null){
                this.geo_json = GEO_JSON;
            }
            setTimeout(() => {
                // wait a bit so the geojson layer is available.
                this.$refs[this.map_ref].mapObject.invalidateSize();
            }, 50);
        },
        get_item_location_info: function() {
            if(!this.geo_json || !this.item_json){
                return null;
            }
            for(let feat of this.geo_json.features){
                if(!feat.hasOwnProperty('properties')){
                    continue;
                }
                if(!feat.properties.hasOwnProperty('href')){
                    continue;
                }
                if(feat.properties.href != this.item_json.id){
                    continue;
                }
                if(feat.properties.hasOwnProperty('location_precision_factor')){
                    this.location_precision_factor = feat.properties.location_precision_factor;
                }
                if(feat.properties.hasOwnProperty('location_precision_note')){
                    this.location_precision_note = feat.properties.location_precision_note;
                }
            }
        },
        update_map_setup: function(){
            this.map.overlay_ready = false;
            if(this.map_type == 'search' && this.map_hash_obj){
                this.map_hash_obj.frontend_state_obj = this.frontend_state_obj;
                this.map.hash_obj = this.map_hash_obj;
            }
            this.add_overlay_layers();
            this.map_size_reset();
            this.frontend_obj_overlays_prep();
            this.fit_bounds();
            this.finesse_item_view();
            this.get_item_location_info();
            this.update_map_legends();
            // console.log('updated map');
            // console.log('current frontend state');
            // console.log(this.frontend_state_obj);
            this.map.overlay_ready = true;
        },
        fetch_geojson: function() {
            if(!this.geo_json_url){
                return null;
            }
            if(this.geo_json){
                return null;
            }
            console.log('fetch geojson from: ' + this.geo_json_url);
            const requestOptions = {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json, application/geo+json, application/vnd.geo+json,',
                    },
                };
            fetch(
                (this.geo_json_url), 
                requestOptions,
            )
            .then(this.loading = false)
            .then(response => response.json())
            .then(json => {
                this.geo_json = json;
                console.log('fetched geojson');
            });
        },
    },
    components: {
      'l-popup': l_popup,
      'l-img-overlay' : l_img_overlay,
      'l-tile-layer': l_tile_layer,
      'l-geo-json': l_geo_json,
      'l-marker': l_marker,
      'l-map': l_map,
      'map-legends': vc_map_legends,
      'map-color-ui': vc_map_color_ui,
    },
});




/* TODO: https://www.patrick-wied.at/static/heatmapjs/example-heatmap-leaflet.html */









</script>



{% endblock %}