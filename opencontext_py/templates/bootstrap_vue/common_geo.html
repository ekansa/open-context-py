{% block common_geo %}

{% load humanize %}


<template id='common_map'>
    <div>
        <l-map
            v-if="geo_json"
            @ready="ready_map_setup"
            :class="map_class"
            :style="'min-height: ' + min_height + 'px;'"
            :ref="'map-' + ref_suffix" 
            :zoom="11"
            :load-tiles-while-animating="true" 
            :load-tiles-while-interacting="true">
            <l-control-layers
                :ref="'map-l-controls-' + ref_suffix"
                position="topright"></l-control-layers>
            <l-tile-layer
                v-for="tp in tileProviders"
                :ref="'map-tile-' + ref_suffix + '-' + tp.name" 
                :key="tp.name"
                :name="tp.name"
                :visible="tp.visible"
                :url="tp.url"
                :attribution="tp.attribution"
                :maxZoom="tp.maxZoom"
                :maxNativeZoom="tp.maxNativeZoom"
                layer-type="base"></l-tile-layer>
            <l-img-overlay
                v-if="geo_overlays"
                v-for="ov in geo_overlays"
                :key="ov.id"
                :name="ov.label"
                :visible="ov.visible"
                :url="ov.url"
                :attribution="ov.attribution"
                :bounds="ov.bounds"
                layer-type="overlay"
            ></l-img-overlay>
            <l-geo-json
                v-if="show_default_overlay"
                :key="'map-geojson-' + ref_suffix + '-' + map_key"
                :ref="'map-geojson-' + ref_suffix"
                :options="options"
                v-bind:geojson="geo_json"
            >
            <l-popup></l-popup>
            </l-geo-json>
        </l-map>
        <div v-else class="text-center mb-3 d-flex justify-content-between">
            <b-spinner
                :variant="primary"
                style="width: 3rem; height: 3rem;" label="Large Spinner"></b-spinner>
        </div>
        <div v-if="location_precision_note">
            <b-alert v-if="location_precision_factor" show variant="warning">
              <small>[[location_precision_note]]</small>
            </b-alert>
            <b-alert v-else show variant="info">
              <small>[[location_precision_note]]</small>
            </b-alert>
        </div>
    </div>
</template>


<script type="text/javascript">
  // Import Vue2Leaflet components. 
  const l_popup = Vue.component('l-popup', window.Vue2Leaflet.LPopup);
  const l_tile_layer = Vue.component(
    'l-tile-layer', 
    window.Vue2Leaflet.LTileLayer,
  );
  const l_img_overlay = Vue.component(
    'l-img-overlay', 
    window.Vue2Leaflet.LImageOverlay,
  );
  const l_geo_json = Vue.component(
    'l-geo-json', 
    window.Vue2Leaflet.LGeoJson,
  );
  const l_control_layers = Vue.component(
    'l-control-layers', 
    window.Vue2Leaflet.LControlLayers,
  );
  const l_marker = Vue.component(
    'l-marker', 
    window.Vue2Leaflet.LMarker,
  );
  const l_map = Vue.component(
    'l-map', 
    window.Vue2Leaflet.LMap,
  );

  const MAX_ZOOM_TILES = 26;
  const MAX_ZOOM = 30;
  
  const GOOGLE_API_KEY = 'AIzaSyAuhr3tCQOxbGxnOki11vuvDB86-sxjHwo';
  const MAPBOX_PUBLIC_ACCESS_TOKEN = '{{ MAPBOX_PUBLIC_ACCESS_TOKEN|escapejs }}';
  
  const GOOGLE_TILE_CONFIGS = [
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Road",
      type: "roadmap",
      id: 'google-road',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Aerial",
      type: "satellite",
      id: 'google-aerial',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Terrain",
      type: "terrain",
      id: 'google-terrain',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
    {
      maxZoom: MAX_ZOOM_TILES,
      name: "Google Hybrid",
      type: "hybrid",
      id: 'google-hybrid',
      attribution: 'Map data: © <a target="_blank" href="https://google.com">Google.com</a>',
    },
  ];


  const TILE_PROVIDERS = [
    {
      name: 'MapBox Satellite',
      visible: true,
      id: 'mapbox-satellite',
      url: (
        'https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token='
        + MAPBOX_PUBLIC_ACCESS_TOKEN
      ),
      attribution: 'Map data: © <a target="_blank" href="https://MapBox.com">MapBox.com</a>',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: MAX_ZOOM_TILES,
    },
    {
      name: 'OpenStreetMap',
      visible: false,
      id: 'osm',
      url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      attribution: '© <a target="_blank" href="http://osm.org/copyright">OpenStreetMap</a> contributors',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: 18,
    },
    {
      name: 'OpenTopoMap',
      visible: false,
      id: 'otm',
      url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
      attribution: 'Map data: © <a target="_blank" href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: © <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
      maxZoom: 16,
      maxNativeZoom: 16,
    },
    {
      name: 'MapBox Light',
      visible: false,
      id: 'mapbox-light',
      url: (
        'https://api.mapbox.com/styles/v1/mapbox/light-v10/tiles/{z}/{x}/{y}?access_token=' 
        + MAPBOX_PUBLIC_ACCESS_TOKEN
      ),
      attribution: 'Map data: © <a target="_blank" href="https://MapBox.com">MapBox.com</a>',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: MAX_ZOOM_TILES,
    },
    {
      name: 'MapBox Dark',
      visible: false,
      id: 'mapbox-dark',
      url: (
        'https://api.mapbox.com/styles/v1/mapbox/dark-v10/tiles/{z}/{x}/{y}?access_token='
        + MAPBOX_PUBLIC_ACCESS_TOKEN
      ),
      attribution: 'Map data: © <a href="https://MapBox.com">MapBox.com</a>',
      maxZoom: MAX_ZOOM,
      maxNativeZoom: MAX_ZOOM_TILES,
    },
  ];


// URL updating for Map view state.
(function(window) {
    var HAS_HASHCHANGE = (function() {
        var doc_mode = window.documentMode;
        return ('onhashchange' in window) &&
            (doc_mode === undefined || doc_mode > 7);
    })();
    
    L.Hash = function(map) {
        this.tile_zoom = false;
        this.onHashChange = L.Util.bind(this.onHashChange, this);
    
        if (map) {
            this.init(map);
        }
    };
    
    L.Hash.prototype = {
        map: null,
        lastHash: null,
        frontend_state_obj: null,
        update_map_frontend_state_obj: null,
        update_base_layer: null,
    
        contains: function(a, obj) {
            var i = a.length;
            while (i--) {
               if (a[i] === obj) {
                   return true;
               }
            }
            return false;
        },

        prep_geo_from_state_obj: function(frag_obj){
            frag_obj.center = null;
            frag_obj.zoom = null;
            if(frag_obj.hasOwnProperty('zm') && frag_obj.hasOwnProperty('lat') && frag_obj.hasOwnProperty('lng')){
                let zoom = parseInt(frag_obj.zm, 10);
                let lat = parseFloat(frag_obj.lat);
                let lng = parseFloat(frag_obj.lng);
                if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) {
                    frag_obj.center = null;
                }
                else{
                    frag_obj.center = new L.LatLng(lat, lng);
                    frag_obj.zoom = zoom;
                }
            }
            if(frag_obj.hasOwnProperty('bm') && frag_obj.bm != null){
                this.update_base_layer(frag_obj.bm.replace('_', ' '));
            }
            return frag_obj;
        },

        parseHash: function(hash) {
            let frag_obj = parse_search_frag_dict(hash);
            return this.prep_geo_from_state_obj(frag_obj);
        },
    
        compose_new_frontend_state: function(map){
            let frag_obj = null;
            if(this.frontend_state_obj == null){
                frag_obj = parse_search_frag_dict(location.hash);
            }else{
                frag_obj = this.frontend_state_obj;
            }

            let center = this.map.getCenter();
            let zoom = this.map.getZoom();
            let precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));

            frag_obj.zm = zoom;
            frag_obj.lat = center.lat.toFixed(precision);
            frag_obj.lng = center.lng.toFixed(precision);
            if(this.map.baselayer_name){
                frag_obj.bm = this.map.baselayer_name.replace(' ' , '_');
            }
            return frag_obj;
        },

        formatHash: function(frag_obj) {
            let frag_str = encode_frag_obj(frag_obj);
            return '#' + frag_str;
        },
    
        init: function(map) {
            this.map = map;
            this.map.on("moveend", this.onMapMove, this);
            // reset the hash
            this.lastHash = null;
            this.onHashChange();
            if (!this.isListening) {
                this.startListening();
            }
        },
    
        remove: function() {
            this.map = null;
            if (this.isListening) {
                this.stopListening();
            }
        },

        update_new_fontend_state: function(frag_obj){
            // Updates the frontend state for all vue components.
            if(frag_obj.hasOwnProperty('center')){
                delete frag_obj.center;
            }
            if(frag_obj.hasOwnProperty('zoom')){
                delete frag_obj.zoom;
            }
            let hash = this.formatHash(frag_obj);
            if (this.lastHash != hash) {
                this.update_map_frontend_state_obj(frag_obj);
                this.lastHash = hash;
                return true;
            }
            return false;
        },
        
        forceHashChange: function(map) {
            // change the hash, in response to changes
            // in base layers
            if(this.map.auto_fit){
                return false;
            }
            let frag_obj = this.compose_new_frontend_state(map);
            this.update_new_fontend_state(frag_obj);
        },
        
        onMapMove: function(map) {
            // bail if we're moving the map (updating from a hash),
            // or if the map has no zoom set
            
            if (this.movingMap || this.map.getZoom() === 0) {
                return false;
            }
            if(this.map.auto_fit){
                return false;
            }
            let frag_obj = this.compose_new_frontend_state(map);
            this.update_new_fontend_state(frag_obj);
        },
    
        movingMap: false,
        update: function() {
            let parsed = null;
            if(this.frontend_state_obj == null){
                var hash = location.hash;
                if (hash === this.lastHash) {
                    // console.info("(no change)");
                    return null;
                }
                parsed = this.parseHash(hash);
            }else{
                parsed = this.prep_geo_from_state_obj(this.frontend_state_obj);
            }
            if (parsed != null && parsed.center != null) {
                // console.log("parsed:", parsed.zoom, parsed.center.toString());
                this.movingMap = true;
                this.map.setView(parsed.center, parsed.zoom);  
                this.movingMap = false;
            } else {
                // console.warn("parse error; resetting:", this.map.getCenter(), this.map.getZoom());
                this.onMapMove(this.map);
            }
        },
    
        // defer hash change updates every 100ms
        changeDefer: 100,
        changeTimeout: null,
        onHashChange: function() {
            // throttle calls to update() so that they only happen every
            // `changeDefer` ms
            if (!this.changeTimeout) {
                var that = this;
                this.changeTimeout = setTimeout(function() {
                    that.update();
                    that.changeTimeout = null;
                }, this.changeDefer);
            }
        },
    
        isListening: false,
        hashChangeInterval: null,
        startListening: function() {
            if (HAS_HASHCHANGE) {
                L.DomEvent.addListener(window, "hashchange", this.onHashChange);
            } else {
                clearInterval(this.hashChangeInterval);
                this.hashChangeInterval = setInterval(this.onHashChange, 50);
            }
            this.isListening = true;
        },
    
        stopListening: function() {
            if (HAS_HASHCHANGE) {
                L.DomEvent.removeListener(window, "hashchange", this.onHashChange);
            } else {
                clearInterval(this.hashChangeInterval);
            }
            this.isListening = false;
        }
    };
})(window);



var vc_common_map = Vue.component(
  'common_map', 
  {
    props: [
        'map_key',
        'ref_suffix',
        'geo_json_url',
        'geo_json',
        'geo_overlays',
        'item_json',
        'map_type',
        'map_class',
        'min_height',
        'route_key_index',
        'frontend_state_obj',
        'show_default_overlay',
    ],
    data() {
        return {
            // Map Options
            map: null,
            map_key: 0,
            zoom_def: 13,
            base_layers: {},
            selectedTileSet: TILE_PROVIDERS[0], 
            tileProviders: TILE_PROVIDERS,
            google_tile_configs: GOOGLE_TILE_CONFIGS,
            added_google_tiles: false,
            added_google_tile_types: [],
            minZoom_def: 1,
            maxZoom_def: MAX_ZOOM,
            show_mapsets_default: true,
            center: null,
            geo_json_url: null,
            geo_json: null,
            geo_overlays: null,
            location_precision_factor: null,
            location_precision_note: null,
            item_json: null,
            map_type: 'generic',
            map_class: 'item',
            min_height: 300,
            route_key_index: 0,
            frontend_state_obj: {},
            map_hash_obj: null,
            baselayer_name: null,
            default_zoom: 11,
            map_type_default_zooms: {
                item: 16,
                generic: 12,
            },
            default_tilelayer_name: 'Google Aerial',
            geo_tile_facets: {
                type: "FeatureCollection",
                label: "Summary regions",
                ref: "map-tile-geojson-" + this.ref_suffix,
                features: [],
            },
            geo_region_facets: {
                type: "FeatureCollection",
                label: "Context summary",
                ref: "map-region-geojson-" + this.ref_suffix,
                features: [],
            },
            geo_page_records: {
                type: "FeatureCollection",
                label: "Records (current page)",
                ref: "map-page-recs-geojson-" + this.ref_suffix,
                features: [],
            },
            geo_all_records: {
                type: "FeatureCollection",
                label: "Records (all selected)",
                ref: "map-all-recs-geojson-" + this.ref_suffix,
                features: [],
            },
            show_default_overlay: true,
            act_overlay_layer: null,
        };
    },
    template: '#common_map',
    delimiters: ['[[', ']]'],
    created() {
        this.fetch_geojson();
    },
    mounted() {
        this.fetch_geojson();
    },
    updated(){
        this.update_map_setup();
    },
    computed: {
        map_ref(){return 'map-' + this.ref_suffix},
        l_controls_ref(){return 'map-l-controls-' + this.ref_suffix},
        geojson_ref(){return 'map-geojson-' + this.ref_suffix},
        options() {
            return {
                onEachFeature: this.onEachFeatureFunction
            };
        },
        onEachFeatureFunction() {
            return (feature, layer) => {
                let popup_content = this.make_feature_popup(feature);
                let tooltip_content = this.make_feature_tooltip(feature);
                layer.bindPopup(popup_content);
                layer.bindTooltip(
                    tooltip_content, 
                    { permanent: false, sticky: true }
                );
            };
        },
    },
    methods: {
        add_links(str){
            if (!(typeof str === 'string' || str instanceof String)){
                return str;
            }
            if(str.startsWith("https://")||str.startsWith("http://")){
                return `<a target="_blank" href="${str}">${str}</a>`;
            }
            return str;
        },
        update_map_frontend_state_obj(frontend_state_obj) {
            this.$emit('set_frontend_state_obj', frontend_state_obj);
        },
        update_base_layer(baselayer_name){
            if(!this.map){
                return null;
            }
            if(!(baselayer_name in this.base_layers)){
                console.log('Cannot find baselayer: ' + baselayer_name);
                return null;
            }
            //
            for(let name_key in this.base_layers){
                let act_layer = this.base_layers[name_key];
                if(name_key == baselayer_name){
                    this.map.addLayer(act_layer);
                }
                else{
                    this.map.removeLayer(act_layer);
                }
            }
            let new_tile_state_list = [];
            for(tp of this.tileProviders){
                tp.visible = false;
                if(tp.name == baselayer_name){
                    tp.visible = true;
                    this.selectedTileSet = tp;
                }
                new_tile_state_list.push(tp);
            }
            this.tileProviders = new_tile_state_list;
            this.map.baselayer_name = baselayer_name;
        },
        add_search_map_extra_controls: function() {
            if(this.map_type != 'search'){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(this.map.hasOwnProperty('search_map_extra_buttons')){
                return null;
            }
            if(!this.map.hasOwnProperty('geodeep')){
                this.map.geodeep = 11;
            }
            if(!this.map.hasOwnProperty('default_overlay_layer')){
                this.map.default_overlay_layer = 'tile';
            }
            if(!this.map.hasOwnProperty('max_tile_zoom')){
                this.map.max_tile_zoom = MAX_ZOOM_TILES;
            }
            this.map.add_search_map_extra_controls = function(map){
                let search_map_extra_controls = [];
                let deep_tile_control = L.easyButton(
                    '<span class="material-icons-two-tone">grid_on</span>',
                    // the control for higher resolution region tiles
                    function (){
                        map.default_overlay_layer = 'tile';
                        let new_geodeep = parseInt(map.geodeep) + 1;
                        if (new_geodeep <= map.max_tile_zoom) {
                            //can still zoom in
                            console.log('New higher tile zoom: ' + new_geodeep);
                            map.geodeep = new_geodeep;
                        }
                    },
                    'Higher resolution Open Context regions',
                );
                let big_tile_control = L.easyButton(
                    '<span class="material-icons-two-tone">window</span>',
                    // control for lower resolution region tiles
                    function (){
                        map.default_overlay_layer = 'tile';
                        let new_geodeep = map.geodeep - 1;
                        if (new_geodeep > 3) {
                            console.log('New lower tile zoom: ' + new_geodeep);
                            map.geodeep = new_geodeep;
                        }
                    },
                    'Lower resolution Open Context regions',
                );
                let circle_control = L.easyButton(
                    '<span class="material-icons">circle</span>', 
                    function (){
                        console.log('Circle region button');
                    },
                    'Circle-markers for Open Context regions',
                );
                let heat_control = L.easyButton(
                    '<span class="material-icons">thermostat</span>', 
                    function (){
                        console.log('Heat-map button');
                    },
                    'Heat-map visualization',
                );
                map.search_map_extra_buttons = {
                    deep_tile_control: deep_tile_control,
                    big_tile_control: big_tile_control,
                    circle_control: circle_control,
                    heat_control: heat_control,
                };
                search_map_extra_controls.push(deep_tile_control);
                search_map_extra_controls.push(big_tile_control);
                search_map_extra_controls.push(circle_control);
                search_map_extra_controls.push(heat_control);
                L.easyBar(search_map_extra_controls).addTo(map);
            }
            this.map.add_search_map_extra_controls(this.map);
            console.log(this.map.search_map_extra_buttons);
            console.log('added search controls');
        },
        add_search_map_hash: function() {
            if(this.map_type != 'search'){
                return null;
            }
            if(!this.map){
                return null;
            }
            this.map_hash_obj = new L.Hash(this.map);
            this.map_hash_obj.frontend_state_obj = this.frontend_state_obj;
            this.map_hash_obj.update_map_frontend_state_obj = this.update_map_frontend_state_obj;
            this.map_hash_obj.update_base_layer = this.update_base_layer;
            this.map.hash_obj = this.map_hash_obj;
            this.map.on('baselayerchange', function(e) {
                // when the base layer changes, keep the id
                this.baselayer_name = e.name;
                if(this.hash_obj){
                    this.hash_obj.forceHashChange();
                }
            });
        },
        make_geo_features_layer(category_limit, geo_layer=null){
            if(!geo_layer){
                let geo_layer = {
                    type: "FeatureCollection",
                    features: [],
                };
            }
            geo_layer.category = category_limit;
            if(!this.geo_json){
                return geo_layer;
            }
            for(let feature of this.geo_json.features){
                if(feature.category != category_limit){
                    continue;
                }
                geo_layer.features.push(feature);
            }
            return geo_layer;
        },
        make_generic_feature_popup(feature){
            if(!feature.hasOwnProperty('properties')){
                return '';
            }
            if(feature.properties.length < 1){
                return '';
            }
            var prop_content = [];
            for (var prop in feature.properties) {
                let prop_str = this.add_links(feature.properties[prop]);
                prop_content.push(
                    `<dl class="row">
                    <dt class="col">${prop}</dt>
                    <dd class="col">${prop_str}</dd>
                    </dl>
                    `
                );
            }
            var all_props = prop_content.join('\n');
            var popup_content = (
                `<div class="container geo_feature_popup">${all_props}</div>`
            );
            return popup_content;
        },
        make_item_feature_popup(feature){
            if(!this.item_json){
                return '';
            }
            return (
                `<dl class="row">
                <dt class="col">Item</dt>
                <dd class="col">${this.item_json.label}</dd>
                </dl>`
            );
        },
        make_feature_popup(feature){
            if(this.map_type == 'generic' || !this.item_json){
                return this.make_generic_feature_popup(feature);
            }
            return this.make_item_feature_popup(feature);
        },
        make_generic_feature_tooltip(feature){
            if(!feature.hasOwnProperty('properties')){
                return '';
            }
            if(feature.properties.length < 1){
                return '';
            }
            let act_prop_val = null;
            for (var prop in feature.properties) {
                act_prop_val = {k: prop, v:feature.properties[prop]};
                break;
            }
            if(!act_prop_val){
                return '';
            }
            return `<div>${act_prop_val.k}: ${act_prop_val.v}</div>`;
        },
        make_item_feature_tooltip(feature){
            if(!this.item_json){
                return '';
            }
            return ("<div>" + item_json.label + "</div>");
        },
        make_feature_tooltip(feature){
            if(this.map_type == 'generic' || !this.item_json){
                return this.make_generic_feature_tooltip(feature);
            }
            return this.make_item_feature_tooltip(feature);
        },
        gather_base_layers: function(){
            if(!this.map){
                return null;
            }
            for(tp of this.tileProviders){
                let tile_key = 'map-tile-' + this.ref_suffix + '-' + tp.name;
                if(this.$refs[tile_key] == null){
                    console.log('no basemap with key: ' + tile_key);
                    continue;
                }
                this.base_layers[tp.name] = this.$refs[tile_key][0].mapObject;
            }
        },
        add_google_tiles: function() {
            if(this.added_google_tiles){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(this.$refs[this.l_controls_ref] == null){
                console.log('no item: ' + this.l_controls_ref);
                return null;
            }
            if(this.$refs[this.map_ref] == null){
                console.log('no item: ' + this.map_ref);
                return null;
            }
            console.log(this.map);
            for(let gtile_config of this.google_tile_configs){
                if(this.added_google_tile_types.indexOf(gtile_config.type) >= 0){
                    // Don't add the same layer twice!
                    continue;
                }
                let gtile = L.gridLayer.googleMutant(gtile_config);
                this.base_layers[gtile.options.name] = gtile;
                if(gtile_config.type == 'satellite'){
                    // Add support for over-zooming satellite.
                    this.map.addLayer(gtile);
                }
                this.$refs[this.l_controls_ref].mapObject.addBaseLayer(
                    gtile, gtile.options.name
                );
                this.added_google_tile_types.push(gtile_config.type);
            }
            this.added_google_tiles = true;
        },
        add_overlay_layers: function() {
            if(!this.geo_json){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(this.$refs[this.l_controls_ref] == null){
                console.log('no item: ' + this.l_controls_ref);
                return null;
            }

            this.geo_tile_facets = this.make_geo_features_layer(
                'oc-api:geo-facet', this.geo_tile_facets
            );
            this.geo_region_facets = this.make_geo_features_layer(
                'oc-api:geo-contained-in-feature', this.geo_region_facets
            );
            this.geo_page_records = this.make_geo_features_layer(
                'oc-api:geo-record', this.geo_page_records
            );

            console.log(
                this.geo_tile_facets.category + 
                ' has ' + 
                this.geo_tile_facets.features.length
            );
            console.log(
                this.geo_region_facets.category + 
                ' has ' + 
                this.geo_region_facets.features.length
            );
            console.log(
                this.geo_page_records.category + 
                ' has ' + 
                this.geo_page_records.features.length
            );
            let overlays = [];
            if(this.geo_tile_facets.features.length > 0){
                overlays.push(this.geo_tile_facets);
            }
            if(this.geo_region_facets.features.length > 0){
                overlays.push(this.geo_region_facets);
            }
            if(this.geo_page_records.features.length > 0){
                overlays.push(this.geo_page_records);
            }
            if(this.geo_all_records.features.length > 0){
                overlays.push(this.geo_all_records);
            }
            if(overlays.length < 1){
                return null;
            }
            for(let act_geojson of overlays){
                let act_layer = L.geoJson(
                    act_geojson,
                    {
                        onEachFeature: this.onEachFeatureFunction,
                    },
                );
                act_layer.addTo(this.map, act_geojson.label);
                this.$refs[this.l_controls_ref].mapObject.addOverlay(
                    act_layer, 
                    act_geojson.label
                );
                if(!this.act_overlay_layer){
                    let l_geo_json = this.$refs[this.geojson_ref];
                    if(l_geo_json){
                        this.map.removeLayer(l_geo_json);
                    }
                    this.map.addLayer(act_layer);
                    this.act_overlay_layer = act_layer;
                }
            }
        },
        geo_view_from_state_obj: function(frag_obj){
            if(!frag_obj){
                return null;
            }
            frag_obj.center = null;
            frag_obj.zoom = null;
            if(frag_obj.hasOwnProperty('zm') && frag_obj.hasOwnProperty('lat') && frag_obj.hasOwnProperty('lng')){
                let zoom = parseInt(frag_obj.zm, 10);
                let lat = parseFloat(frag_obj.lat);
                let lng = parseFloat(frag_obj.lng);
                if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) {
                    frag_obj.center = null;
                }
                else{
                    frag_obj.center = new L.LatLng(lat, lng);
                    frag_obj.zoom = zoom;
                }
            }
            return frag_obj;
        },
        finese_item_view: function(){
            if(!this.map){
                return null;
            }
            if (this.map_type == 'search'){
                return null;
            }
            if(!('features' in this.geo_json)){
                return null;
            }
            if(this.geo_json.features.length > 1){
                return null;
            }
            if(this.geo_json.features[0].geometry.type != 'Point'){
                console.log('Use extent derived zoom for ' + this.geo_json.features[0].geometry.type);
                return null;
            }
            let zoom = this.default_zoom;
            if(this.map_type in this.map_type_default_zooms){
                zoom = this.map_type_default_zooms[this.map_type];
            }
            let center = this.map.getCenter();
            this.map.setView(center, zoom);
        },
        fit_bounds: function(){
            if(!this.geo_json && GEO_JSON != null){
                this.geo_json = GEO_JSON;
            }
            if(!this.map){
                return null;
            }
            let l_geo_json = null;
            if(this.act_overlay_layer != null){
                l_geo_json = this.act_overlay_layer;
            }
            else{
                l_geo_json = this.$refs[this.geojson_ref];
                if(l_geo_json == null){
                    console.log('no geo-json layer item: ' + this.geojson_ref);
                    return null;
                }
            }
            if(l_geo_json == null){
                console.log('no overlay layer for fitbounds');
                return null;
            }
            let frag_obj = this.geo_view_from_state_obj(this.frontend_state_obj);
            if (this.map_type == 'search' && frag_obj != null && frag_obj.center != null) {
                this.map.auto_fit = false;
                this.map.setView(frag_obj.center, frag_obj.zoom);  
            }
            else{
                this.map.auto_fit = true;
                let bounds = l_geo_json.getBounds();
                this.map.fitBounds(bounds);
                console.log(bounds);
            }
            this.map._layersMaxZoom = MAX_ZOOM;
            this.map.auto_fit = false;
        },
        ready_map_setup: function(){
            this.map = this.$refs[this.map_ref].mapObject;
            this.map.auto_fit = true;
            this.gather_base_layers();
            this.add_google_tiles();
            this.get_item_location_info();
            this.add_search_map_hash();
            this.add_search_map_extra_controls();
            this.add_overlay_layers();
            this.fit_bounds();
            this.finese_item_view();
            this.map.auto_fit = false;
        },
        map_size_reset: function(){
            if(!this.geo_json && GEO_JSON != null){
                this.geo_json = GEO_JSON;
            }
            setTimeout(() => {
                // wait a bit so the geojson layer is available.
                this.$refs[this.map_ref].mapObject.invalidateSize();
            }, 50);
        },
        get_item_location_info: function() {
            if(!this.geo_json || !this.item_json){
                return null;
            }
            for(let feat of this.geo_json.features){
                if(!feat.hasOwnProperty('properties')){
                    continue;
                }
                if(!feat.properties.hasOwnProperty('href')){
                    continue;
                }
                if(feat.properties.href != this.item_json.id){
                    continue;
                }
                if(feat.properties.hasOwnProperty('location_precision_factor')){
                    this.location_precision_factor = feat.properties.location_precision_factor;
                }
                if(feat.properties.hasOwnProperty('location_precision_note')){
                    this.location_precision_note = feat.properties.location_precision_note;
                }
            }
        },
        update_map_setup: function(){
            this.map_size_reset();
            this.fit_bounds();
            this.finese_item_view();
            this.get_item_location_info();
            console.log('updated map');
        },
        fetch_geojson: function() {
            if(!this.geo_json_url){
                return null;
            }
            if(this.geo_json){
                return null;
            }
            console.log('fetch geojson from: ' + this.geo_json_url);
            const requestOptions = {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json, application/geo+json, application/vnd.geo+json,',
                    },
                };
            fetch(
                (this.geo_json_url), 
                requestOptions,
            )
            .then(this.loading = false)
            .then(response => response.json())
            .then(json => {
                this.geo_json = json;
                console.log('fetched geojson');
            });
        },
    },
    components: {
      'l-popup': l_popup,
      'l-img-overlay' : l_img_overlay,
      'l-tile-layer': l_tile_layer,
      'l-geo-json': l_geo_json,
      'l-marker': l_marker,
      'l-map': l_map,
    },
});




/* TODO: https://www.patrick-wied.at/static/heatmapjs/example-heatmap-leaflet.html */









</script>



{% endblock %}