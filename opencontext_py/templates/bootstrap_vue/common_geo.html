{% block common_geo %}

{% load humanize %}

{% include './common_map_constants.html' %}

<script type="text/x-template" id="map_color_ui">
    <b-modal
        size="lg"
        scrollable
        class="color-ui-modal"
        ref="map-color-modal"
        id="map-color-modal"
        title="Change Map Visualization Colors"
        @shown="on_shown"
    >
        <p><small>Select a color gradient option to use in map data visualizations. Different
            color options may be more effective than others depending on your selection of
            basemap layers, underlying patterns in the data, your sensitivity to
            various colors, and aesthetic preferences.
        </small></p>

        <color-gradient-ui
            v-bind:selected_gradient_key="selected_gradient_key"
            @set_selected_gradient_key="set_selected_gradient_key"
        >
        </color-gradient-ui>

        <template #modal-footer="{ ok, cancel, hide }">
            <b-button size="sm" variant="outline-secondary" @click="hide('map-color-modal')">
              Cancel
            </b-button>
          </template>
    </b-modal>
</script>



<script type="text/x-template" id="map_legends">
    <b-card v-if="legends"
        border-variant="secondary"
        header-border-variant="secondary"
        header="Map Data Visualization Legend"
        id="map-datavis-legend"
    >
        <b-list-group flush>
            <b-list-group-item v-for="(legend, index) in legends" class="map-overlay-legend-item">
                <b-row align-v="center">
                    <b-col lg="3">
                        <small>
                            <b-avatar
                            v-if="legend.icon"
                            :aria-label="'Icon for ' + legend.label"
                            rounded="sm"
                            variant="light"
                            v-html="legend.icon">
                        </b-avatar>
                            <strong>[[ legend.label ]]</strong>
                            <span v-if="legend.label_edit_ok">
                                <b-button size="sm" :id="'popover-target-' + legend.ov_id" variant="light"><b-icon-pencil-square></b-icon-pencil-square></b-button>
                                <b-popover :target="'popover-target-' + legend.ov_id" triggers="hover" placement="topright">
                                    <template #title>Edit downloaded layer label</template>

                                    <b-form-input
                                        debounce="100"
                                        @change="update_layer_label(legend)"
                                        type="text"
                                        v-model="edit_label"
                                        :value="legend.label"></b-form-input>
                                </b-popover>
                            </span>
                        </small>
                    </b-col>
                    <b-col>
                        <b-container fluid v-if="legend.poly_list">
                            <b-row align-h="center" align-v="center">
                                <b-col sm v-for="(sqr, c_index) in legend.poly_list" class="text-center">
                                    <svg width="25" height="25">
                                        <rect x="0" y="0" width="25" height="25" :style="sqr.svg_style" />
                                    </svg><br/>
                                    <small class="text-center">[[ sqr.count ]]</small>
                                </b-col>
                            </b-row>
                        </b-container>

                        <div v-if="legend.circle_list">
                            <b-row align-h="center" align-v="center">
                                <b-col sm v-for="(crc, c_index) in legend.circle_list" class="text-center">
                                    <svg :height="(crc.radius * 2) + 4" :width="(crc.radius * 2) + 4">
                                        <circle :cx="crc.radius + 2" :cy="crc.radius + 2" :r="crc.radius" :style="crc.svg_style" />
                                    </svg><br/>
                                    <small class="text-center">[[ crc.count ]]</small>
                                </b-col>
                            </b-row>
                        </div>

                        <div v-if="legend.heat_style">
                            <b-row align-h="center">
                                <b-col>
                                    <div :style="legend.heat_style"></div>
                                </b-col>
                            </b-row>
                            <b-row align-h="center">
                                <b-col class="text-left">
                                    <small>[[ legend.min_count ]]</small>
                                </b-col>
                                <b-col class="text-right">
                                    <small>[[ legend.max_count ]]</small>
                                </b-col>
                            </b-row>
                        </div>

                        <div v-if="legend.type == 'record'">
                            <b-row>
                                <b-col cols="3" class="text-center">
                                    <svg :height="(legend.crc.radius * 2) + 4" :width="(legend.crc.radius * 2) + 4">
                                        <circle :cx="legend.crc.radius + 2" :cy="legend.crc.radius + 2" :r="legend.crc.radius" :style="legend.crc.svg_style" />
                                    </svg><br/>
                                    <small>Item marker</small>
                                </b-col>
                                <b-col cols="9">
                                    <small v-if="legend.totalResults"><strong>[[ legend.totalResults ]]</strong> downloaded records temporarily
                                    stored in your browser's memory. If you reload or navigate away from this page, you will need to download these records again.
                                    </small>
                                </b-col>
                            </b-row>
                        </div>

                    </b-col>
                </b-row>
                <b-row v-if="legend.circle_list">
                    <b-col>
                        <small><em>
                            Circle markers aggregate counts from up to 4 adjacent regions,
                            so the maximum value of a circle marker may differ from other visualization layers.
                        </em>
                        </small>
                    </b-col>
                </b-row>
                <b-row v-if="legend.heat_style">
                    <b-col>
                        <small><em>
                            When the <b>Heatmap</b> visualization is active, you will not be able to click on features
                            in other layers.
                        </em>
                        </small>
                    </b-col>
                </b-row>

            </b-list-group-item>
        </b-list-group>
    </b-card>
</script>



<script type="text/x-template" id='common_map'>
    <div>
        <l-map
            v-if="geo_json"
            @ready="ready_map_setup"
            :class="map_class"
            :style="'min-height: ' + min_height + 'px;'"
            :ref="'map-' + ref_suffix"
            :zoom="11"
            :load-tiles-while-animating="true"
            :load-tiles-while-interacting="true">
            <l-control-layers
                :ref="'map-l-controls-' + ref_suffix"
                position="topright"></l-control-layers>
            <l-tile-layer
                v-for="tp in tileProviders"
                :ref="'map-tile-' + ref_suffix + '-' + tp.name"
                :key="tp.name"
                :name="tp.name"
                :visible="tp.visible"
                :url="tp.url"
                :attribution="tp.attribution"
                :maxZoom="tp.maxZoom"
                :maxNativeZoom="tp.maxNativeZoom"
                layer-type="base"></l-tile-layer>
            <l-img-overlay
                v-if="geo_overlays"
                v-for="ov in geo_overlays"
                :key="ov.id"
                :alt="ov.id"
                :ref="'map-image-overlay-' + ov.id + '-' + ref_suffix"
                :name="ov.label"
                :visible="ov.visible"
                :url="ov.url"
                :attribution="ov.attribution"
                :bounds="ov.bounds"
                layer-type="overlay"
            ></l-img-overlay>
            <l-geo-json
                v-if="show_default_overlay"
                :key="'map-geojson-' + ref_suffix + '-' + map_key"
                :ref="'map-geojson-' + ref_suffix"
                :options="options"
                v-bind:geojson="geo_json"
            >
            <l-popup></l-popup>
            </l-geo-json>
        </l-map>
        <div v-else class="text-center mb-3 d-flex justify-content-between">
            <b-spinner
                variant="primary"
                style="width: 3rem; height: 3rem;" label="Large Spinner"></b-spinner>
        </div>
        <div v-if="location_precision_note">
            <b-alert v-if="location_precision_factor" show variant="warning">
              <small>[[location_precision_note]]</small>
            </b-alert>
            <b-alert v-else show variant="info">
              <small>[[location_precision_note]]</small>
            </b-alert>
        </div>
        <div v-if="map_type == 'search'">
            <map-color-ui
                v-bind:selected_gradient_key="selected_gradient_key"
                @set_selected_gradient_key="set_selected_gradient_key"
            ></map-color-ui>
            <map-legends
                :key="legend_key"
                @update_layer_label="update_layer_label($event)"
                v-bind:legends="map_legends"></map-legends>
        </div>
    </div>
</script>


<script type="text/javascript">

// URL updating for Map view state.
(function(window) {
    var HAS_HASHCHANGE = (function() {
        var doc_mode = window.documentMode;
        return ('onhashchange' in window) &&
            (doc_mode === undefined || doc_mode > 7);
    })();

    L.Hash = function(map) {
        this.tile_zoom = false;
        this.onHashChange = L.Util.bind(this.onHashChange, this);

        if (map) {
            this.init(map);
        }
    };

    L.Hash.prototype = {
        map: null,
        lastHash: null,
        frontend_state_obj: null,
        update_map_frontend_state_obj: null,
        update_base_layer: null,

        contains: function(a, obj) {
            var i = a.length;
            while (i--) {
               if (a[i] === obj) {
                   return true;
               }
            }
            return false;
        },

        prep_geo_from_state_obj: function(frag_obj){
            frag_obj.center = null;
            frag_obj.zoom = null;
            if(frag_obj.hasOwnProperty('zm') && frag_obj.hasOwnProperty('lat') && frag_obj.hasOwnProperty('lng')){
                let zoom = parseInt(frag_obj.zm, 10);
                let lat = parseFloat(frag_obj.lat);
                let lng = parseFloat(frag_obj.lng);
                if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) {
                    frag_obj.center = null;
                }
                else{
                    frag_obj.center = new L.LatLng(lat, lng);
                    frag_obj.zoom = zoom;
                }
            }
            if(frag_obj.hasOwnProperty('bm') && frag_obj.bm != null){
                this.update_base_layer(frag_obj.bm.replace('_', ' '));
            }
            return frag_obj;
        },

        parseHash: function(hash) {
            let frag_obj = parse_search_frag_dict(hash);
            return this.prep_geo_from_state_obj(frag_obj);
        },

        compose_new_frontend_state: function(map){
            let frag_obj = this.frontend_state_obj;
            // console.log('composing new map frontend state');
            // console.log(frag_obj);
            let center = this.map.getCenter();
            let zoom = this.map.getZoom();
            let precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));

            frag_obj.zm = zoom;
            frag_obj.lat = center.lat.toFixed(precision);
            frag_obj.lng = center.lng.toFixed(precision);
            if(Math.round(frag_obj.lat, 1) == 0 && Math.round(frag_obj.lng, 1) == 0){
                console.log('Bad coordinates do not update');
                delete frag_obj.zm;
                delete frag_obj.lat;
                delete frag_obj.lng;
            }
            if(this.map.baselayer_name){
                frag_obj.bm = this.map.baselayer_name.replace(' ' , '_');
            }
            if(this.map.hasOwnProperty('visible_overlay_ids')){
                if(this.map.visible_overlay_ids.length > 0){
                    frag_obj.ov = this.map.visible_overlay_ids;
                }
            }
            return frag_obj;
        },

        formatHash: function(frag_obj) {
            let frag_str = encode_frag_obj(frag_obj);
            return '#' + frag_str;
        },

        init: function(map) {
            this.map = map;
            this.map.on("moveend", this.onMapMove, this);
            // reset the hash
            this.lastHash = null;
            this.onHashChange();
            if (!this.isListening) {
                this.startListening();
            }
        },

        remove: function() {
            this.map = null;
            if (this.isListening) {
                this.stopListening();
            }
        },

        update_new_fontend_state: function(frag_obj){
            // Updates the frontend state for all vue components.
            if(frag_obj.hasOwnProperty('center')){
                delete frag_obj.center;
            }
            if(frag_obj.hasOwnProperty('zoom')){
                delete frag_obj.zoom;
            }
            let hash = this.formatHash(frag_obj);
            if (this.lastHash != hash) {
                this.update_map_frontend_state_obj(frag_obj);
                this.lastHash = hash;
                return true;
            }
            return false;
        },

        forceHashChange: function(map) {
            // change the hash, in response to changes
            // in base layers
            if(this.map.auto_fit){
                return false;
            }
            let frag_obj = this.compose_new_frontend_state(map);
            this.update_new_fontend_state(frag_obj);
        },

        onMapMove: function(map) {
            // bail if we're moving the map (updating from a hash),
            // or if the map has no zoom set

            if (this.movingMap || this.map.getZoom() === 0) {
                return false;
            }
            if(this.map.auto_fit){
                return false;
            }
            let frag_obj = this.compose_new_frontend_state(map);
            this.update_new_fontend_state(frag_obj);
        },

        movingMap: false,
        update: function() {
            let parsed = this.prep_geo_from_state_obj(this.frontend_state_obj);
            if (parsed != null && parsed.center != null) {
                // console.log("parsed:", parsed.zoom, parsed.center.toString());
                this.movingMap = true;
                this.map.setView(parsed.center, parsed.zoom);
                this.movingMap = false;
            } else {
                // console.warn("parse error; resetting:", this.map.getCenter(), this.map.getZoom());
                this.onMapMove(this.map);
            }
        },

        // defer hash change updates every 100ms
        changeDefer: 100,
        changeTimeout: null,
        onHashChange: function() {
            // throttle calls to update() so that they only happen every
            // `changeDefer` ms
            if (!this.changeTimeout) {
                var that = this;
                this.changeTimeout = setTimeout(function() {
                    that.update();
                    that.changeTimeout = null;
                }, this.changeDefer);
            }
        },

        isListening: false,
        hashChangeInterval: null,
        startListening: function() {
            if (HAS_HASHCHANGE) {
                L.DomEvent.addListener(window, "hashchange", this.onHashChange);
            } else {
                clearInterval(this.hashChangeInterval);
                this.hashChangeInterval = setInterval(this.onHashChange, 50);
            }
            this.isListening = true;
        },

        stopListening: function() {
            if (HAS_HASHCHANGE) {
                L.DomEvent.removeListener(window, "hashchange", this.onHashChange);
            } else {
                clearInterval(this.hashChangeInterval);
            }
            this.isListening = false;
        }
    };
})(window);


var vc_map_color_ui = Vue.component(
    'map-color-ui',
    {
        delimiters: ['[[', ']]'],
        props: ['selected_gradient_key', ],
        data() {
            return {
                selected_gradient_key: MAP_DEFAULT_COLOR_GRADIENT_KEY,
            };
        },
        template: '#map_color_ui',
        methods: {
            on_shown(){
                console.log('Show map color ui');
            },
            set_selected_gradient_key(gradient_key){
                this.selected_gradient_key = gradient_key;
                this.$emit('set_selected_gradient_key', this.selected_gradient_key);
            },
        },
        components: {
            'color-gradient-ui': vc_color_gradient_ui,
        }
    }
);


var vc_map_legends = Vue.component(
    'map-legends',
    {
        delimiters: ['[[', ']]'],
        props: ['legends', ],
        data() {
            return {
                legends: null,
                edit_label: null,
            };
        },
        template: '#map_legends',
        methods: {
            update_layer_label: function(legend){
                console.log('updating label to ' + this.edit_label);
                console.log(legend);
                if(!this.edit_label){
                    return null;
                }
                if(!legend.hasOwnProperty('label_edit_ok')){
                    // not a download layer, can't edit
                    return null;
                }
                if(!legend.label_edit_ok){
                    // not a download layer, can't edit
                    return null;
                }
                if(legend.label == this.edit_label){
                    return null;
                }
                if(this.edit_label.length < 1){
                    return null;
                }
                legend.label = this.edit_label;
                this.$emit('update_layer_label', legend);
            }
        },
        components: {

        }
    }
);


var vc_common_map = Vue.component(
  'common_map',
  {
    props: [
        'uuid',
        'map_key',
        'ref_suffix',
        'geo_json_url',
        'geo_json',
        'geo_overlays',
        'item_json',
        'map_type',
        'map_class',
        'min_height',
        'route_key_index',
        'frontend_state_obj',
        'show_default_overlay',
        'geojson_record_layers',
        'result_count_human',
    ],
    data() {
        return {
            // Map Options
            uuid: null,
            map: null,
            map_key: 0,
            ref_suffix: '-map',
            legend_key: this.map_key + '-legend',
            zoom_def: 13,
            base_layers: {},
            selectedTileSet: TILE_PROVIDERS[0],
            tileProviders: TILE_PROVIDERS,
            google_tile_configs: GOOGLE_TILE_CONFIGS,
            map_scale: null,
            added_google_tiles: false,
            added_google_tile_types: [],
            minZoom_def: 1,
            maxZoom_def: MAX_ZOOM,
            show_mapsets_default: true,
            center: null,
            result_count_human: null,
            geo_json_url: null,
            geo_json: null,
            geo_overlays: null,
            location_precision_factor: null,
            location_precision_note: null,
            item_geo_zoom: null,
            item_json: null,
            map_type: 'generic',
            map_class: 'item',
            min_height: 300,
            route_key_index: 0,
            frontend_state_obj: {},
            map_hash_obj: null,
            baselayer_name: null,
            default_zoom: 11,
            map_type_default_zooms: {
                item: 16,
                generic: 12,
            },
            map_scale_options: {
                metric: true,
                imperial: true,
                maxWidth: 240,
                position: 'bottomleft',
            },
            geojson_record_layers: null,
            default_tilelayer_name: DEFAULT_TILELAYER_NAME,
            // default_tilelayer_name: 'Google Aerial',
            geo_tile_facets: null,
            geo_region_facets: null,
            geo_page_records: null,
            geo_all_records: null,
            heatmap_data: null,
            overlay_icons: {
                sqr: '<span class="cntrl-icons material-icons-two-tone">grid_on</span>',
                sqr_hr: '<span class="cntrl-icons material-icons-two-tone">grid_on</span>',
                sqr_lr: '<span class="cntrl-icons material-icons-two-tone">window</span>',
                crc: '<span class="cntrl-icons material-icons">circle</span>',
                heat: '<span class="cntrl-icons material-icons">thermostat</span>',
                color: '<span class="cntrl-icons material-icons-two-tone">palette</span>',
            },
            ios_safari_overlay_icons: {
                sqr: '<span class="ios-cntrl-icons material-icons">grid_on</span>',
                sqr_hr: '<span class="ios-cntrl-icons material-icons">grid_on</span>',
                sqr_lr: '<span class="ios-cntrl-icons material-icons">window</span>',
                crc: '<span class="ios-cntrl-icons material-icons">circle</span>',
                heat: '<span class="ios-cntrl-icons material-icons">thermostat</span>',
                color: '<span class="ios-cntrl-icons material-icons">palette</span>',
            },
            ios_overlay_icons: {
                sqr: '<span class="ios-cntrl-icons material-icons">grid_on</span>',
                sqr_hr: '<span class="ios-cntrl-icons material-icons">grid_on</span>',
                sqr_lr: '<span class="ios-cntrl-icons material-icons">window</span>',
                crc: '<span class="ios-cntrl-icons material-icons">circle</span>',
                heat: '<span class="ios-cntrl-icons material-icons">thermostat</span>',
                color: '<span class="ios-cntrl-icons material-icons">palette</span>',
            },
            safari_overlay_icons: {
                sqr: '<span class="cntrl-icons material-icons">grid_on</span>',
                sqr_hr: '<span class="cntrl-icons material-icons">grid_on</span>',
                sqr_lr: '<span class="cntrl-icons material-icons">window</span>',
                crc: '<span class="cntrl-icons material-icons">circle</span>',
                heat: '<span class="cntrl-icons material-icons">thermostat</span>',
                color: '<span class="cntrl-icons material-icons">palette</span>',
            },
            geo_tile_facets_default: {
                type: "FeatureCollection",
                label: "Area counts (squares)",
                ov_id: 'sqr',
                ref: "map-tile-geojson-" + this.ref_suffix,
                min_count: null,
                max_count: null,
                legend: null,
                features: [],
            },
            geo_facets_circles_default: {
                type: "FeatureCollection",
                label: "Area counts (circles)",
                ov_id: 'crc',
                ref: "map-circle-geojson-" + this.ref_suffix,
                min_count: null,
                max_count: null,
                legend: null,
                features: [],
            },
            geo_region_facets_default: {
                type: "FeatureCollection",
                label: "Context summary",
                ov_id: 'cntx',
                ref: "map-region-geojson-" + this.ref_suffix,
                min_count: null,
                max_count: null,
                legend: null,
                features: [],
            },
            geo_page_records_default: {
                type: "FeatureCollection",
                label: "Records (current page)",
                ov_id: 'pg-recs',
                ref: "map-page-recs-geojson-" + this.ref_suffix,
                legend: null,
                features: [],
            },
            default_ov_ids: ['sqr', 'crc', 'cntx', 'heat', 'pg-recs'],
            heatmap_data_default: {
                label: "Area counts (heatmap)",
                ov_id: 'heat',
                ref: "map-heatmap-" + this.ref_suffix,
                max: null,
                legend: null,
                data: [],
            },
            heatmap_config: {
                "radius": 40,
                "useLocalExtrema": false,
                latField: 'lat',
                lngField: 'lng',
                valueField: 'count',
            },
            show_default_overlay: true,
            selected_gradient_key: MAP_DEFAULT_COLOR_GRADIENT_KEY,
            // relative influence of percentile rankings for determining visualization color.
            // a positive value here shows more detail in cases where a few high values obscure variation in lower values
            percentile_color_influence: 0.175,
            legend_config: {
                poly_list: null,
                circle_list: null,
                heat_style: null,
            },
            route_map_legends: {},
            map_legends: null,
        };
    },
    template: '#common_map',
    delimiters: ['[[', ']]'],
    created(){
        this.fetch_geojson();
    },
    mounted(){
        this.fetch_geojson();
    },
    updated(){
        this.update_map_setup();
    },
    computed: {
        map_ref(){return 'map-' + this.ref_suffix},
        l_controls_ref(){return 'map-l-controls-' + this.ref_suffix},
        geojson_ref(){return 'map-geojson-' + this.ref_suffix},
        options() {
            return {
                onEachFeature: this.onEachFeatureFunction
            };
        },
        onEachFeatureFunction() {
            return (feature, layer) => {
                let popup_content = this.make_feature_popup(feature);
                let tooltip_content = this.make_feature_tooltip(feature);
                if(this.map_class == 'map_preview' && this.map_type != 'search'){
                    layer.bindPopup(popup_content, {minWidth: 300});
                }
                else{
                    layer.bindPopup(popup_content);
                }
                layer.bindTooltip(
                    tooltip_content,
                    { permanent: false, sticky: true }
                );
            };
        },
    },
    methods: {
        // Utility functions for search map interface
        iOS: function() {
            return [
                'iPad Simulator',
                'iPhone Simulator',
                'iPod Simulator',
                'iPad',
                'iPhone',
                'iPod'
            ].includes(navigator.platform)
            // iPad on iOS 13 detection
            || (navigator.userAgent.includes("Mac") && "ontouchend" in document)
        },
        isSafari: function(){
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            return isSafari;
        },
        util_search_map_ok: function(){
            if(this.map_type != 'search'){
                return false;
            }
            if(!this.map){
                return false;
            }
            return true;
        },
        util_search_map_ok_with_props: function(prop_list){
            if(!this.util_search_map_ok()){
                return false;
            }
            for(let prop of prop_list){
                if(!this.map.hasOwnProperty(prop)){
                    return false;
                }
            }
            return true;
        },
        round_value(val, min_increment){
            let n_val = parseFloat(val);
            let rounded = n_val + min_increment/2 - (n_val + min_increment/2) % min_increment;
            return rounded;
        },
        add_links(str){
            if (!(typeof str === 'string' || str instanceof String)){
                return str;
            }
            if(str.startsWith("https://")||str.startsWith("http://")){
                return `<a target="_blank" href="${str}">${str}</a>`;
            }
            return str;
        },
        update_router: function(url){
            let hash = '';
            if(window.location.hash) {
                hash = '#' + window.location.hash.substring(1); //Puts hash in variable, and removes the # character
            }
            if(url.indexOf(hash) < 0){
                url += hash;
            }
            url = abs_to_rel_url(url, BASE_URL);
            router.push(url);
        },
        update_geodeep: function(geodeep){
            if(!this.geo_json){
                return null;
            }
            let current_url = this.geo_json.id;
            let url = replaceURLparameter(current_url, 'geodeep', geodeep);
            this.update_router(url);
        },
        update_with_bbox_query: function(bbox_query){
            if(!this.geo_json){
                return null;
            }
            let current_url = this.geo_json.id;
            let frontend_state_obj = JSON.parse(JSON.stringify(this.frontend_state_obj));
            frontend_state_obj.zm = null;
            frontend_state_obj.lat = null;
            frontend_state_obj.lng = null;
            let hash = encode_frag_obj(frontend_state_obj);
            let url = replaceURLparameter(current_url, 'bbox', bbox_query);
            url += '#' + hash;
            url = abs_to_rel_url(url, BASE_URL);

            if(this.route_map_legends == null){
                this.route_map_legends = {};
            }
            for([key, val] of Object.entries(this.route_map_legends)){
                delete this.route_map_legends[key];
            }
            this.map_legends = [];
            router.push(url);
        },
        get_current_geo_json_id: function(){
            if(this.geo_json){
                if(this.geo_json.hasOwnProperty('id')){
                    return this.geo_json.id;
                }
            }
            return null;
        },
        get_centroid: function(arr) {
            // get the centroid of a polygon
            if(arr[0] == arr[1]){
                arr.pop();
            }
            return arr.reduce(function (x,y) {
                return [x[0] + y[0]/arr.length, x[1] + y[1]/arr.length]
            }, [0,0]);
        },
        update_map_frontend_state_obj(frontend_state_obj) {
            if(frontend_state_obj.hasOwnProperty('ov')){
                if(isArray(frontend_state_obj.ov)){
                    frontend_state_obj.ov = [...new Set(frontend_state_obj.ov)];
                }
            }
            this.frontend_state_obj = frontend_state_obj;
            this.$emit('set_frontend_state_obj', frontend_state_obj);
            this.delayed_update_map_legends();
        },
        update_base_layer(baselayer_name){
            if(!this.map){
                return null;
            }
            if(!(baselayer_name in this.base_layers)){
                console.log('Cannot find baselayer: ' + baselayer_name);
                return null;
            }
            for(let name_key in this.base_layers){
                let act_layer = this.base_layers[name_key];
                if(name_key == baselayer_name){
                    this.map.addLayer(act_layer);
                }
                else{
                    this.map.removeLayer(act_layer);
                }
            }
            let new_tile_state_list = [];
            for(tp of this.tileProviders){
                tp.visible = false;
                if(tp.name == baselayer_name){
                    tp.visible = true;
                    this.selectedTileSet = tp;
                }
                new_tile_state_list.push(tp);
            }
            this.tileProviders = new_tile_state_list;
            this.map.baselayer_name = baselayer_name;
        },
        show_map_color_ui: function(){
            this.$bvModal.show('map-color-modal');
        },
        make_heatmap_gradient_config: function(gradient_key){
            if(!COLOR_GRADIENTS.hasOwnProperty(gradient_key)){
                return null;
            }
            let act_gradient = COLOR_GRADIENTS[gradient_key];
            let heat_gradient = {};
            for(let conf of act_gradient){
                let v_val = conf.v;
                if(v_val < 0.01){
                    v_val = 0.01;
                }
                let v_key = '' + v_val;
                heat_gradient[v_key] = conf.color;
            }
            return heat_gradient;
        },
        delayed_update_map_legends: function() {
            setTimeout(() => {
                this.update_map_legends();
            }, 250);
        },
        get_current_state_key: function(){
            // Use relevant parts of the current frontend object state
            // to track the state ff the legend. This means we won't make
            // a new legend everytime the map is panned or zoom levels change.
            // Only if the query changes or the overlays change will we update
            // the legends.
            let legend_ok_keys = ['ov', 'ovgrd',];
            let act_legend_state = {};
            for(let ok_key of legend_ok_keys){
                if(this.frontend_state_obj.hasOwnProperty(ok_key)){
                    act_legend_state[ok_key] = JSON.parse(JSON.stringify(this.frontend_state_obj[ok_key]));
                }else{
                    act_legend_state[ok_key] = null;
                }
            }
            let state_key = (
                this.$route.fullPath
                + '#'
                + encode_frag_obj(act_legend_state)
            );
            return state_key;
        },
        update_map_legends: function() {
            let req_props = ['overlay_layers_by_id', 'visible_overlay_ids'];
            if(!this.util_search_map_ok_with_props(req_props)){
                return null;
            }
            // Use relevant parts of the current frontend object state
            // to track the state ff the legend. This means we won't make
            // a new legend everytime the map is panned or zoom levels change.
            // Only if the query changes or the overlays change will we update
            // the legends.
            let state_key = this.get_current_state_key();
            if(this.route_map_legends == null){
                this.route_map_legends = {};
            }
            if(state_key in this.route_map_legends){
                if(this.route_map_legends[state_key].length > 0){
                    // console.log('Map legend state key already exists ' + state_key);
                    let prior_ok = true;
                    let geo_json_id = this.get_current_geo_json_id();
                    // console.log('current geo_json_id: ' + geo_json_id);
                    for(let legend of this.route_map_legends[state_key]){
                        // console.log(legend);
                        if(legend.hasOwnProperty('geo_json_id')){
                            // console.log('geo_json_id: ' + legend.geo_json_id + ' ' + geo_json_id);
                            if(legend.geo_json_id != geo_json_id){
                                prior_ok = false;
                            }
                        }
                    }
                    if(prior_ok){
                        // The prior layer legends are OK to use.
                        this.map_legends = this.route_map_legends[state_key];
                        return null;
                    }
                }
            }
            // console.log('Map legend state key is new');
            this.map_legends = [];
            let order_legends = JSON.parse(JSON.stringify(this.default_ov_ids));
            if(this.geojson_record_layers && this.geojson_record_layers.length > 0){
                for(let geo_rec_layer of this.geojson_record_layers){
                    order_legends.push(geo_rec_layer.ov_id);
                }
            }
            for(let ov_id of order_legends){
                if(this.map.visible_overlay_ids.indexOf(ov_id) < 0){
                    continue;
                }
                if(!this.map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                    continue;
                }
                let act_layer = this.map.overlay_layers_by_id[ov_id];
                if(!act_layer.hasOwnProperty('legend')){
                    continue;
                }
                if(act_layer.legend == null){
                    continue;
                }
                this.map_legends.push(JSON.parse(JSON.stringify(act_layer.legend)));
            }
            // console.log('update map legends, legends: ');
            // console.log(this.map_legends);
            this.route_map_legends[state_key] = this.map_legends;
        },
        set_selected_gradient_key(gradient_key){
            if(!this.util_search_map_ok()){
                return null;
            }
            if(!gradient_key in COLOR_GRADIENTS){
                // This key does not exist, skip out.
                return null;
            }
            // capture the visible overlay ids before we mess with the overlay layers.
            // we need to do this to solve wierd state crap that I don't understand.
            let act_visible_overlay_ids = JSON.parse(JSON.stringify(this.map.visible_overlay_ids));
            this.selected_gradient_key = gradient_key;
            this.frontend_state_obj.ovgrd = gradient_key;
            let frontend_state = JSON.parse(JSON.stringify(this.frontend_state_obj));
            frontend_state.ovgrd = gradient_key;
            this.update_map_frontend_state_obj(frontend_state);
            this.selected_gradient_key = gradient_key;
            this.frontend_state_obj.ovgrd = gradient_key;
            this.add_overlay_layers();
            // remember the overlay ids!
            this.map.visible_overlay_ids = act_visible_overlay_ids;
            setTimeout(() => {
                this.frontend_state_obj.ovgrd = gradient_key;
                this.frontend_obj_overlays_prep();
            }, 50);
            this.delayed_update_map_legends();
            this.$bvModal.hide('map-color-modal');
        },
        add_search_map_extra_controls: function() {
            if(!this.util_search_map_ok()){
                return null;
            }
            if(this.map.hasOwnProperty('search_map_extra_buttons')){
                return null;
            }
            if(!this.map.hasOwnProperty('geodeep')){
                this.map.geodeep = 11;
            }
            if(!this.map.hasOwnProperty('max_tile_zoom')){
                this.map.max_tile_zoom = MAX_ZOOM_TILES;
            }
            this.map.update_geodeep = this.update_geodeep;
            this.map.show_map_color_ui = this.show_map_color_ui;
            if(this.iOS() && this.isSafari()){
                console.log('Use iOS AND safari class for icons');
                this.map.overlay_icons = this.ios_safari_overlay_icons;
            }
            else if(this.iOS()){
                console.log('Use iOS class for icons');
                this.map.overlay_icons = this.ios_overlay_icons;
            }
            else if(this.isSafari()){
                console.log('Use safari class for icons');
                this.map.overlay_icons = this.safari_overlay_icons;
            }
            else{
                this.map.overlay_icons = this.overlay_icons;
            }
            this.map.deactivate_all_overlays_except = function(map, active_ov_id){
                if(!map.hasOwnProperty('overlay_layers_by_id')){
                    console.log('missing overlay_layers_by_id');
                    console.log(map);
                    return null;
                }
                map.visible_overlay_ids = [];
                for(let ov_id in map.overlay_layers_by_id){
                    if(!map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                        continue;
                    }
                    let act_layer = map.overlay_layers_by_id[ov_id];
                    if(active_ov_id == ov_id){
                        map.addLayer(act_layer);
                        map.visible_overlay_ids = [act_layer.ov_id];
                    }else{
                        act_layer.removeFrom(map);
                    }
                }
                if(map.hash_obj){
                    map.hash_obj.forceHashChange();
                }
            };
            this.map.add_search_map_extra_controls = function(map){
                let search_map_extra_controls = [];
                let deep_tile_control = L.easyButton(
                    map.overlay_icons.sqr_hr,
                    // the control for higher resolution region tiles
                    function (){
                        map.deactivate_all_overlays_except(map, 'sqr');
                        let new_geodeep = parseInt(map.geodeep) + 1;
                        if (new_geodeep <= map.max_tile_zoom) {
                            //can still zoom in
                            console.log('New higher tile zoom: ' + new_geodeep);
                            map.geodeep = new_geodeep;
                            map.update_geodeep(new_geodeep);
                        }
                    },
                    'Higher resolution summary regions',
                );
                let big_tile_control = L.easyButton(
                    map.overlay_icons.sqr_lr,
                    // control for lower resolution region tiles
                    function (){
                        map.deactivate_all_overlays_except(map, 'sqr');
                        let new_geodeep = map.geodeep - 1;
                        if (new_geodeep > 3) {
                            console.log('New lower tile zoom: ' + new_geodeep);
                            map.geodeep = new_geodeep;
                            map.update_geodeep(new_geodeep);
                        }
                    },
                    'Lower resolution summary regions',
                );
                let circle_control = L.easyButton(
                    map.overlay_icons.crc,
                    function (){
                        map.deactivate_all_overlays_except(map, 'crc');
                    },
                    'Circle-markers for summary regions',
                );
                let heat_control = L.easyButton(
                    map.overlay_icons.heat,
                    function (){
                        map.deactivate_all_overlays_except(map, 'heat');
                    },
                    'Heat-map visualization',
                );
                let color_control = L.easyButton(
                    map.overlay_icons.color,
                    function (){
                        map.show_map_color_ui();
                    },
                    'Map visualization colors',
                );
                map.search_map_extra_buttons = {
                    deep_tile_control: deep_tile_control,
                    big_tile_control: big_tile_control,
                    circle_control: circle_control,
                    heat_control: heat_control,
                    color_control: color_control,
                };
                search_map_extra_controls.push(deep_tile_control);
                search_map_extra_controls.push(big_tile_control);
                search_map_extra_controls.push(circle_control);
                search_map_extra_controls.push(heat_control);
                search_map_extra_controls.push(color_control);
                L.easyBar(search_map_extra_controls).addTo(map);
            }
            this.map.add_search_map_extra_controls(this.map);
            // console.log(this.map.search_map_extra_buttons);
            // console.log('added search controls');
        },
        geo_view_from_state_obj: function(raw_frag_obj){
            if(!raw_frag_obj){
                return null;
            }
            let frag_obj = JSON.parse(JSON.stringify(raw_frag_obj));
            frag_obj.center = null;
            frag_obj.zoom = null;
            if(frag_obj.hasOwnProperty('zm') && frag_obj.hasOwnProperty('lat') && frag_obj.hasOwnProperty('lng')){
                let zoom = parseInt(frag_obj.zm, 10);
                let lat = parseFloat(frag_obj.lat);
                let lng = parseFloat(frag_obj.lng);
                if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) {
                    frag_obj.center = null;
                }
                else{
                    frag_obj.center = new L.LatLng(lat, lng);
                    frag_obj.zoom = zoom;
                }
            }
            return frag_obj;
        },
        set_map_view_from_frontend_state_obj: function () {
            if(!this.util_search_map_ok()){
                return null;
            }
            let frag_obj = this.geo_view_from_state_obj(this.frontend_state_obj);
            console.log('frag obj geo view');
            console.log(frag_obj);
            if (this.map_type == 'search' && frag_obj != null && frag_obj.center != null) {
                console.log('Update map view from frontend state');
                this.map.auto_fit = false;
                this.map.setView(frag_obj.center, frag_obj.zoom);
                return true;
            }
            return false;
        },
        add_search_map_hash: function() {
            if(!this.util_search_map_ok()){
                return null;
            }
            this.map.visible_overlay_ids = [];
            let map_view_set = this.set_map_view_from_frontend_state_obj();
            this.map_hash_obj = new L.Hash(this.map);
            this.map_hash_obj.frontend_state_obj = this.frontend_state_obj;
            this.map_hash_obj.update_map_frontend_state_obj = this.update_map_frontend_state_obj;
            this.map_hash_obj.update_base_layer = this.update_base_layer;
            this.map.hash_obj = this.map_hash_obj;
            this.map.on('baselayerchange', function(e) {
                // when the base layer changes, keep the id
                this.baselayer_name = e.name;
                if(this.hash_obj){
                    this.hash_obj.forceHashChange();
                }
            });
            this.map.overlay_ready = false;
            this.map.on('overlayadd', function(e) {
                // Adding an overlay layer, note what layers are active
                if(!this.overlay_ready){
                    return null;
                }
                if(!e.hasOwnProperty('layer') || !e.layer.hasOwnProperty('ov_id')){
                    console.log('Image overlay, no state recording');
                    return null;
                }
                if(!e.layer.hasOwnProperty('legend') || e.layer.legend == null){
                    console.log('No legend, no state recording');
                    return null;
                }

                if(this.visible_overlay_ids.indexOf(e.layer.ov_id) < 0){
                    this.visible_overlay_ids.push(e.layer.ov_id);
                }
                else{
                    // Nothing changed so skip out.
                    return null;
                }
                if(this.hash_obj){
                    this.hash_obj.forceHashChange();
                }
            });
            this.map.on('overlayremove', function(e) {
                if(!this.overlay_ready){
                    return null;
                }
                /// Remove an overlay layer, note what layers are active
                if(!e.hasOwnProperty('layer') || !e.layer.hasOwnProperty('ov_id')){
                    console.log('Image overlay, no state recording');
                    return null;
                }
                let new_overlay_ids = [];
                for(let i =0; i < this.visible_overlay_ids.length; i++){
                    if(this.visible_overlay_ids[i] !== e.layer.ov_id){
                        new_overlay_ids.push(this.visible_overlay_ids[i]);
                    }
                }
                if(this.visible_overlay_ids.length <= new_overlay_ids.length){
                    // Nothing changed, so skip out.
                    return null;
                }
                this.visible_overlay_ids = new_overlay_ids;
                if(this.hash_obj){
                    this.hash_obj.forceHashChange();
                }
            });
        },
        get_percentile_of_val: function(act_array, val) {
            if (act_array.length === 0) return null;
            if (typeof val !== 'number') return null;
            let act_num = 0;
            for (let i in act_array) {
                act_num = (
                    act_num
                    + (act_array[i] < val ? 1 : 0)
                    + (act_array[i] === val ? 0.5 : 0)
                );
            }
            return (act_num / act_array.length);
        },
        cat_limit_feature_data(category_limit, feature_data=null){
            if(!feature_data){
                let feature_data = {
                    type: "FeatureCollection",
                    features: [],
                };
            }
            feature_data.category = category_limit;
            if(!this.geo_json){
                return feature_data;
            }
            let counts = [];
            for(let feature of this.geo_json.features){
                if(feature.category != category_limit){
                    continue;
                }
                feature_data.features.push(feature);
                if(feature.hasOwnProperty('count')){
                    counts.push(feature.count);
                }
            }
            if(counts.length > 0){
                // Add information needed to style features.

                feature_data.min_count = Math.min.apply(Math, counts);
                feature_data.max_count = Math.max.apply(Math, counts);
                feature_data.all_counts = counts.sort();
                let count_features = [];
                for(let feature of feature_data.features){
                    feature.max_count = feature_data.max_count;
                    feature.gradient_key = this.selected_gradient_key;
                    feature.percentile = this.get_percentile_of_val(counts, feature.count);
                    count_features.push(feature);
                }
                feature_data.features = count_features;
            }
            return feature_data;
        },
        make_area_count_feature_popup(feature){
            // for an area (count) aggregate summary feature
            if(!feature.hasOwnProperty('count')){
                return '';
            }
            if(!feature.hasOwnProperty('id')){
                return '';
            }
            let area_html =  (
                `<dl class="row">
                <dt class="col-5">Count of Records in this Area</dt>
                <dd class="col-7"><b>${feature.count}</b> of <b>${this.result_count_human}</b> total items</dd>
                </dl>
                <dl class="row">
                <dt class="col-5">Filter</dt>
                <dd class="col-7"><a href="${feature.id}">Query</a> to only include the ${feature.count} items within this area</dd>
                </dl>
                `
            );
            let popup_content = (
                `<div class="container geo_feature_popup">${area_html}</div>`
            );
            return popup_content;
        },
        make_record_feature_popup(feature){
            // for records in a query result page or download
            if(!feature.hasOwnProperty('properties')){
                return '';
            }
            if(feature.properties.length < 1){
                return '';
            }
            // First update the property labels (keys) using a constant config.
            let mapped_props = {};
            let mapped_prop_keys = [];
            for(let [key, val] of Object.entries(feature.properties)){
                if(skip_excluded_property_key(key)){
                    continue;
                }
                if(val == null){
                    continue;
                }
                let mapped_key = map_property_key_to_field(key);
                mapped_props[mapped_key] = val;
                mapped_prop_keys.push(mapped_key);
            }
            // Consolidate properties with their links.
            let link_consolidate = JSON.parse(JSON.stringify(UI_RECORD_PROPERTY_LINK_CONSOLIDATE));
            for(let a_prop of mapped_prop_keys){
                if(a_prop.indexOf(' [URI]') >= 0){
                    continue;
                }
                for(let b_prop of mapped_prop_keys){
                    if(b_prop == a_prop){
                        continue;
                    }
                    if(b_prop.indexOf(' [URI]') < 0){
                        continue;
                    }
                    let b_prop_first = b_prop.split(' [URI]')[0];
                    if(a_prop.indexOf(b_prop_first) >= 0){
                        //b prop is the link for the a_prop.
                        link_consolidate[a_prop] = b_prop;
                    }
                }
            }
            // Make the HTML for the (mapped) properties and their values.
            let used_keys = [];
            let prop_content = [];
            let label_index = null;
            for(let [mapped_key, val] of Object.entries(mapped_props)){
                if(used_keys.indexOf(mapped_key) >=0){
                    continue;
                }
                let link_val = null;
                if(link_consolidate.hasOwnProperty(mapped_key)){
                    let link_prop = link_consolidate[mapped_key];
                    if(link_prop == null){
                        // Don't make a link with this field.
                        used_keys.push(link_prop);
                        continue;
                    }
                    if(mapped_props.hasOwnProperty(link_prop)){
                        link_val = mapped_props[link_prop];
                        used_keys.push(link_prop);
                    }
                }
                // Values for a property can be in a list/array, so make
                // this the worst.
                let val_list = null;
                if(Array.isArray(val)){
                    val_list = val;
                }
                else{
                    val_list = [val];
                }
                if(val_list == null){
                    continue;
                }
                // Iterate through the val list to make a list of HTML to generate.
                let val_html_list = [];
                let val_index = 0;
                for(let act_val of val_list){
                    let val_html = act_val;
                    if(link_val != null){
                        let act_link = link_val;
                        if(Array.isArray(link_val)){
                            if(val_index >= link_val.length){
                                // problem, no link at this value index.
                                continue;
                            }
                            // Assumes the URI for the act_val is at the same index
                            // as the act_val.
                            act_link = link_val[val_index];
                        }
                        act_link = use_all_items_href(act_link, BASE_URL, USE_TEST_ALL_ITEMS_HREF);
                        val_html = `<a target="_blank" href="${act_link}">${act_val}</a>`;
                    }
                    if(mapped_key == 'Thumbnail'){
                        val_html = `<img src="${act_val}" alt="Thumbnail image" style="max-width: 90%;" />`;
                    }
                    if(val_list.length > 1){
                        val_html = `<li>${val_html}</li>`;
                    }
                    val_html_list.push(val_html);
                    val_index += 1;
                }

                // Consolidate all of the val_html_list into one string.
                let all_vals_html = null;
                if(val_html_list.length == 1){
                    all_vals_html = val_html_list[0];
                }
                else if(val_html_list.length > 1){
                    all_vals_html = '<ul>' + val_html_list.join('\n') + '</ul>';
                }
                else{
                    continue;
                }
                let prop_html = (
                    `<dl class="row">
                    <dt class="col-5">${mapped_key}</dt>
                    <dd class="col-7">${all_vals_html}</dd>
                    </dl>
                    `
                );

                if(mapped_key == 'Item Label'){
                    label_index = prop_content.length;
                }
                if(mapped_key == 'Thumbnail' && label_index != null){
                    // Make sure the thumbnail is always after the item label.
                    prop_content.splice((label_index + 1), 0, prop_html);
                }
                else{
                    prop_content.push(prop_html);
                }
                used_keys.push(mapped_key);
            }
            var all_props = prop_content.join('\n');

            var popup_content = (
                `<div class="container geo_feature_popup">${all_props}</div>`
            );
            return popup_content;
        },
        make_item_feature_popup(feature){
            if(!this.item_json){
                return '';
            }
            let dt_class = 'geo_f_item_dt col-4';
            let dd_class = 'geo_f_item_dd col';
            let popup = (
                `<dl class="geo_f_item_row row">
                <dt class="${dt_class}">Item</dt>
                <dd class="${dd_class}">${this.item_json.label}</dd>
                </dl>`
            );
            if(!feature.hasOwnProperty('properties')){
                return `<div class="container-fluid">${popup}</div>`;
            }
            if(feature.properties.length < 1){
                return `<div class="container-fluid">${popup}</div>`;
            }
            let ref_url = null;
            let ref_label = null;
            let ref_type = null;
            if(feature.properties.hasOwnProperty('reference_uri')){
                ref_url = use_local_subjects_href(feature.properties.reference_uri, BASE_URL);
            }
            if(feature.properties.hasOwnProperty('reference_uri')){
                ref_label = feature.properties.reference_label;
            }
            if(feature.properties.hasOwnProperty('reference_type')){
                if(feature.properties.reference_type == 'specified'){
                    popup += (
                        `<dl class="geo_f_item_row row">
                        <dt class="${dt_class}">Location info source</dt>
                        <dd class="${dd_class}">Location information specified for this item</dd>
                        </dl>`
                    )
                }
                else if(ref_url && ref_label && feature.properties.reference_type == 'inferred'){
                    popup += (
                        `<dl class="geo_f_item_row row">
                        <dt class="${dt_class}">Location info source</dt>
                        <dd class="${dd_class}">Inferred from: <a target="_blank" href="${ref_url}">${ref_label}</a></dd>
                        </dl>`
                    )
                }
                else {

                }
            }
            if(feature.properties.hasOwnProperty('location_region_note')){
                let r_note = feature.properties.location_region_note;
                popup += (
                        `<dl class="geo_f_item_row row">
                        <dt class="${dt_class}">Location note</dt>
                        <dd class="${dd_class}">${r_note}</dd>
                        </dl>`
                    )
            }
            return `<div class="container-fluid">${popup}</div>`;
        },
        make_feature_popup(feature){
            if(this.map_type == 'generic' || !this.item_json){
                if(feature.hasOwnProperty('count')){
                    // for an area (count) aggregate summary feature
                    return this.make_area_count_feature_popup(feature);
                } else {
                    // for records in a query result page or download
                    return this.make_record_feature_popup(feature);
                }
                //return this.make_generic_feature_popup(feature);
            }
            return this.make_item_feature_popup(feature);
        },
        make_generic_feature_tooltip(feature){
            if(feature.hasOwnProperty('count')){
                return `<div>Area containing ${feature.count} items</div>`;
            }
            if(!feature.hasOwnProperty('properties')){
                return '';
            }
            if(feature.properties.length < 1){
                return '';
            }
            let act_prop_val = null;
            if(feature.properties.hasOwnProperty('label')){
                act_prop_val = {k: 'Item', v:feature.properties.label};
            }
            else if(feature.properties.hasOwnProperty('Item Label')){
                act_prop_val = {k: 'Item', v:feature.properties['Item Label']};
            }
            else{
                // use the first property
                for (var prop in feature.properties) {
                    act_prop_val = {k: prop, v:feature.properties[prop]};
                    break;
                }
            }
            if(!act_prop_val){
                return '';
            }
            return `<div>${act_prop_val.k}: ${act_prop_val.v}</div>`;
        },
        make_item_feature_tooltip(feature){
            if(!this.item_json){
                return '';
            }
            return ("<div>" + item_json.label + "</div>");
        },
        make_feature_tooltip(feature){
            if(this.map_type == 'generic' || !this.item_json){
                return this.make_generic_feature_tooltip(feature);
            }
            return this.make_item_feature_tooltip(feature);
        },
        gather_base_layers: function(){
            if(!this.map){
                return null;
            }
            for(tp of this.tileProviders){
                let tile_key = 'map-tile-' + this.ref_suffix + '-' + tp.name;
                if(this.$refs[tile_key] == null){
                    console.log('no basemap with key: ' + tile_key);
                    continue;
                }
                this.base_layers[tp.name] = this.$refs[tile_key][0].mapObject;
            }
        },
        add_google_tiles: function() {
            if(this.added_google_tiles){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(this.$refs[this.l_controls_ref] == null){
                console.log('no item: ' + this.l_controls_ref);
                return null;
            }
            if(this.$refs[this.map_ref] == null){
                console.log('no item: ' + this.map_ref);
                return null;
            }
            // console.log(this.map);
            for(let gtile_config of this.google_tile_configs){
                if(this.added_google_tile_types.indexOf(gtile_config.type) >= 0){
                    // Don't add the same layer twice!
                    continue;
                }
                let gtile = L.gridLayer.googleMutant(gtile_config);
                this.base_layers[gtile.options.name] = gtile;
                if(gtile_config.type == 'satellite' && this.default_tilelayer_name == 'Google Aerial'){
                    // Add support for over-zooming satellite.
                    this.map.addLayer(gtile);
                }
                this.$refs[this.l_controls_ref].mapObject.addBaseLayer(
                    gtile, gtile.options.name
                );
                this.added_google_tile_types.push(gtile_config.type);
            }
            this.added_google_tiles = true;
        },
        add_map_scale: function(){
            if(this.map_scale != null){
                //Already created.
                return null;
            }
            if(!this.map){
                // Map isn't ready
                return null;
            }
            console.log('MAP SCALE creation');
            let map_scale = L.control.scale(this.map_scale_options).addTo(this.map);
            this.map_scale = map_scale;
        },
        count_style: function(gradient_key, act_count, max_count, percentile=null){
            let act_gradient = COLOR_GRADIENTS[MAP_DEFAULT_COLOR_GRADIENT_KEY];
            if(gradient_key in COLOR_GRADIENTS){
                act_gradient = COLOR_GRADIENTS[gradient_key];
            }
            let normalized_count = act_count / max_count;
            if (typeof percentile === 'number' && typeof this.percentile_color_influence === 'number'){
                if(this.percentile_color_influence > 0 && this.percentile_color_influence <= 1 ){
                    // Use the percentile value in determining the normalized count
                    // that gives the color value.
                    normalized_count = (
                        normalized_count * (1 - this.percentile_color_influence)
                        + (percentile * this.percentile_color_influence)
                    );
                }
            }
            let hex_color = make_hex_color_in_gradient(
                normalized_count,
                act_gradient
            );
            let fill_opacity = (
                ((act_count / max_count) * 0.5 ) + 0.20
            );
            return {
                color: hex_color,
                fillOpacity: fill_opacity,
                weight: 1.5,
            };
        },
        polygon_count_style: function(feature){
            if(feature.hasOwnProperty('percentile')){
                return this.count_style(
                    feature.gradient_key,
                    feature.count,
                    feature.max_count,
                    feature.percentile,
                );
            }
            return this.count_style(
                feature.gradient_key,
                feature.count,
                feature.max_count,
            );
        },
        circle_count_style: function(gradient_key, act_count, max_count, percentile=null){
            let marker_opts = this.count_style(gradient_key, act_count, max_count, percentile);
            marker_opts.radius = Math.round(30 * (act_count / max_count), 0) + 5;
            marker_opts.fillColor = marker_opts.color;
            marker_opts.weight = 1;
            marker_opts.opacity = 0.95;
            marker_opts.fillOpacity = 0.8;
            return marker_opts;
        },
        circle_pointToLayer: function(feature,  latlng){
            let marker_opts = null;
            if(feature.hasOwnProperty('percentile')){
                marker_opts = this.circle_count_style(
                    feature.gradient_key,
                    feature.count,
                    feature.max_count,
                    feature.percentile,
                );
            }
            else{
                marker_opts = this.circle_count_style(
                    feature.gradient_key,
                    feature.count,
                    feature.max_count,
                );
            }
            return L.circleMarker(latlng, marker_opts);
        },
        circle_record_style: function(record_layer_index){
            let fill_color = '#332288';
            let radius = 9;
            if(record_layer_index >= 0){
                radius -= (record_layer_index * 2);
                let color_i = record_layer_index % COLOR_PALLET.length;
                if( record_layer_index == 0){
                    color_i = 0;
                }
                fill_color = COLOR_PALLET[color_i];
            }
            if(radius < 6){
                radius = 6;
            }
            // make an outline color that's blended with white for contrast.
            let gradient_list = [
                {v: 0, color: '#FFFFFF', },
		        {v: 1, color: fill_color, },
            ];
            let outline_color = make_hex_color_in_gradient(0.5, gradient_list);
            let marker_opts = {
                radius: radius,
                fillColor: fill_color,
                color: outline_color,
                weight: 1,
				opacity: 1,
				fillOpacity: 0.9,
                boostType: 'balloon',
                boostScale: 3,
                boostExp: 0.25,
            };
            return marker_opts;
        },
        circle_record_pointToLayer: function(feature,  latlng){
            let record_layer_index = -1;
            if(feature.hasOwnProperty('record_layer_index')){
                record_layer_index = feature.record_layer_index;
            }
            let marker_opts = this.circle_record_style(record_layer_index);
            return L.circleMarker(latlng, marker_opts);
        },
        make_legend_example_values: function(min_count, max_count){
            let example_div = 5;
            let max_min_dif =  max_count - min_count;
            let increment = max_min_dif / example_div;
            if(increment < 1){
                increment = 1;
            }
            let example_values = [];
            for(let act_val = min_count; act_val < max_count; act_val += increment){
                let round_val = Math.round(act_val, 0);
                if(example_values.indexOf(round_val) >=0 ){
                    continue
                }
                example_values.push(round_val);
            }
            if(example_values.indexOf(max_count) < 0){
                example_values.push(max_count);
            }
            return example_values;
        },
        make_layer_legend: function(act_layer, legend_key){
            if(!act_layer.hasOwnProperty('min_count')){
                return null;
            }
            if(!act_layer.hasOwnProperty('max_count')){
                return null;
            }
            let example_values = this.make_legend_example_values(
                act_layer.min_count,
                act_layer.max_count
            );
            let legend = JSON.parse(JSON.stringify(this.legend_config));
            legend.ov_id = act_layer.ov_id;
            legend.label = act_layer.label;
            legend.icon = null;
            legend.label_edit_ok = false;
            legend.type = 'count-summary';
            legend.geo_json_id = this.get_current_geo_json_id();

            if(this.overlay_icons.hasOwnProperty(act_layer.ov_id)){
                if(this.iOS() || this.isSafari()){
                    legend.icon = this.safari_overlay_icons[act_layer.ov_id];
                }
                else{
                    legend.icon = this.overlay_icons[act_layer.ov_id];
                }
            }
            legend.min_count = act_layer.min_count;
            legend.max_count = act_layer.max_count;
            let l_gradient_parts = ['to right'];
            if(legend_key != 'heat_style'){
                legend[legend_key] = [];
            }
            for(let act_count of example_values){
                let percentile = null;
                if(act_layer.hasOwnProperty('all_counts')){
                    percentile = this.get_percentile_of_val(act_layer.all_counts, act_count);
                }
                // console.log('legend count ' + act_count + ' is percentile ' + percentile);
                let opts = this.circle_count_style(
                    this.selected_gradient_key,
                    act_count,
                    act_layer.max_count,
                    percentile
                );
                opts.fillOpacity = 0.95;
                let rgb = convertToRGB(opts.color);
                let grad_part = `rgba(${rgb.join(', ')},1)`;
                l_gradient_parts.push(grad_part);
                let act_example = {
                    count: act_count,
                    radius: opts.radius,
                    svg_style: (
                        `fill:${opts.color};
                        fill-opacity:${opts.fillOpacity};
                        stroke:${opts.color};
                        stroke-width:${opts.weight};
                        stroke-opacity:1.0;`
                    ),
                };
                if(legend_key != 'heat_style'){
                    legend[legend_key].push(act_example);
                }
            }
            if(legend_key == 'heat_style'){
                legend[legend_key] = (
                    `min-height: 36px;
                    background-image: linear-gradient(${l_gradient_parts.join(', ')});`
                );
            }
            return legend;
        },
        make_record_layer_legend: function(act_layer){
            if(!act_layer.hasOwnProperty('ov_id')){
                return null;
            }
            if(!act_layer.hasOwnProperty('options')){
                return null;
            }
            if(!act_layer.options.hasOwnProperty('pointToLayer')){
                return null;
            }
            let legend = {
                ov_id: act_layer.ov_id,
                label: act_layer.label,
                icon: null,
                type: 'record',
                label_edit_ok: false,
                query_url: null,
                totalResults: null,
            };
            let record_layer_index = -1;
            if(act_layer.hasOwnProperty('record_layer_index')){
                record_layer_index = act_layer.record_layer_index;
            }
            if(act_layer.hasOwnProperty('query_url')){
                legend.query_url = act_layer.query_url;
            }
            if(act_layer.hasOwnProperty('totalResults')){
                legend.totalResults = act_layer.totalResults;
                legend.label_edit_ok = true;
            }
            let opts = this.circle_record_style(record_layer_index);
            opts.fillOpacity = 0.95;
            legend.crc = {
                radius: opts.radius,
                svg_style: (
                    `fill:${opts.fillColor};
                    fill-opacity:${opts.fillOpacity};
                    stroke:${opts.color};
                    stroke-width:${opts.weight};
                    stroke-opacity:1.0;`
                ),
            };
            return legend;
        },
        get_map_geodeep_from_geojson: function(act_geojson){
            if(act_geojson.category != 'oc-api:geo-facet'){
                return null;
            }
            if(!this.map){
                return null;
            }
            let feature = act_geojson.features[0];
            let geo_id_ex = feature.geometry.id.split('-');
			let geo_tile = geo_id_ex[geo_id_ex.length - 1];
            this.map.geodeep = geo_tile.length;
        },
        geojson_to_circle_data: function(act_geojson){
            if(act_geojson.category != 'oc-api:geo-facet'){
                return null;
            }
            if(!act_geojson.hasOwnProperty('max_count')){
                return null;
            }
            let circle_geojson = JSON.parse(JSON.stringify(this.geo_facets_circles_default));
            circle_geojson.category = act_geojson.category;
            /*
			 * 1st we aggregate nearby tiles getting points for the center of each
			 * tile region
			 */
            let aggregated_tiles = {};
            for(let feature of act_geojson.features){
                let centroid = this.get_centroid(feature.geometry.coordinates[0]);
                let geo_id_ex = feature.geometry.id.split('-');
				let geo_tile = geo_id_ex[geo_id_ex.length - 1];
                let agg_tile_id = geo_tile.substring(0, (geo_tile.length -1));
                if(!(agg_tile_id in aggregated_tiles)) {
                    aggregated_tiles[agg_tile_id] = [];
                }
                let point_item = {
                    centroid: centroid,
                    count: feature.count,
                    id: replaceURLparameter(feature.id, 'allevent-geotile', agg_tile_id),
                }
                aggregated_tiles[agg_tile_id].push(point_item);
            }
            /*
			 * 2nd we compute the weighted average for nearby tile center points
			 * based on their counts. This will help make the map look less like a grid
			 */
            let min_count = null;
            let max_count = 0;
            let tindex = 0;
            let count_keyed_points = {};
            let count_keys = [];
            for(let agg_tile_id in aggregated_tiles){
                tindex += .000001;
                let total_count = 0;
                let sum_lat = 0;
                let sum_lng = 0;
                for(let point_item of aggregated_tiles[agg_tile_id]){
                    total_count += point_item.count;
                    sum_lat += point_item.centroid[1] * point_item.count;
                    sum_lng += point_item.centroid[0] * point_item.count;
                }
                if(max_count < total_count){
                    max_count = total_count;
                }
                if(min_count == null || total_count < min_count){
                    min_count = total_count;
                }
                let mean_lat = sum_lat / total_count;
                let mean_lng = sum_lng / total_count;
                let point_feature = {
                    'type': 'Feature',
                    'id': aggregated_tiles[agg_tile_id][0].id,
                    'count': total_count,
                    'max_count': null,
                    'geometry': {
                        'type': 'Point',
                        'coordinates': [mean_lng, mean_lat],
                    },
                };
                count_key = total_count + tindex;
                count_keys.push(count_key);
                count_keyed_points[count_key] = point_feature;
            }
            // Set min and max count limits for the circle feature geojson.
            circle_geojson.min_count = min_count;
            circle_geojson.max_count = max_count;
            /*
			 * 3rd we sort the points in descending order of count so the point features with
			 * the highest counts will be rendered lower
			 */
			count_keys.sort(function(a, b){return b-a;});
            for(let count_key of count_keys){
                let feature = count_keyed_points[count_key];
                feature.max_count = max_count;
                feature.gradient_key = this.selected_gradient_key;
                circle_geojson.features.push(feature);
            }
            return circle_geojson;
        },
        geojson_to_heatmap_data: function(act_geojson){
            if(act_geojson.category != 'oc-api:geo-facet'){
                return null;
            }
            if(!act_geojson.hasOwnProperty('max_count')){
                return null;
            }
            let heatmap_data = JSON.parse(JSON.stringify(this.heatmap_data_default));
            heatmap_data.min_count = act_geojson.min_count;
            heatmap_data.max_count = act_geojson.max_count;
            heatmap_data.max = act_geojson.max_count;
            for(let feature of act_geojson.features){
                let centroid = this.get_centroid(feature.geometry.coordinates[0]);
                let data_item = {
                    // convert geojson order to lat/lng
                    lat: centroid[1],
                    lng: centroid[0],
                    count: feature.count,
                }
                heatmap_data.data.push(data_item);
            }
            return heatmap_data;
        },
        remove_prior_overlays: function(){
            if(!this.map){
                return null;
            }
            // Removes prior geojson overlay layers from prior routing.
            if(this.map.hasOwnProperty('overlay_layers_by_id')){
                for(let ov_id in this.map.overlay_layers_by_id){
                    if(!this.map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                        continue;
                    }
                    let act_layer = this.map.overlay_layers_by_id[ov_id];
                    act_layer.removeFrom(this.map);
                    this.$refs[this.l_controls_ref].mapObject.removeLayer(
                        act_layer,
                    );
                    delete this.map.overlay_layers_by_id[ov_id];
                }
            }
            this.map.overlay_layers_by_id = null;
        },
        add_overlay_geojson_map_preview: function(){
            if(!this.geo_json){
                return null;
            }
            this.remove_prior_overlays();
            this.map.overlay_layers_by_id = {};
            let act_layer = L.geoJson(
                this.geo_json,
                {
                    onEachFeature: this.onEachFeatureFunction,
                },
            );
            act_layer.id = 'map-preview-layer-' + this.uuid;
            act_layer.label = 'Map Preview';
            act_layer.ref = 'map-preview';
            act_layer.ov_id = 'overlay-' + act_layer.id;
            act_layer.addTo(this.map, act_layer.label);
            this.$refs[this.l_controls_ref].mapObject.addOverlay(
                act_layer,
                act_layer.label
            );
            act_layer.bringToFront();
            this.map.overlay_layers_by_id[act_layer.ov_id] = act_layer;
            let bounds = act_layer.getBounds();
            this.map.fitBounds(bounds);
        },
        make_tile_facets_from_result_feature: function(cp_feature){
            // Use a result feature to make a tile feature in cases where there
            // are not tile facet features available.
            cp_feature.count = this.geo_json.totalResults;
            cp_feature.category = 'oc-api:geo-facet';
            cp_feature.geometry.type = 'Polygon';
            // Set up counts for styling
            cp_feature.max_count = cp_feature.count;
            cp_feature.gradient_key = this.selected_gradient_key;
            cp_feature.percentile = this.get_percentile_of_val([cp_feature.count], cp_feature.count);

            let act_zoom = 11;
            let req_geotile = getURLParameter(this.geo_json.id, 'allevent-geotile');
            if(req_geotile && req_geotile.length > 1){
                act_zoom = req_geotile.length - 1;
            }
            const [lon, lat] = cp_feature.geometry.coordinates;
            const tileDeg = 360 / Math.pow(2, act_zoom);

            // We want a square with ~1/8 the area of a tile
            // Area = side, so side = tileWidth / sqrt(8)
            const squareSide = tileDeg / Math.sqrt(8);
            const halfSide = squareSide / 1.75;
            // Construct square around the center point
            const squareCoords = [
                [lon - (halfSide * 1.25), lat - halfSide],
                [lon + (halfSide * 1.25), lat - halfSide],
                [lon + (halfSide * 1.25), lat + halfSide],
                [lon - (halfSide * 1.25), lat + halfSide],
                [lon - (halfSide * 1.25), lat - halfSide]  // Close the polygon
            ];
            cp_feature.geometry.coordinates = [squareCoords];

            // Make a feature collection for the tile facet.
            let cp_feature_data = {
                id: this.geo_json.id,
                ov_id: 'sqr',
                label: 'Area counts (squares)',
                ref: 'map-tile-geojson-search-map',
                type: "FeatureCollection",
                category: 'oc-api:geo-facet',
                min_count: cp_feature.count,
                max_count: cp_feature.count,
                all_counts: [cp_feature.count],
                features: [cp_feature],
            }
            return cp_feature_data;
        },
        add_overlay_layers: function() {
            if(!this.geo_json){
                return null;
            }
            if(!this.map){
                this.map = this.$refs[this.map_ref].mapObject;
                // this.ready_map_setup();
            }
            if(!this.map){
                console.log('What map?');
                return null;
            }
            if(this.$refs[this.l_controls_ref] == null){
                console.log('no item: ' + this.l_controls_ref);
                return null;
            }
            if(this.map_class == 'map_preview' && this.map_type != 'search'){
                console.log('add map_preview overlay');
                this.add_overlay_geojson_map_preview();
            }
            if(!this.frontend_state_obj){
                // not a search map, no search map overlays.
                return null;
            }

            // Use the frontend state object to set the selected color gradient,
            // if applicable.
            if(this.frontend_state_obj.hasOwnProperty('ovgrd')){
                if(this.frontend_state_obj.ovgrd in COLOR_GRADIENTS){
                    // console.log('frontend obj color gradient: ' + this.frontend_state_obj.ovgrd);
                    this.selected_gradient_key = this.frontend_state_obj.ovgrd;
                }
            }else{
                this.frontend_state_obj.ovgrd = MAP_DEFAULT_COLOR_GRADIENT_KEY;
            }

            // prevent mutation of the result.
            this.geo_tile_facets = this.cat_limit_feature_data(
                'oc-api:geo-facet',
                JSON.parse(JSON.stringify(this.geo_tile_facets_default))
            );
            this.geo_region_facets = this.cat_limit_feature_data(
                'oc-api:geo-contained-in-feature',
                JSON.parse(JSON.stringify(this.geo_region_facets_default))
            );
            this.geo_page_records = this.cat_limit_feature_data(
                'oc-api:geo-record',
                JSON.parse(JSON.stringify(this.geo_page_records_default))
            );
            if((!this.geo_tile_facets || this.geo_tile_facets.features.length < 1) && this.geo_page_records && this.geo_page_records.features.length > 0){
                // We need to make a tile feature from the first record of the result features
                console.log(
                    'No tile facets, but page records available, so make a tile feature from the first record.'
                );
                let cp_feature = JSON.parse(JSON.stringify(this.geo_page_records.features[0]));
                this.geo_tile_facets = this.make_tile_facets_from_result_feature(cp_feature);
                console.log(
                    'updated geo_tile_facets to have ' + this.geo_tile_facets.features.length + ' features.'
                );
                // Reset this so no endless recursion.
                this.geo_tile_facets_default = JSON.parse(JSON.stringify(this.geo_tile_facets));
            }

            // Removes prior geojson overlay layers from prior routing.
            this.remove_prior_overlays();

            // Gather all the types of 'raw' geojson used to build overlay layers.
            let overlays_geojson = [];
            if(this.geo_tile_facets && this.geo_tile_facets.features.length > 0){
                console.log(
                    'adding overlays_geojson: geo_tile_facets has ' + this.geo_tile_facets.features.length + ' features.'
                );
                overlays_geojson.push(this.geo_tile_facets);
            }
            if(this.geo_region_facets && this.geo_region_facets.features.length > 0){
                overlays_geojson.push(this.geo_region_facets);
            }
            if(this.geo_page_records && this.geo_page_records.features.length > 0){
                console.log(
                    'adding overlays_geojson: geo_page_records has ' + this.geo_page_records.features.length + ' features.'
                );
                overlays_geojson.push(this.geo_page_records);
            }
            if(this.geo_all_records && this.geo_all_records.features.length > 0){
                overlays_geojson.push(this.geo_all_records);
            }
            if(this.geojson_record_layers && this.geojson_record_layers.length > 0){
                for(let geo_rec_layer of this.geojson_record_layers){
                    geo_rec_layer.ref = "map-all-" + geo_rec_layer.ov_id + "-geojson-" + this.ref_suffix
                    overlays_geojson.push(geo_rec_layer);
                }
            }

            if(overlays_geojson.length < 1){
                return null;
            }

            this.map.overlay_layers_by_id = {};
            let i = -1;
            for(let act_geojson of overlays_geojson){
                let act_layer = null;
                if(act_geojson.hasOwnProperty('max_count')){
                    act_layer = L.geoJson(
                        act_geojson,
                        {
                            style: this.polygon_count_style,
                            onEachFeature: this.onEachFeatureFunction,
                        },
                    );
                    act_layer.min_count = act_geojson.min_count;
                    act_layer.max_count = act_geojson.max_count;
                    act_layer.all_counts = act_geojson.all_counts;
                    act_layer.id = act_geojson.id;
                    console.log('act_layer id is now:' + act_layer.id);
                }
                else{
                    act_layer = L.geoJson(
                        act_geojson,
                        {
                            pointToLayer: this.circle_record_pointToLayer,
                            onEachFeature: this.onEachFeatureFunction,
                        },
                    );
                    if(act_geojson.hasOwnProperty('record_layer_index')){
                        // Need for legend styling of record download layers
                        act_layer.record_layer_index = act_geojson.record_layer_index;
                        act_layer.query_url = act_geojson.query_url;
                        act_layer.totalResults = act_geojson.totalResults;
                    }
                    // console.log('act_layer is now a point layer');
                }
                i += 1;
                act_layer.ref = act_geojson.ref;
                act_layer.label = act_geojson.label;
                if(act_geojson.hasOwnProperty('ov_id')){
                    act_layer.ov_id = act_geojson.ov_id;
                }
                else{
                    act_layer.ov_id = 'overlay-' + i;
                }
                // Add the layer legend if applicable.
                act_layer.legend = this.make_layer_legend(act_layer, 'poly_list');
                if(!act_layer.hasOwnProperty('min_count')){
                    act_layer.legend = this.make_record_layer_legend(act_layer);
                }

                // Now add it again fresh.
                act_layer.addTo(this.map, act_geojson.label);
                this.$refs[this.l_controls_ref].mapObject.addOverlay(
                    act_layer,
                    act_geojson.label
                );
                act_layer.bringToFront();

                // Add to the object of all overlays keyed by their ID.
                this.map.overlay_layers_by_id[act_layer.ov_id] = act_layer;

                let l_geo_json = this.$refs[this.geojson_ref];
                if(l_geo_json){
                    this.map.removeLayer(l_geo_json);
                }

                if(!this.frontend_state_obj.hasOwnProperty('ov') && act_layer.ov_id == SEARCH_MAP_DEFAULT_OVERLAY_KEY){
                    // we don't have a frontend obj determined overlay, and we don't have any
                    // currently visible overlays, so make this active layer visible.
                    this.map.addLayer(act_layer);
                    this.map.visible_overlay_ids.push(act_layer.ov_id);
                }
                else{
                    this.map.removeLayer(act_layer);
                }

                // Add headmap if relevant.
                let heatmap_data = this.geojson_to_heatmap_data(act_geojson);
                let circle_geojson = this.geojson_to_circle_data(act_geojson);
                if(heatmap_data == null || circle_geojson == null){
                    continue;
                }

                // Extract the current geodeep property. This is needed to give a starting
                // value for increasing or decreasing the tile resolution controls.
                this.get_map_geodeep_from_geojson(act_geojson);

                // Make and add a circle layer
                let circle_layer = L.geoJson(
                    circle_geojson,
                    {
                        pointToLayer: this.circle_pointToLayer,
                        onEachFeature: this.onEachFeatureFunction,
                    },
                );
                circle_layer.ref = circle_geojson.ref;
                circle_layer.label = circle_geojson.label;
                circle_layer.ov_id = circle_geojson.ov_id;
                circle_layer.min_count = circle_geojson.min_count;
                circle_layer.max_count = circle_geojson.max_count;
                circle_layer.legend = this.make_layer_legend(circle_layer, 'circle_list');
                circle_layer.addTo(this.map, circle_layer.label);
                this.$refs[this.l_controls_ref].mapObject.addOverlay(
                    circle_layer,
                    circle_layer.label
                );
                circle_layer.bringToFront();
                this.map.removeLayer(circle_layer);
                this.map.overlay_layers_by_id[circle_layer.ov_id] = circle_layer;

                //Make and add the heatmap layer.
                // First, set up the color gradient for the heatmap.
                if(this.iOS()){
                    let frag_obj = this.geo_view_from_state_obj(this.frontend_state_obj);
                    if(!frag_obj.center){
                        console.log('skip heatmap when center is not yet set');
                        continue;
                    }
                }
                let act_heatmap_config = JSON.parse(JSON.stringify(this.heatmap_config));
                let feature_cnt = this.geo_tile_facets.features.length;
                if(feature_cnt >= 100){
                    let act_radius = act_heatmap_config.radius - Math.round(
                        (act_heatmap_config.radius * ((feature_cnt - 100) / 2000)),
                        0
                    );
                    if(act_radius > act_heatmap_config.radius){
                        act_radius = act_heatmap_config.radius;
                    }
                    if(act_radius < 8){
                        act_radius = 8;
                    }
                    console.log('tile features: ' + this.geo_tile_facets.features.length);
                    console.log('act_radius is: ' + act_radius);
                    act_heatmap_config.radius = act_radius;
                }

                act_heatmap_config.gradient = this.make_heatmap_gradient_config(
                    this.selected_gradient_key
                );
                let heatmap_layer = new HeatmapOverlay(act_heatmap_config);
                heatmap_layer.ref = heatmap_data.ref;
                heatmap_layer.label = heatmap_data.label;
                heatmap_layer.ov_id = heatmap_data.ov_id;
                heatmap_layer.min_count = heatmap_data.min_count;
                heatmap_layer.max_count = heatmap_data.max_count;
                heatmap_layer.setData(heatmap_data);
                heatmap_layer.legend = this.make_layer_legend(heatmap_layer, 'heat_style');
                heatmap_layer.addTo(this.map, heatmap_layer.label);
                this.$refs[this.l_controls_ref].mapObject.addOverlay(
                    heatmap_layer,
                    heatmap_layer.label
                );
                heatmap_layer.zIndex = 100;
                this.map.removeLayer(heatmap_layer);
                this.map.overlay_layers_by_id[heatmap_layer.ov_id] = heatmap_layer;
            }
        },
        finesse_item_view: function(){
            if(!this.map){
                return null;
            }
            if (this.map_type == 'search'){
                return null;
            }
            if(!('features' in this.geo_json)){
                return null;
            }
            if(this.geo_json.features.length > 1){
                for(let feat of this.geo_json.features){
                    if(feat.geometry.type != 'Point'){
                        continue;
                    }
                    if(!feat.hasOwnProperty('properties')){
                        continue;
                    }
                    if(feat.properties.hasOwnProperty('geo_zoom')){
                        this.item_geo_zoom = feat.properties.geo_zoom;
                    }
                }
                if(!this.item_geo_zoom){
                    // None of the features here have zoom level set by the database,
                    // so just default to no set view.
                    return null;
                }
            }
            if(!this.item_geo_zoom && this.geo_json.features[0].geometry.type != 'Point'){
                console.log('Use extent derived zoom for ' + this.geo_json.features[0].geometry.type);
                return null;
            }
            let zoom = this.default_zoom;
            if(this.map_type in this.map_type_default_zooms){
                zoom = this.map_type_default_zooms[this.map_type];
            }
            if(this.item_geo_zoom){
                zoom = this.item_geo_zoom;
                console.log('Item has set zoom view: ' + zoom);
            }
            let center = this.map.getCenter();
            this.map.setView(center, zoom);
        },
        fit_bounds: function(){
            if(!this.geo_json && GEO_JSON != null){
                this.geo_json = GEO_JSON;
            }
            if(!this.map){
                return null;
            }
            let frag_obj_set_view = this.set_map_view_from_frontend_state_obj();
            if (frag_obj_set_view){
                console.log('Frontend state object set map bounds.');
                return null;
            }
            console.log('Use overlay layer to fit bounds.');
            let act_overlay_layer = null;
            if(this.map.hasOwnProperty('overlay_layers_by_id')){
                if (this.map.overlay_layers_by_id && this.map.overlay_layers_by_id.hasOwnProperty('sqr')){
                    act_overlay_layer = this.map.overlay_layers_by_id.sqr;
                }
            }
            if(act_overlay_layer == null){
                act_overlay_layer = this.$refs[this.geojson_ref];
                if(act_overlay_layer == null){
                    console.log('no geo-json layer item: ' + this.geojson_ref);
                    return null;
                }
            }
            if(act_overlay_layer == null){
                console.log('no overlay layer for fitbounds');
                return null;
            }
            this.map.auto_fit = true;
            let bounds = act_overlay_layer.getBounds();
            this.map.fitBounds(bounds);
            console.log(bounds);
            this.map.auto_fit = false;
        },
        frontend_obj_overlays_prep: function(){
            if(this.map_type != 'search'){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(!this.map.hasOwnProperty('overlay_layers_by_id')){
                // No overlay layers by ID added to the map.
                return null;
            }
            if(!this.frontend_state_obj.hasOwnProperty('ov')){
                // No overlays passed from frontend state object.
                return null;
            }
            if(this.frontend_state_obj.ov == null || this.frontend_state_obj.ov == ''){
                // No overlays passed from frontend state object.
                delete this.frontend_state_obj.ov;
                if(this.map_hash_obj){
                    this.map_hash_obj.frontend_state_obj = this.frontend_state_obj;
                }
                return null;
            }
            if(typeof this.frontend_state_obj.ov === 'string'){
                // No overlays passed from frontend state object.
                this.frontend_state_obj.ov = [this.frontend_state_obj.ov];
            }
            let valid_ov_ids = [];
            for(let fr_ov_id of this.frontend_state_obj.ov){
                if(!this.map.overlay_layers_by_id.hasOwnProperty(fr_ov_id)){
                    continue;
                }
                valid_ov_ids.push(fr_ov_id);
            }
            this.frontend_state_obj.ov = valid_ov_ids;
            if(valid_ov_ids.length < 0){
                // no valid overlays found, so delete this key and skip out.
                delete this.frontend_state_obj.ov;
                if(this.map_hash_obj){
                    this.map_hash_obj.frontend_state_obj = this.frontend_state_obj;
                }
                return null;
            }

            for(let ov_id in this.map.overlay_layers_by_id){
                if(!this.map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                    continue;
                }
                let act_layer = this.map.overlay_layers_by_id[ov_id];
                if(this.frontend_state_obj.ov.indexOf(act_layer.ov_id) >=0){
                    if(this.map.visible_overlay_ids.indexOf(act_layer.ov_id) < 0){
                        this.map.visible_overlay_ids.push(act_layer.ov_id);
                    }
                    console.log('activate ' + act_layer.ov_id);
                    this.map.addLayer(act_layer);
                }
                else{
                    console.log('deactivate ' + act_layer.ov_id);
                    this.map.removeLayer(act_layer);
                }
            }
            console.log('end frontend_obj_overlays_prep');
        },
        add_bbox_obj: function(){
            if(!this.geo_json){
                return null;
            }
            if(!this.map){
                return null;
            }
            if(!this.frontend_state_obj){
                // not a search map, no search map controls.
                return null;
            }
            if(this.map.hasOwnProperty('bbox_zoom')){
                // Deactivate this, because we changed state
                this.map.bbox_zoom.deactivate();
                this.map.bbox_zoom.reset_points();
                let state_key = this.get_current_state_key();
                if(this.route_map_legends == null){
                    this.route_map_legends = {};
                }
                // Reset the map legends state key until we're
                // actually ready to use the zoom again.
                if(state_key in this.route_map_legends){
                    //delete this.route_map_legends[state_key];
                }
                return null;
            }
            var options = {
                modal: true,
                title: "Box area filter"
            };
            var bbox_zoom = L.control.zoomBox(options);
            this.map.update_with_bbox_query = this.update_with_bbox_query;
            this.map.addControl(bbox_zoom);
            this.map.bbox_zoom = bbox_zoom;
        },
        ready_map_setup: function(){
            this.map = this.$refs[this.map_ref].mapObject;
            this.map._layersMaxZoom = MAX_ZOOM;
            this.map.auto_fit = true;
            this.map.legends = null;
            this.gather_base_layers();
            this.add_google_tiles();
            this.get_item_location_info();
            this.add_search_map_hash();
            this.add_overlay_layers();
            this.add_search_map_extra_controls();
            this.add_bbox_obj();
            this.frontend_obj_overlays_prep();
            this.update_map_legends();
            this.fit_bounds();
            this.finesse_item_view();
            this.add_map_scale();
            // this.update_map_legends();
            this.map.auto_fit = false;
            this.map.overlay_ready = true;
        },
        map_size_reset: function(){
            if(!this.geo_json && GEO_JSON != null){
                console.log('Missing this.geo_json, use GEO_JSON');
                this.geo_json = GEO_JSON;
            }
            if(this.$refs[this.map_ref] == null){
                console.log('no item: ' + this.map_ref);
                return null;
            }
            setTimeout(() => {
                // wait a bit so the geojson layer is available.
                try {
                    this.$refs[this.map_ref].mapObject.invalidateSize();
                } catch (error) {
                    console.log('Map not yet ready to invalidateSize()');
                    console.log(error);
                }
            }, 100);
        },
        get_item_location_info: function() {
            if(!this.geo_json || !this.item_json){
                return null;
            }
            for(let feat of this.geo_json.features){
                if(!feat.hasOwnProperty('properties')){
                    continue;
                }
                if(!feat.properties.hasOwnProperty('href')){
                    continue;
                }
                if(feat.properties.href != this.item_json.id){
                    continue;
                }
                if(feat.properties.hasOwnProperty('location_precision_factor')){
                    this.location_precision_factor = feat.properties.location_precision_factor;
                }
                if(feat.properties.hasOwnProperty('location_precision_note')){
                    this.location_precision_note = feat.properties.location_precision_note;
                }
                if(feat.geometry.type == 'Point' && feat.properties.hasOwnProperty('geo_zoom')){
                    this.item_geo_zoom = feat.properties.geo_zoom;
                }
            }
        },
        update_map_setup: function(){
            if(!this.map){
                this.map = this.$refs[this.map_ref].mapObject;
                // this.ready_map_setup();
            }
            if(!this.map){
                console.log('What map?');
                return null;
            }
            this.map.overlay_ready = false;
            if(this.map_type == 'search' && this.map_hash_obj){
                this.map_hash_obj.frontend_state_obj = this.frontend_state_obj;
                this.map.hash_obj = this.map_hash_obj;
            }
            this.add_overlay_layers();
            this.map_size_reset();
            this.frontend_obj_overlays_prep();
            this.fit_bounds();
            this.finesse_item_view();
            this.get_item_location_info();
            this.update_map_legends();
            this.add_map_scale();
            this.add_bbox_obj();
            // console.log('updated map');
            // console.log('current frontend state');
            // console.log(this.frontend_state_obj);
            this.map.overlay_ready = true;
            console.log('update done...');
            console.log(this.geo_json);
        },
        fetch_geojson: function() {
            if(!this.geo_json_url){
                return null;
            }
            if(this.geo_json){
                return null;
            }
            console.log('fetch geojson from: ' + this.geo_json_url);
            const requestOptions = {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json, application/geo+json, application/vnd.geo+json,',
                    },
                };
            fetch(
                (this.geo_json_url),
                requestOptions,
            )
            .then(this.loading = false)
            .then(response => response.json())
            .then(json => {
                this.geo_json = json;
                console.log('fetched geojson');
                console.log(this.geo_json);
            });
        },
        reset_overlay_layer_control: function(act_layer){
            this.$refs[this.l_controls_ref].mapObject.removeLayer(
                act_layer,
            );
            this.$refs[this.l_controls_ref].mapObject.addOverlay(
                act_layer,
                act_layer.label
            );
        },
        update_layer_label: function(legend){
            let ov_id = legend.ov_id;
            console.log('update layer id: ' + ov_id + ' to label ' + legend.label);
            if(!this.map.overlay_layers_by_id.hasOwnProperty(ov_id)){
                return null;
            }

            let act_layer = this.map.overlay_layers_by_id[ov_id];
            act_layer.label = legend.label;

            let dl_layer_ov_ids = [];
            if(this.geojson_record_layers && this.geojson_record_layers.length > 0){
                // mutates the object everywhere.
                for(let geo_rec_layer of this.geojson_record_layers){
                    if(geo_rec_layer.ov_id === ov_id){
                        geo_rec_layer.label = legend.label;
                    }
                    dl_layer_ov_ids.push(geo_rec_layer.ov_id);
                }
            }
            // iterate through all of the download layers to reset their overlay
            // control.
            for(let loop_ov_id of dl_layer_ov_ids){
                if(!this.map.overlay_layers_by_id.hasOwnProperty(loop_ov_id)){
                    continue;
                }
                let loop_layer = this.map.overlay_layers_by_id[loop_ov_id];
                if(loop_ov_id == ov_id){
                    // make sure we pass in the new label.
                    loop_layer.label = act_layer.label;
                }
                this.reset_overlay_layer_control(loop_layer);
            }
            // toggle visibility to update the map overlay menu
            if(this.map.visible_overlay_ids.indexOf(act_layer.ov_id) >= 0){
                this.map.removeLayer(act_layer);
                this.map.addLayer(act_layer);
            }
            else{
                this.map.addLayer(act_layer);
                this.map.removeLayer(act_layer);
            }
        },
    },
    components: {
      'l-popup': l_popup,
      'l-img-overlay' : l_img_overlay,
      'l-tile-layer': l_tile_layer,
      'l-geo-json': l_geo_json,
      'l-marker': l_marker,
      'l-map': l_map,
      'map-legends': vc_map_legends,
      'map-color-ui': vc_map_color_ui,
    },
});




/* TODO: https://www.patrick-wied.at/static/heatmapjs/example-heatmap-leaflet.html */









</script>



{% endblock %}